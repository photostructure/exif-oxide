# exif-oxide Design Document

_A comprehensive guide for new engineers working on the exif-oxide project_

## Overview

exif-oxide is a **high-performance Rust implementation** of Phil Harvey's ExifTool, designed to provide 10-20x performance improvements while maintaining 100% compatibility with ExifTool's metadata extraction capabilities. The project leverages 25 years of ExifTool's accumulated camera-specific knowledge while adding the performance and memory safety benefits of Rust.

## Project Philosophy

### 1. Respect ExifTool's Legacy

- **Phil Harvey has been developing ExifTool for 25 years** - the Perl codebase contains invaluable camera-specific quirks and edge cases
- **We're not inventing anything here** - how ExifTool handles it is the correct way
- All implementations maintain tag name and structure compatibility
- Comprehensive attribution to ExifTool sources throughout codebase

### 2. Performance Without Compromise

- **Target**: Sub-10ms processing for typical JPEG files (vs ExifTool's 100-200ms)
- **Memory Safety**: Zero unsafe code in core parsing logic
- **Embedded Image Extraction**: First-class support for thumbnails and previews

### 3. Incremental Development

- Learn first, optimize later - don't over-engineer early implementations
- Incrementally improve our tooling -- if some tool fails, don't just route around the damage! We've probably hit a scenario that we didn't understand or make accommodations for properly. The person breaking the tool has the perfect context to figure out what went wrong, and should work to make the tool work smoothly for the Engineers of Tomorrow.
- Document surprises and gotchas as they're discovered
- Update TODO lists and other relevant documentation when tasks are completed

### Data Flow Architecture

```
File Input → Format Detection → Format-Specific Parser → IFD Parser → Tag Extraction → Value Processing
     ↓              ↓                    ↓               ↓              ↓              ↓
   Any of 26    Magic numbers      JPEG/TIFF/PNG      Universal     496 EXIF +    Type-safe
   formats      (sub-1ms)          /Container          IFD chain     34 Canon      conversions
                                   parsers             parser        tags
```

## Key Design Decisions

### 1. Automatic code extraction

**Strategy**: When possible, Rust code is autogenerated from ExifTool's Perl modules rather than manual porting.

**Why**: Ensures 100% compatibility and enables easy updates when ExifTool adds new camera support.

See [`doc/SYNC-DESIGN.md`](SYNC-DESIGN.md) for details

### 2. Multi-Format Support Strategy

**Central Dispatch Pattern**: Single `find_metadata_segment()` function works across all 26 formats.

```rust
// Universal API - format detection is automatic
let metadata = find_metadata_segment("photo.cr2")?;  // Works with any format
let exif = read_basic_exif("video.mp4")?;           // Even video files
```

**Format-Specific Optimizations**:

- **TIFF dual-mode**: Metadata-only parsing reduces memory usage by 90%
- **Streaming parsers**: Container formats don't load entire files
- **Early termination**: Stop parsing when no more metadata is possible

### 3. Memory Management

**Zero-Copy Design**:

- Use byte slices instead of string allocations where possible
- Memory-mapped files for large RAW formats
- Streaming for container formats (QuickTime, RIFF)

**Safety First**:

- All parsing includes bounds checking
- Maximum recursion depth for IFDs (prevents infinite loops)
- Graceful handling of malformed data

### 4. Error Handling Philosophy

**Graceful Degradation**: Continue parsing despite errors (matches ExifTool behavior)

- Skip malformed entries rather than failing entirely
- Collect warnings separately from errors
- Provide detailed error context (file offset, tag ID)

**Result Types**:

```rust
Result<Option<T>>  // "may not exist" vs "error occurred"
Result<T>          // "must exist" or error
```

### 5. Performance Strategy

**Lazy Parsing**:

- Build tag index without parsing values
- Only decode requested tags
- Cache parsed values for repeated access

**Static Optimizations**:

- Generated lookup tables (zero runtime overhead)
- Compiled regex patterns (lazy_static)
- Efficient magic number matching

**Memory Efficiency**:

- Mmap large files when beneficial
- Reuse buffers across operations
- Smart string interning for common values

### 6. Compatibility Layer

## Maintenance & Updates

### ExifTool Synchronization

**Attribution System**: All ExifTool-derived code includes source attribution

```rust
#![doc = "EXIFTOOL-SOURCE: lib/Image/ExifTool/Canon.pm"]
#![doc = "EXIFTOOL-SOURCE: lib/Image/ExifTool/Exif.pm"]
```

**Sync Tool**: Simple command-line tool for tracking changes

```bash
# Check current ExifTool dependencies
cargo run --bin exiftool_sync scan
# Show files impacted by ExifTool update
cargo run --bin exiftool_sync diff 13.26 13.27
```

**Update Process**:

1. Monthly ExifTool release check
2. Run sync tool to identify impacted files
3. Update implementations as needed
4. Regenerate auto-generated code (`cargo build`)
5. Run compatibility tests

### Testing Strategy

**Multi-Layer Testing**:

- **Unit tests**: Synthetic data for edge cases (71 tests)
- **Integration tests**: Real ExifTool test images (25 tests)
- **Format tests**: All supported formats (91 tests)
- **Compatibility tests**: Output comparison with ExifTool

**Performance Benchmarks**:

```bash
cargo bench                    # Run all benchmarks
cargo test test_*_performance  # Performance validation tests
```

**ExifTool Test Suite Integration**:

- Uses ExifTool's own test images from `exiftool/t/images/`
- Validates against ExifTool verbose output
- Tests both success cases and error handling

## Security & Safety

### Memory Safety

**Zero Unsafe Code**: Core parsing logic uses no unsafe blocks

- All buffer access is bounds-checked
- `get()` method used instead of indexing to prevent panics
- Graceful handling of malformed data

**Recursion Limits**:

```rust
const MAX_IFD_DEPTH: usize = 10;  // Prevent infinite loops
const MAX_IFD_SIZE: usize = 1024 * 1024;  // 1MB limit
```

### Robustness

**Graceful Degradation**: Continue parsing despite errors

- Skip malformed entries rather than failing
- Collect warnings for debugging
- Return partial results when possible

**Attack Surface Minimization**:

- File size limits prevent memory exhaustion
- Depth limits prevent stack overflow
- Timeout mechanisms for complex parsing

**Future Security Measures**:

- Fuzzing-based testing infrastructure
- Address sanitizer in CI
- Security audit of binary parsing code

## Tribal knowledge

**REMEMBER: `third-party/exiftool` has figured this all out already -- the
answer for literally any parsing or heurstic issue is in that codebase. We MUST
follow it EXACTLY.

### 1. JPEG Parsing Gotchas

**Segment Length Includes Itself**: JPEG segment lengths include the 2 bytes for the length field

```rust
// WRONG: Using segment length directly
let data_size = segment_length;

// CORRECT: Subtract length field size
let data_size = segment_length - 2;
```

**Marker Padding**: JPEG markers can have unlimited 0xFF padding bytes

```rust
// Must consume all 0xFF bytes until finding non-0xFF marker
while data[pos] == 0xFF {
    pos += 1;
}
let marker = data[pos];
```

**APP1 Size Limit**: APP1 segments limited to 64KB (65533 bytes after length field)

### 2. EXIF/TIFF Structure Complexities

**Byte Order Detection**:

- "II" (0x4949) = Little-endian (Intel)
- "MM" (0x4D4D) = Big-endian (Motorola)
- Magic number always 42 (0x002A or 0x2A00 depending on endianness)

**IFD Entry Values**:

```rust
// Critical: Value storage depends on size
if format.size() * count <= 4 {
    // Value stored inline in offset field
    let value = &entry_bytes[8..12];
} else {
    // Offset field contains pointer to actual data
    let offset = read_u32(&entry_bytes[8..12], byte_order);
    let value = &data[offset as usize..];
}
```

**Offset Calculations**:

- **JPEG files**: Offsets relative to TIFF header (after "Exif\0\0")
- **TIFF files**: Offsets relative to file start
- **Container formats**: Offsets relative to metadata segment start

### 3. Multi-Format Parsing Challenges

**Format-Specific Offset Handling**:

```rust
// JPEG: TIFF header is inside APP1 segment
let tiff_offset = if is_jpeg {
    find_exif_marker_position() + 6  // After "Exif\0\0"
} else {
    0  // TIFF formats start at file beginning
};
```

**Container Format Patterns**:

- **RIFF**: Little-endian, word-aligned chunks
- **QuickTime**: Big-endian, 32-bit or 64-bit atom sizes
- **PNG**: CRC-validated chunks, stop at IDAT

### 4. Memory Management Critical Points

**TIFF Dual-Mode Parsing**:

```rust
// For tag reading only - 90% memory savings
TiffParseMode::MetadataOnly  // Reads only IFD chain

// For binary extraction - full file access needed
TiffParseMode::FullFile      // Loads entire file
```

**Bounds Checking Pattern**:

```rust
// ALWAYS check bounds before accessing
if offset + size > data.len() {
    return Err(ExifError::InvalidOffset(offset));
}
// Safe to access data[offset..offset + size]
```

### 5. DateTime Intelligence Pitfalls

**GPS Coordinate Validation**:

```rust
// GPS (0,0) is INVALID per exiftool-vendored
if lat.abs() < 0.0001 && lng.abs() < 0.0001 {
    return false;  // Placeholder coordinates
}
```

**Timezone Offset Limits**:

```rust
// RFC 3339 compliance - ±14 hours maximum
if delta_minutes.abs() > 14 * 60 {
    return None;  // Beyond valid timezone range
}
```

### 6. Binary Data Extraction Issues

**JPEG Validation with Padding**:

```rust
// WRONG: Expect EOI at exact end
data.ends_with(&[0xFF, 0xD9])

// CORRECT: Search for EOI in last 32 bytes (padding common)
let search_start = data.len().saturating_sub(32);
data[search_start..].windows(2).any(|w| w == [0xFF, 0xD9])
```

**Format Flexibility**:

```rust
// Tags can be stored in different formats
fn get_numeric_u32(tag_id: u16) -> Option<u32> {
    match self.entries.get(&tag_id)? {
        ExifValue::U32(v) => Some(*v),
        ExifValue::U16(v) => Some(*v as u32),
        ExifValue::Undefined(data) if data.len() >= 4 => {
            // Coerce binary data to u32
            Some(u32::from_le_bytes([data[0], data[1], data[2], data[3]]))
        },
        _ => None,
    }
}
```

### 7. XMP Parsing Complications

**UTF-16 Detection**:

```rust
// Check for UTF-16 BOM patterns
if data.len() >= 2 {
    match &data[0..2] {
        [0x00, _] => Encoding::Utf16Be,
        [_, 0x00] => Encoding::Utf16Le,
        _ => Encoding::Utf8,
    }
}
```

**Namespace Handling**:

```rust
// xmlns declarations can appear anywhere in XML
// Must maintain dynamic namespace registry
let mut namespaces = HashMap::new();
namespaces.insert("dc".to_string(), "http://purl.org/dc/elements/1.1/".to_string());
```

### 8. Performance Optimization Lessons

**Lazy Static Pattern**:

```rust
lazy_static! {
    static ref EXIF_REGEX: Regex = Regex::new(r"pattern").unwrap();
    static ref TIMEZONE_FINDER: DefaultFinder = DefaultFinder::new();
}
// Compile once, use many times
```

**Pre-allocation Strategy**:

```rust
// Pre-allocate with reasonable capacity
let mut buffer = Vec::with_capacity(MAX_EXPECTED_SIZE);
let mut tags = HashMap::with_capacity(100);  // Typical EXIF file has ~50-100 tags
```

### 9. Testing Strategy Insights

**Use a copy of ExifTool's Test Images**:

- First check in `$REPO_ROOT/test-images`, there's a bunch in there already
- Then check for files located in `exiftool/t/images/` -- but before using them in integration tests, they must be copied into `$REPO_ROOT/test-images/$make/$model.$ext`
- Ask the user for missing examples of more modern cameras (ExifTool may not have very recent make/models)
- Provides excellent real-world coverage
- Contains edge cases and manufacturer variations

**Layer Test Complexity**:

1. **Unit tests**: Synthetic data for specific edge cases -- but be sure that the heuristics EXACTLY match ExifTool
2. **Integration tests**: Real files with expected outputs
3. **Compatibility tests**: Compare against ExifTool output
4. **Performance tests**: Validate timing requirements


### 10. Common Rust Patterns for Binary Parsing

**Error Handling Pattern**:

```rust
// Continue on non-fatal errors
match parse_tag(&data) {
    Ok(tag) => tags.insert(tag.id, tag.value),
    Err(e) => {
        warnings.push(format!("Failed to parse tag: {}", e));
        continue; // Don't fail entire parsing
    }
}
```

**Iterator Chaining for Data Processing**:

```rust
// Efficient data processing
tags.iter()
    .filter(|(id, _)| **id < 0x8000)  // Only EXIF tags
    .map(|(id, value)| format!("{}:{}", id, value))
    .collect::<Vec<_>>()
```
