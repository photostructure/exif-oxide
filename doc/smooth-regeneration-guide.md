# Smooth Regeneration Guide for ExifTool Extractors

This document provides instructions for making other component extractors as smooth as the `maker-detection` extractor, which can regenerate without manual intervention or compilation errors.

## Problem Statement

Currently, some extractors may have regeneration friction:

- Manual steps required to avoid compilation errors
- Missing generated files cause build failures
- Developers need to know specific regeneration sequences

## Solution Pattern: Build Script + Smart Extractor

The `maker-detection` extractor solved this with two components:

1. **Build Script Auto-Stub Creation**: Ensures required files always exist
2. **Smart Extractor Logic**: Handles all cases (existing, missing, or partial files)

## Implementation Steps

### Step 1: Identify Extractors That Need Improvement

Check which extractors generate files that are imported as modules or required for compilation:

```bash
# Check current extractors
cargo run --bin exiftool_sync help

# Current extractors (as of 2025-06-24):
# - binary-formats ✅ (generates to src/binary/formats/*.rs)
# - magic-numbers (generates to src/detection/magic_patterns.rs ?)
# - datetime-patterns (generates to src/datetime/patterns.rs ?)
# - binary-tags ✅ (generates to src/binary/composite_tags.rs)
# - maker-detection ✅ (generates to src/maker/*/detection.rs) - COMPLETED
```

**Priority targets**: Extractors that generate `.rs` files imported elsewhere in the codebase.

### Step 2: Analyze Current File Generation

For each extractor, determine:

1. **What files does it generate?**

   ```bash
   # Example analysis
   grep -r "Generated\|AUTO-GENERATED" src/ | grep -v maker
   ```

2. **Are the files imported as modules?**

   ```bash
   # Look for mod declarations or use statements
   grep -r "mod magic_patterns\|use.*magic_patterns" src/
   grep -r "mod composite_tags\|use.*composite_tags" src/
   ```

3. **What happens if files are missing?**
   ```bash
   # Test by temporarily moving files
   mv src/detection/magic_patterns.rs /tmp/ 2>/dev/null
   cargo build  # Does it fail?
   mv /tmp/magic_patterns.rs src/detection/ 2>/dev/null
   ```

### Step 3: Implement Build Script Stub Creation

Add stub creation to `build.rs` for any files that cause compilation failures:

```rust
// Add to build.rs main() function
ensure_magic_patterns_exists();
ensure_datetime_patterns_exists();
// etc.

// Add functions at end of build.rs
fn ensure_magic_patterns_exists() {
    let file_path = "src/detection/magic_patterns.rs";

    if !Path::new(file_path).exists() {
        // Create directory if needed
        let _ = fs::create_dir_all("src/detection");

        let stub_content = r#"// STUB: Auto-generated by build.rs to ensure compilation
// Regenerate with: cargo run --bin exiftool_sync extract magic-numbers

/// Magic number patterns for file type detection
pub const MAGIC_PATTERNS: &[(&[u8], &str)] = &[
    // Stub - real patterns will be generated by extractor
];
"#;

        if let Err(e) = fs::write(file_path, stub_content) {
            eprintln!("Warning: Failed to create stub {}: {}", file_path, e);
        } else {
            println!("Created stub file: {}", file_path);
        }
    }
}

fn ensure_datetime_patterns_exists() {
    let file_path = "src/datetime/patterns.rs";

    if !Path::new(file_path).exists() {
        let _ = fs::create_dir_all("src/datetime");

        let stub_content = r#"// STUB: Auto-generated by build.rs to ensure compilation
// Regenerate with: cargo run --bin exiftool_sync extract datetime-patterns

/// Date/time parsing patterns from ExifTool
pub const DATETIME_PATTERNS: &[&str] = &[
    // Stub - real patterns will be generated by extractor
];
"#;

        if let Err(e) = fs::write(file_path, stub_content) {
            eprintln!("Warning: Failed to create stub {}: {}", file_path, e);
        } else {
            println!("Created stub file: {}", file_path);
        }
    }
}
```

### Step 4: Update Extractor to Handle All Cases

Modify each extractor to always generate complete files:

```rust
// Example pattern for magic-numbers extractor
impl Extractor for MagicNumbersExtractor {
    fn extract(&self, exiftool_path: &Path) -> Result<(), String> {
        let mut extractor = Self::new();

        // Extract patterns from ExifTool source
        extractor.parse_magic_patterns(exiftool_path)?;

        // Always generate file (with patterns or fallback)
        let code = if extractor.patterns.is_empty() {
            extractor.generate_stub_magic_patterns()
        } else {
            extractor.generate_magic_patterns_code()
        };

        extractor.write_magic_patterns_file(&code)?;

        println!("Successfully generated magic patterns");
        if extractor.patterns.is_empty() {
            println!("  - Using stub implementation (no patterns found)");
        } else {
            println!("  - Generated {} patterns", extractor.patterns.len());
        }

        Ok(())
    }
}
```

### Step 5: Testing Procedure

For each updated extractor:

1. **Test with existing files**:

   ```bash
   cargo run --bin exiftool_sync extract magic-numbers
   ```

2. **Test regeneration from scratch**:

   ```bash
   rm src/detection/magic_patterns.rs  # Remove generated file
   touch build.rs                      # Trigger build script
   cargo run --bin exiftool_sync extract magic-numbers
   ```

3. **Test build without manual intervention**:
   ```bash
   rm src/detection/magic_patterns.rs
   cargo build  # Should succeed (build script creates stub)
   cargo run --bin exiftool_sync extract magic-numbers  # Should work
   ```

## Specific Extractor Instructions

### Magic Numbers Extractor

**Current state**: Unknown - needs investigation
**Files generated**: Likely `src/detection/magic_patterns.rs`
**Investigation needed**:

```bash
# Check if extractor exists and what it does
cargo run --bin exiftool_sync extract magic-numbers 2>&1 | head -10
find src/ -name "*magic*" -o -name "*pattern*"
```

**Implementation priority**: Medium (file detection is important)

### DateTime Patterns Extractor

**Current state**: Unknown - needs investigation  
**Files generated**: Likely `src/datetime/patterns.rs`
**Investigation needed**:

```bash
cargo run --bin exiftool_sync extract datetime-patterns 2>&1 | head -10
find src/ -name "*datetime*" -o -name "*date*"
```

**Implementation priority**: Low (unless actively breaking builds)

### Binary Formats Extractor

**Current state**: ✅ Already smooth
**Files generated**: `src/binary/formats/*.rs`
**Evidence**: Works without manual intervention

```bash
rm src/binary/formats/nikon.rs
cargo run --bin exiftool_sync extract binary-formats  # Works fine
```

### Binary Tags Extractor

**Current state**: ✅ Already smooth
**Files generated**: `src/binary/composite_tags.rs`
**Evidence**: Single file, always regenerated completely

## General Patterns to Follow

### 1. Build Script Stub Creation Pattern

```rust
fn ensure_COMPONENT_exists() {
    let file_path = "src/path/to/generated_file.rs";

    if !Path::new(file_path).exists() {
        let _ = fs::create_dir_all("src/path/to");

        let stub_content = r#"// STUB: Auto-generated by build.rs
// Regenerate with: cargo run --bin exiftool_sync extract COMPONENT

// Minimal stub implementation that compiles
"#;

        if let Err(e) = fs::write(file_path, stub_content) {
            eprintln!("Warning: Failed to create stub {}: {}", file_path, e);
        }
    }
}
```

### 2. Smart Extractor Pattern

```rust
impl Extractor for ComponentExtractor {
    fn extract(&self, exiftool_path: &Path) -> Result<(), String> {
        // Always attempt extraction
        let patterns = self.extract_patterns(exiftool_path)?;

        // Always generate files (real or stub)
        let code = if patterns.is_empty() {
            self.generate_stub_code()
        } else {
            self.generate_real_code(&patterns)
        };

        self.write_code_file(&code)?;

        // Informative output
        if patterns.is_empty() {
            println!("Generated stub implementation");
        } else {
            println!("Generated {} patterns", patterns.len());
        }

        Ok(())
    }
}
```

### 3. Generated File Header Pattern

```rust
// For real generated files
let header = format!(
    "// AUTO-GENERATED by exiftool_sync extract {}\n\
     // Source: third-party/exiftool/lib/Image/ExifTool/Source.pm\n\
     // Generated: {}\n\
     // DO NOT EDIT - Regenerate with `cargo run --bin exiftool_sync extract {}`\n\n\
     #![doc = \"EXIFTOOL-SOURCE: lib/Image/ExifTool/Source.pm\"]\n\n",
    component_name,
    chrono::Utc::now().format("%Y-%m-%d"),
    component_name
);

// For stub files
let header = format!(
    "// AUTO-GENERATED stub by exiftool_sync extract {}\n\
     // Source: third-party/exiftool/lib/Image/ExifTool/Source.pm\n\
     // Generated: {}\n\
     // DO NOT EDIT - Regenerate with `cargo run --bin exiftool_sync extract {}`\n\n\
     #![doc = \"EXIFTOOL-SOURCE: lib/Image/ExifTool/Source.pm\"]\n\n",
    component_name,
    chrono::Utc::now().format("%Y-%m-%d"),
    component_name
);
```

## Success Criteria

After implementing smooth regeneration for all extractors:

1. **Zero manual steps**: `cargo run --bin exiftool_sync extract COMPONENT` always works
2. **Build resilience**: `cargo build` never fails due to missing generated files
3. **Clear feedback**: Users know whether real patterns or stubs were generated
4. **Consistent experience**: All extractors work the same way

## Testing All Extractors

Final validation script:

```bash
#!/bin/bash
# Test all extractors work smoothly

components=("binary-formats" "magic-numbers" "datetime-patterns" "binary-tags" "maker-detection")

for component in "${components[@]}"; do
    echo "Testing $component..."

    # Find and remove generated files
    echo "  Removing generated files..."
    # Component-specific cleanup here

    # Trigger build (should create stubs)
    echo "  Testing build with missing files..."
    touch build.rs
    cargo build --quiet || { echo "  ❌ Build failed"; continue; }

    # Test regeneration
    echo "  Testing regeneration..."
    cargo run --bin exiftool_sync extract "$component" --quiet || { echo "  ❌ Regeneration failed"; continue; }

    # Test build still works
    echo "  Testing final build..."
    cargo build --quiet || { echo "  ❌ Final build failed"; continue; }

    echo "  ✅ $component works smoothly"
done

echo "All extractor testing complete!"
```

## Future Considerations

1. **New Extractors**: Follow this pattern from the start
2. **Generated Modules**: Consider if other generated code needs module imports
3. **CI Integration**: Add checks that all extractors work without manual steps
4. **Documentation**: Update user docs to emphasize single-command regeneration

This approach ensures that ExifTool synchronization remains maintainable and user-friendly as the codebase evolves.
