# ExifTool Synchronization Guide

This guide documents how exif-oxide tracks knowledge from Phil Harvey's ExifTool and incorporates updates as ExifTool evolves.

## The problems

1. ExifTool is updated monthly, and every version contains changes that touch all parts of the codebase.
2. Parsing `perl` with anything other than `perl` is an exercise in futility
3. The structures and code in ExifTool are _complicated_
4. There will always be a need for manual edits and updates to what the sync system can provide. An example of this is PrintConv implementations -- we can't directly execute the perl PrintConv code -- apart from the sync tooling, we need to manually implement those functions in Rust, and _something_ needs to map the autogenerated table from sync with our manually-written functions.

## How to not clobber prior work

We initially directly edited the PrintConv tables to reference our rust PrintConv functions. Although this worked, any subsequent sync would clobber those manual edits and revert to PrintConv::None.

There are several ways we can avoid clobbering in the future -- but via a smarter sync at sync time that can look up what we've written manually, and automatically associate the correct rust PrintConv function seems most promising, as it makes what will happen at runtime much more obvious.

There are multiple types of PrintConv:

### Direct (simple perl snippets), like `{ 0 => 'Off', 1 => 'On' }`

TODO: Sync uses the verbatim perl string to find 0 or 1 rust PrintConv function implementations. This lookup is managed in a mapping table. It's up to the rust PrintConv function implementer to add their perl mapping to that table and re-run sync to add a new PrintConv implementation.

### String expressions (simple perl snippets), like `"$val mm"`

TODO: Can these be handled just like Direct PrintConv?

### Hash references, like `canonLensTypes` with 500+ lens definitions

TODO: how should we handle these by sync? Maybe by introducing a new, separate table of pointers to hashes? Or can these always be automated, and make sync do this too? (these tables like lens names are updated by almost every version of ExifTool!)

### Code references, like `\&PrintExposureTime`

TODO: can these be handled like Direct PrintConv? Do we need to worry about function name collisions, and add a context to the code reference (like `Canon.pm::PrintExposureTime`)? This needs to be researched.

## TODO: ADD OTHER SYNC COMPONENT DESIGN

## Source Tracking

### Module-Level Attribution

Each Rust file that manually re-implements ExifTool functionality that isn't rebuilt automatically by `sync` must include doc attributes at the top.

```rust
//! Canon maker note parsing implementation

#![doc = "EXIFTOOL-SOURCE: lib/Image/ExifTool/Canon.pm"]
#![doc = "EXIFTOOL-SOURCE: lib/Image/ExifTool/CanonRaw.pm"]

// rest of implementation...
```

For auto-generated files:

```rust
// AUTO-GENERATED from ExifTool v12.65
// Source: lib/Image/ExifTool/Canon.pm (Main, PreviewImageInfo tables)
// Generated: 2024-12-22 by build.rs
// DO NOT EDIT - Regenerate with `cargo run sync` << TODO: FIX THIS COMMAND
```

### Why This Approach?

1. **Simple** - Just doc attributes at the top of each file
2. **Greppable** - Easy to find all files affected by a Perl module change
3. **Parseable** - Can be extracted programmatically when needed
4. **Self-documenting** - Shows up in rustdoc
5. **No separate files** - Attribution travels with the code
