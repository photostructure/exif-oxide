//! Kodak maker note detection patterns
//!
//! EXIFTOOL-SOURCE: lib/Image/ExifTool/MakerNotes.pm
//! EXIFTOOL-VERSION: 12.65
//!
//! This file is auto-generated by exiftool_sync extract maker-detection.
//! Do not edit manually.

#![doc = "EXIFTOOL-SOURCE: lib/Image/ExifTool/MakerNotes.pm"]

#[derive(Debug, Clone)]
pub struct KODAKDetectionResult {
    pub maker_note_type: KodakMakerNoteType,
    pub ifd_offset: usize,
    pub byte_order: Option<crate::core::Endian>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum KodakMakerNoteType {
    /// Type1a: EASTMAN KODAK with "KDK INFO" signature
    /// Condition: Make=~/^EASTMAN KODAK/ and $$valPt=~/^KDK INFO/
    Type1a,
    /// Type1b: EASTMAN KODAK with "KDK" signature
    /// Condition: Make=~/^EASTMAN KODAK/ and $$valPt=~/^KDK/
    Type1b,
    /// Type2: Contains "Eastman Kodak" or specific pattern
    /// Condition: $$valPt =~ /^.{8}Eastman Kodak/s or $$valPt =~ /^\x01\0[\0\x01]\0\0\0\x04\0[a-zA-Z]{4}/
    Type2,
    /// Type3: EASTMAN KODAK with specific year pattern
    /// Condition: Make=~/^EASTMAN KODAK/ and $$valPt =~ /^(?!MM|II).{12}\x07/s
    Type3,
    /// Type4: Eastman Kodak with JPG signature
    /// Condition: Make=~/^Eastman Kodak/ and $$valPt =~ /^.{41}JPG/s
    Type4,
    /// Type5: EASTMAN KODAK with specific CX models
    /// Condition: Make=~/^EASTMAN KODAK/ and Model=~/CX(4200|4230|4300|4310|6200|6230)/
    Type5,
    /// Type6a: EASTMAN KODAK DX3215
    /// Condition: Make=~/^EASTMAN KODAK/ and Model=~/DX3215/
    Type6a,
    /// Type6b: EASTMAN KODAK DX3700
    /// Condition: Make=~/^EASTMAN KODAK/ and Model=~/DX3700/
    Type6b,
    /// Type7: Kodak with serial number pattern
    /// Condition: Make=~/Kodak/i and $$valPt =~ /^[CK][A-Z\d]{3} ?[A-Z\d]{1,2}\d{2}[A-Z\d]\d{4}[ \0]/
    Type7,
    /// Type8a: Kodak IFD-format maker notes
    /// Condition: Make=~/Kodak/i and ($$valPt =~ /^\0[\x02-\x7f]..\0[\x01-\x0c]\0\0/s or $$valPt =~ /^[\x02-\x7f]\0..[\x01-\x0c]\0..\0\0/s)
    Type8a,
    /// Type8b: Kodak with extra 2 bytes after entry count
    /// Condition: Make=~/Kodak/i and $$valPt =~ /^MM\0\x2a\0\0\0\x08\0.\0\0/
    Type8b,
    /// Type8c: Kodak TIFF-format maker notes
    /// Condition: Make=~/Kodak/i and $$valPt =~ /^(MM\0\x2a\0\0\0\x08|II\x2a\0\x08\0\0\0)/
    Type8c,
    /// Type9: IIII header with date pattern
    /// Condition: $$valPt =~ m{^IIII[\x02\x03]\0.{14}\d{4}/\d{2}/\d{2} }s
    Type9,
    /// Type10: Kodak with byte order indicator
    /// Condition: Make=~/Kodak/i and $$valPt =~ /^(MM\0[\x02-\x7f]|II[\x02-\x7f]\0)/
    Type10,
    /// Type11: PixPro S-1 with 4-byte entry count
    /// Condition: Model=~/(Kodak|PixPro)/i and $$valPt =~ /^II\x2a\0\x08\0\0\0.\0\0\0/s
    Type11,
    /// Type12: PixPro AZ901 with 4-byte entry count
    /// Condition: Model=~/(Kodak|PixPro)/i and $$valPt =~ /^MM\0\x2a\0\0\0\x08\0\0\0./s
    Type12,
    /// Unknown: Kodak unknown format
    /// Condition: Make=~/Kodak/i and $$valPt!~/^AOC\0/
    Unknown,
}

/// Detect Kodak maker note format from raw data
/// Based on ExifTool lib/Image/ExifTool/MakerNotes.pm detection logic
///
/// Returns the detected type and IFD offset for parsing
pub fn detect_kodak_maker_note(
    data: &[u8],
    make: &str,
    model: &str,
) -> Result<KODAKDetectionResult, String> {
    if data.is_empty() {
        return Err("Empty maker note data".to_string());
    }

    // Type1a: EASTMAN KODAK with "KDK INFO" signature
    if make.starts_with("EASTMAN KODAK") && data.starts_with(b"KDK INFO") {
        return Ok(KODAKDetectionResult {
            maker_note_type: KodakMakerNoteType::Type1a,
            ifd_offset: 8,
            byte_order: Some(crate::core::Endian::Big),
        });
    }

    // Type1b: EASTMAN KODAK with "KDK" signature
    if make.starts_with("EASTMAN KODAK") && data.starts_with(b"KDK") {
        return Ok(KODAKDetectionResult {
            maker_note_type: KodakMakerNoteType::Type1b,
            ifd_offset: 8,
            byte_order: Some(crate::core::Endian::Little),
        });
    }

    // Type2: Contains "Eastman Kodak" at offset 8 or specific pattern
    if data.len() >= 16 {
        if data.get(8..20) == Some(b"Eastman Kodak") {
            return Ok(KODAKDetectionResult {
                maker_note_type: KodakMakerNoteType::Type2,
                ifd_offset: 0,
                byte_order: Some(crate::core::Endian::Big),
            });
        }
        // Pattern: \x01\0[\0\x01]\0\0\0\x04\0[a-zA-Z]{4}
        if data.len() >= 12
            && data[0] == 0x01
            && data[1] == 0x00
            && (data[2] == 0x00 || data[2] == 0x01)
            && data[3] == 0x00
            && data[4] == 0x00
            && data[5] == 0x00
            && data[6] == 0x04
            && data[7] == 0x00
            && data.len() >= 12
            && data[8..12].iter().all(|&b| b.is_ascii_alphabetic())
        {
            return Ok(KODAKDetectionResult {
                maker_note_type: KodakMakerNoteType::Type2,
                ifd_offset: 0,
                byte_order: Some(crate::core::Endian::Big),
            });
        }
    }

    // Type3: EASTMAN KODAK with year pattern
    if make.starts_with("EASTMAN KODAK")
        && data.len() >= 13
        && !data.starts_with(b"MM")
        && !data.starts_with(b"II")
        && data[12] == 0x07
    {
        return Ok(KODAKDetectionResult {
            maker_note_type: KodakMakerNoteType::Type3,
            ifd_offset: 0,
            byte_order: Some(crate::core::Endian::Big),
        });
    }

    // Type4: Eastman Kodak with JPG signature at offset 41
    if make.starts_with("Eastman Kodak")
        && data.len() >= 44
        && data.get(41..44) == Some(b"JPG")
        && !data.starts_with(b"MM")
        && !data.starts_with(b"II")
        && !data.starts_with(b"AOC")
    {
        return Ok(KODAKDetectionResult {
            maker_note_type: KodakMakerNoteType::Type4,
            ifd_offset: 0,
            byte_order: Some(crate::core::Endian::Big),
        });
    }

    // Type5: EASTMAN KODAK CX models
    if make.starts_with("EASTMAN KODAK") {
        let cx_models = ["CX4200", "CX4230", "CX4300", "CX4310", "CX6200", "CX6230"];
        if cx_models.iter().any(|&m| model.contains(m)) {
            return Ok(KODAKDetectionResult {
                maker_note_type: KodakMakerNoteType::Type5,
                ifd_offset: 0,
                byte_order: Some(crate::core::Endian::Big),
            });
        }
    }

    // Type6a: DX3215
    if make.starts_with("EASTMAN KODAK") && model.contains("DX3215") {
        return Ok(KODAKDetectionResult {
            maker_note_type: KodakMakerNoteType::Type6a,
            ifd_offset: 0,
            byte_order: Some(crate::core::Endian::Big),
        });
    }

    // Type6b: DX3700
    if make.starts_with("EASTMAN KODAK") && model.contains("DX3700") {
        return Ok(KODAKDetectionResult {
            maker_note_type: KodakMakerNoteType::Type6b,
            ifd_offset: 0,
            byte_order: Some(crate::core::Endian::Little),
        });
    }

    // Type8b: Extra 2 bytes after entry count
    if make.to_lowercase().contains("kodak")
        && data.starts_with(&[0x4D, 0x4D, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x08, 0x00])
        && data.len() >= 11
    {
        return Ok(KODAKDetectionResult {
            maker_note_type: KodakMakerNoteType::Type8b,
            ifd_offset: 8,
            byte_order: Some(crate::core::Endian::Big),
        });
    }

    // Type8c: TIFF-format maker notes
    if make.to_lowercase().contains("kodak") {
        if data.starts_with(&[0x4D, 0x4D, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x08]) {
            return Ok(KODAKDetectionResult {
                maker_note_type: KodakMakerNoteType::Type8c,
                ifd_offset: 8,
                byte_order: Some(crate::core::Endian::Big),
            });
        }
        if data.starts_with(&[0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00]) {
            return Ok(KODAKDetectionResult {
                maker_note_type: KodakMakerNoteType::Type8c,
                ifd_offset: 8,
                byte_order: Some(crate::core::Endian::Little),
            });
        }
    }

    // Type10: Byte order indicator
    if make.to_lowercase().contains("kodak") {
        if data.len() >= 3 && data.starts_with(b"MM") && data[2] >= 0x02 && data[2] <= 0x7f {
            return Ok(KODAKDetectionResult {
                maker_note_type: KodakMakerNoteType::Type10,
                ifd_offset: 2,
                byte_order: Some(crate::core::Endian::Big),
            });
        }
        if data.len() >= 3
            && data.starts_with(b"II")
            && data[1] >= 0x02
            && data[1] <= 0x7f
            && data[2] == 0x00
        {
            return Ok(KODAKDetectionResult {
                maker_note_type: KodakMakerNoteType::Type10,
                ifd_offset: 2,
                byte_order: Some(crate::core::Endian::Little),
            });
        }
    }

    // Type11: PixPro with 4-byte entry count (little endian)
    if (model.to_lowercase().contains("kodak") || model.to_lowercase().contains("pixpro"))
        && data.starts_with(&[0x49, 0x49, 0x2A, 0x00, 0x08, 0x00, 0x00, 0x00])
        && data.len() >= 12
    {
        return Ok(KODAKDetectionResult {
            maker_note_type: KodakMakerNoteType::Type11,
            ifd_offset: 8,
            byte_order: Some(crate::core::Endian::Little),
        });
    }

    // Type12: PixPro with 4-byte entry count (big endian)
    if (model.to_lowercase().contains("kodak") || model.to_lowercase().contains("pixpro"))
        && data.starts_with(&[
            0x4D, 0x4D, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        ])
        && data.len() >= 11
    {
        return Ok(KODAKDetectionResult {
            maker_note_type: KodakMakerNoteType::Type12,
            ifd_offset: 8,
            byte_order: Some(crate::core::Endian::Big),
        });
    }

    // Type8a: IFD-format maker notes
    if make.to_lowercase().contains("kodak") && data.len() >= 6 {
        // Pattern: ^\0[\x02-\x7f]..\0[\x01-\x0c]\0\0
        if data[0] == 0x00
            && data[1] >= 0x02
            && data[1] <= 0x7f
            && data.len() >= 8
            && data[4] == 0x00
            && data[5] >= 0x01
            && data[5] <= 0x0c
            && data[6] == 0x00
            && data[7] == 0x00
        {
            return Ok(KODAKDetectionResult {
                maker_note_type: KodakMakerNoteType::Type8a,
                ifd_offset: 0,
                byte_order: Some(crate::core::Endian::Big),
            });
        }
        // Pattern: ^[\x02-\x7f]\0..[\x01-\x0c]\0..\0\0
        if data[0] >= 0x02
            && data[0] <= 0x7f
            && data[1] == 0x00
            && data.len() >= 8
            && data[4] >= 0x01
            && data[4] <= 0x0c
            && data[5] == 0x00
            && data[7] == 0x00
            && data[8] == 0x00
        {
            return Ok(KODAKDetectionResult {
                maker_note_type: KodakMakerNoteType::Type8a,
                ifd_offset: 0,
                byte_order: Some(crate::core::Endian::Little),
            });
        }
    }

    // Type9: IIII header with date
    if data.len() >= 20
        && data.starts_with(b"IIII")
        && (data[4] == 0x02 || data[4] == 0x03)
        && data[5] == 0x00
    {
        // Check for date pattern at offset 18: \d{4}/\d{2}/\d{2}
        if data.len() >= 29 {
            let date_slice = &data[18..29];
            if date_slice.len() >= 11
                && date_slice[4] == b'/'
                && date_slice[7] == b'/'
                && date_slice[10] == b' '
                && date_slice[0..4].iter().all(|&b| b.is_ascii_digit())
                && date_slice[5..7].iter().all(|&b| b.is_ascii_digit())
                && date_slice[8..10].iter().all(|&b| b.is_ascii_digit())
            {
                return Ok(KODAKDetectionResult {
                    maker_note_type: KodakMakerNoteType::Type9,
                    ifd_offset: 0,
                    byte_order: Some(crate::core::Endian::Little),
                });
            }
        }
    }

    // Type7: Serial number pattern
    if make.to_lowercase().contains("kodak") && data.len() >= 16 {
        // Pattern: ^[CK][A-Z\d]{3} ?[A-Z\d]{1,2}\d{2}[A-Z\d]\d{4}[ \0]
        if (data[0] == b'C' || data[0] == b'K')
            && data[1..4].iter().all(|&b| b.is_ascii_alphanumeric())
            && (data[4] == b' ' || data[4].is_ascii_alphanumeric())
            && data.len() >= 15
        {
            // This is a simplified check - the full regex would be more complex
            return Ok(KODAKDetectionResult {
                maker_note_type: KodakMakerNoteType::Type7,
                ifd_offset: 0,
                byte_order: Some(crate::core::Endian::Little),
            });
        }
    }

    // Unknown: Fallback for Kodak that doesn't match AOC
    if make.to_lowercase().contains("kodak") && !data.starts_with(b"AOC\0") {
        return Ok(KODAKDetectionResult {
            maker_note_type: KodakMakerNoteType::Unknown,
            ifd_offset: 0,
            byte_order: Some(crate::core::Endian::Big),
        });
    }

    Err("No Kodak maker note pattern detected".to_string())
}
