// AUTO-GENERATED by exiftool_sync extract maker-detection
// Source: third-party/exiftool/lib/Image/ExifTool/OLYMPUS.pm
// Generated: 2025-06-24
// DO NOT EDIT - Regenerate with `cargo run --bin exiftool_sync extract maker-detection`

#![doc = "EXIFTOOL-SOURCE: lib/Image/ExifTool/OLYMPUS.pm"]

/// Detection patterns for olympus maker notes
#[derive(Debug, Clone, PartialEq)]
pub struct OLYMPUSDetectionResult {
    pub version: Option<u8>,
    pub ifd_offset: usize,
    pub description: String,
}

/// Detect olympus maker note format and extract version information
/// 
/// Returns Some(DetectionResult) if this appears to be a olympus maker note,
/// None otherwise.
pub fn detect_olympus_maker_note(data: &[u8]) -> Option<OLYMPUSDetectionResult> {
    // Pattern from source line 0: Olympus Type 1 maker note
    if data.len() >= 10 && data.starts_with(&[0x4f, 0x4c, 0x59, 0x4d, 0x50, 0x55, 0x53, 0x00, 0x01, 0x00]) {
        return Some(OLYMPUSDetectionResult {
            version: Some(1),
            ifd_offset: 12,
            description: "Olympus Type 1 maker note".to_string(),
        });
    }

    // Pattern from source line 0: Olympus Type 2 maker note
    if data.len() >= 10 && data.starts_with(&[0x4f, 0x4c, 0x59, 0x4d, 0x50, 0x55, 0x53, 0x00, 0x02, 0x00]) {
        return Some(OLYMPUSDetectionResult {
            version: Some(2),
            ifd_offset: 12,
            description: "Olympus Type 2 maker note".to_string(),
        });
    }

    // Pattern from source line 0: Olympus short Type 1 maker note
    if data.len() >= 8 && data.starts_with(&[0x4f, 0x4c, 0x59, 0x4d, 0x50, 0x00, 0x01, 0x00]) {
        return Some(OLYMPUSDetectionResult {
            version: Some(1),
            ifd_offset: 10,
            description: "Olympus short Type 1 maker note".to_string(),
        });
    }

    // Pattern from source line 0: Olympus short Type 2 maker note
    if data.len() >= 8 && data.starts_with(&[0x4f, 0x4c, 0x59, 0x4d, 0x50, 0x00, 0x02, 0x00]) {
        return Some(OLYMPUSDetectionResult {
            version: Some(2),
            ifd_offset: 10,
            description: "Olympus short Type 2 maker note".to_string(),
        });
    }

    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_olympus_detection_pattern_0() {
        let test_data = &[0x4f, 0x4c, 0x59, 0x4d, 0x50, 0x55, 0x53, 0x00, 0x01, 0x00];
        let result = detect_olympus_maker_note(test_data);
        assert!(result.is_some());
        let detection = result.unwrap();
        assert_eq!(detection.version, Some(1));
        assert_eq!(detection.ifd_offset, 12);
    }

    #[test]
    fn test_olympus_detection_pattern_1() {
        let test_data = &[0x4f, 0x4c, 0x59, 0x4d, 0x50, 0x55, 0x53, 0x00, 0x02, 0x00];
        let result = detect_olympus_maker_note(test_data);
        assert!(result.is_some());
        let detection = result.unwrap();
        assert_eq!(detection.version, Some(2));
        assert_eq!(detection.ifd_offset, 12);
    }

    #[test]
    fn test_olympus_detection_pattern_2() {
        let test_data = &[0x4f, 0x4c, 0x59, 0x4d, 0x50, 0x00, 0x01, 0x00];
        let result = detect_olympus_maker_note(test_data);
        assert!(result.is_some());
        let detection = result.unwrap();
        assert_eq!(detection.version, Some(1));
        assert_eq!(detection.ifd_offset, 10);
    }

    #[test]
    fn test_olympus_detection_pattern_3() {
        let test_data = &[0x4f, 0x4c, 0x59, 0x4d, 0x50, 0x00, 0x02, 0x00];
        let result = detect_olympus_maker_note(test_data);
        assert!(result.is_some());
        let detection = result.unwrap();
        assert_eq!(detection.version, Some(2));
        assert_eq!(detection.ifd_offset, 10);
    }

}
