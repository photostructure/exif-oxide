//! AUTO-GENERATED by exiftool_sync extract maker-detection
//! Source: third-party/exiftool/lib/Image/ExifTool/MakerNotes.pm
//! Do not edit manually - regenerate with extraction tool

#![doc = "EXIFTOOL-SOURCE: lib/Image/ExifTool/MakerNotes.pm:486-517"]
#![allow(dead_code)]

use crate::error::Result;

#[derive(Debug, Clone)]
pub struct MINOLTADetectionResult {
    pub detected: bool,
    pub ifd_offset: usize,
    pub byte_order: Option<crate::core::Endian>,
    pub description: String,
}

/// Detect Minolta maker note format based on ExifTool logic
///
/// From MakerNotes.pm lines 486-517:
/// - MakerNoteMinolta: Make matches "Konica Minolta" or "Minolta" and data doesn't start with specific patterns
/// - MakerNoteMinolta2: Data starts with "MINOL" or "CAMER" (uses Olympus tag table)  
/// - MakerNoteMinolta3: Make matches "Konica Minolta" or "Minolta" and data starts with "MLY0", "KC", "+M+M", or 0xd7
pub fn detect_minolta_maker_note(data: &[u8]) -> Result<MINOLTADetectionResult> {
    if data.len() < 8 {
        return Ok(MINOLTADetectionResult {
            detected: false,
            ifd_offset: 0,
            byte_order: None,
            description: "Insufficient data for Minolta detection".to_string(),
        });
    }

    // MakerNoteMinolta2: MINOL or CAMER signature (lines 499-507)
    if data.len() >= 6 && (data.starts_with(b"MINOL\0") || data.starts_with(b"CAMER\0")) {
        return Ok(MINOLTADetectionResult {
            detected: true,
            ifd_offset: 8,    // Start after 8-byte header
            byte_order: None, // Unknown byte order - will be detected later
            description: if data.starts_with(b"MINOL\0") {
                "Minolta Type 2 maker note (MINOL signature, uses Olympus tags)".to_string()
            } else {
                "Minolta Type 2 maker note (CAMER signature, uses Olympus tags)".to_string()
            },
        });
    }

    // MakerNoteMinolta3: Special binary formats (lines 513-517)
    if data.len() >= 4 {
        if data.starts_with(b"MLY0") {
            return Ok(MINOLTADetectionResult {
                detected: true,
                ifd_offset: 0,
                byte_order: None,
                description: "Minolta Type 3 maker note (MLY0 signature, non-EXIF binary)"
                    .to_string(),
            });
        }

        if data.starts_with(b"KC") {
            return Ok(MINOLTADetectionResult {
                detected: true,
                ifd_offset: 0,
                byte_order: None,
                description: "Minolta Type 3 maker note (KC signature, non-EXIF binary)"
                    .to_string(),
            });
        }

        if data.starts_with(b"+M+M") {
            return Ok(MINOLTADetectionResult {
                detected: true,
                ifd_offset: 0,
                byte_order: None,
                description: "Minolta Type 3 maker note (+M+M signature, DiMAGE E201)".to_string(),
            });
        }

        if !data.is_empty() && data[0] == 0xd7 {
            return Ok(MINOLTADetectionResult {
                detected: true,
                ifd_offset: 0,
                byte_order: None,
                description: "Minolta Type 3 maker note (0xd7 signature, DiMAGE RD3000)"
                    .to_string(),
            });
        }
    }

    // MakerNoteMinolta: Standard IFD-based format (lines 486-495)
    // This is detected when make matches Konica Minolta/Minolta AND
    // data doesn't start with MINOL, CAMER, MLY0, KC, +M+M, or 0xd7
    // For now, we'll assume standard IFD format if none of the above patterns match
    Ok(MINOLTADetectionResult {
        detected: true,
        ifd_offset: 0,    // Standard IFD starts at beginning
        byte_order: None, // Unknown byte order - will be detected during IFD parsing
        description: "Minolta Type 1 maker note (standard IFD format)".to_string(),
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_minolta_detection_minol() {
        let data = b"MINOL\0\x00\x01\x02\x03\x04\x05\x06\x07";
        let result = detect_minolta_maker_note(data).unwrap();
        assert!(result.detected);
        assert_eq!(result.ifd_offset, 8);
        assert!(result.description.contains("MINOL"));
    }

    #[test]
    fn test_minolta_detection_camer() {
        let data = b"CAMER\0\x00\x01\x02\x03\x04\x05\x06\x07";
        let result = detect_minolta_maker_note(data).unwrap();
        assert!(result.detected);
        assert_eq!(result.ifd_offset, 8);
        assert!(result.description.contains("CAMER"));
    }

    #[test]
    fn test_minolta_detection_mly0() {
        let data = b"MLY0\x00\x01\x02\x03\x04\x05\x06\x07";
        let result = detect_minolta_maker_note(data).unwrap();
        assert!(result.detected);
        assert_eq!(result.ifd_offset, 0);
        assert!(result.description.contains("MLY0"));
    }

    #[test]
    fn test_minolta_detection_plus_m() {
        let data = b"+M+M\x00\x01\x02\x03\x04\x05\x06\x07";
        let result = detect_minolta_maker_note(data).unwrap();
        assert!(result.detected);
        assert_eq!(result.ifd_offset, 0);
        assert!(result.description.contains("+M+M"));
    }

    #[test]
    fn test_minolta_detection_0xd7() {
        let data = b"\xd7\x00\x01\x02\x03\x04\x05\x06\x07";
        let result = detect_minolta_maker_note(data).unwrap();
        assert!(result.detected);
        assert_eq!(result.ifd_offset, 0);
        assert!(result.description.contains("0xd7"));
    }

    #[test]
    fn test_minolta_detection_standard() {
        let data = b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09";
        let result = detect_minolta_maker_note(data).unwrap();
        assert!(result.detected);
        assert_eq!(result.ifd_offset, 0);
        assert!(result.description.contains("standard IFD"));
    }

    #[test]
    fn test_minolta_detection_insufficient_data() {
        let data = b"MIN";
        let result = detect_minolta_maker_note(data).unwrap();
        assert!(!result.detected);
        assert!(result.description.contains("Insufficient data"));
    }
}
