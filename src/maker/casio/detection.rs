//! Casio maker note detection patterns
//!
//! EXIFTOOL-SOURCE: lib/Image/ExifTool/MakerNotes.pm
//! EXIFTOOL-VERSION: 12.65
//!
//! This file is auto-generated by exiftool_sync extract maker-detection.
//! Do not edit manually.

#![doc = "EXIFTOOL-SOURCE: lib/Image/ExifTool/MakerNotes.pm"]

#[derive(Debug, Clone)]
pub struct CASIODetectionResult {
    pub maker_note_type: CasioMakerNoteType,
    pub ifd_offset: usize,
    pub byte_order: Option<crate::core::Endian>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum CasioMakerNoteType {
    /// Main Casio maker notes (starts with IFD)
    /// Condition: Make=~/^CASIO/ and $$valPt!~/^(QVC|DCI)\0/
    Main,
    /// Type2 Casio maker notes (starts with "QVC\0" or "DCI\0")
    /// Condition: $$valPt =~ /^(QVC|DCI)\0/
    Type2,
}

/// Detect Casio maker note format from raw data
/// Based on ExifTool lib/Image/ExifTool/MakerNotes.pm detection logic
///
/// Returns Some(DetectionResult) if this appears to be a Casio maker note,
/// None otherwise.
pub fn detect_casio_maker_note(data: &[u8]) -> Option<CASIODetectionResult> {
    // Check for Type2 first (QVC\0 or DCI\0 signature)
    if data.len() >= 4 && (&data[0..4] == b"QVC\0" || &data[0..4] == b"DCI\0") {
        return Some(CASIODetectionResult {
            maker_note_type: CasioMakerNoteType::Type2,
            ifd_offset: 6,    // Start after "QVC\0\0\0" or "DCI\0\0\0"
            byte_order: None, // Will be determined by IFD
        });
    }

    // For Main type detection, we can't check Make here, so we'll assume
    // that if this function is called, it's because Make was already CASIO.
    // This follows the pattern of other manufacturer detection functions.
    if data.len() >= 2 {
        // Assume Main type if we have data but no Type2 signature
        // Main type starts with an IFD directly
        return Some(CASIODetectionResult {
            maker_note_type: CasioMakerNoteType::Main,
            ifd_offset: 0,    // Starts at beginning
            byte_order: None, // Will be determined by IFD
        });
    }

    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_casio_type2_qvc_detection() {
        let data = b"QVC\0\0\0test_ifd_data";
        let result = detect_casio_maker_note(data).unwrap();

        assert_eq!(result.maker_note_type, CasioMakerNoteType::Type2);
        assert_eq!(result.ifd_offset, 6);
    }

    #[test]
    fn test_casio_type2_dci_detection() {
        let data = b"DCI\0\0\0test_ifd_data";
        let result = detect_casio_maker_note(data).unwrap();

        assert_eq!(result.maker_note_type, CasioMakerNoteType::Type2);
        assert_eq!(result.ifd_offset, 6);
    }

    #[test]
    fn test_casio_main_detection() {
        let data = b"\x00\x08\x00\x01\x00\x04"; // Sample IFD data
        let result = detect_casio_maker_note(data).unwrap();

        assert_eq!(result.maker_note_type, CasioMakerNoteType::Main);
        assert_eq!(result.ifd_offset, 0);
    }

    #[test]
    fn test_insufficient_data() {
        let data = b"\x00"; // Too short for Main type
        let result = detect_casio_maker_note(data);

        assert!(result.is_none());
    }

    #[test]
    fn test_empty_data() {
        let data = b"";
        let result = detect_casio_maker_note(data);

        assert!(result.is_none());
    }
}
