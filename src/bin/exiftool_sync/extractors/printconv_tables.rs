//! PrintConv Tables Extractor
//!
//! Extracts complete tag tables with PrintConv mappings from ExifTool manufacturer files

use super::Extractor;
use std::fs;
use std::path::Path;
use regex::Regex;

#[derive(Debug, Clone)]
struct TagEntry {
    id: String,
    name: String,
    printconv_id: String,
}

pub struct PrintConvTablesExtractor {
    manufacturer_file: String,
}

impl PrintConvTablesExtractor {
    pub fn new(manufacturer_file: &str) -> Self {
        Self {
            manufacturer_file: manufacturer_file.to_string(),
        }
    }
    
    fn generate_stub_code(&self) -> Result<String, String> {
        let manufacturer = self.manufacturer_file.trim_end_matches(".pm");
        let mut code = String::new();

        code.push_str(&format!(
            "//! Auto-generated stub {} tag table with PrintConv mappings\n\
             //!\n\
             //! EXIFTOOL-SOURCE: lib/Image/ExifTool/{}\n\
             //! This is a stub file generated when no data was found.\n\
             //! Regenerate with: cargo run --bin exiftool_sync extract printconv-tables {}\n\n\
             #![doc = \"EXIFTOOL-SOURCE: lib/Image/ExifTool/{}\"]\n\n\
             use crate::core::print_conv::PrintConvId;\n\n",
            manufacturer.to_lowercase(), 
            self.manufacturer_file,
            self.manufacturer_file,
            self.manufacturer_file
        ));

        code.push_str(&format!(
            "#[derive(Debug, Clone)]\n\
             pub struct {}Tag {{\n\
             \x20\x20\x20\x20pub id: u16,\n\
             \x20\x20\x20\x20pub name: &'static str,\n\
             \x20\x20\x20\x20pub print_conv: PrintConvId,\n\
             }}\n\n",
            manufacturer.to_uppercase()
        ));

        code.push_str(&format!(
            "/// Stub tag table (empty - regenerate to populate)\n\
             pub const {}_TAGS: &[{}Tag] = &[\n\
             \x20\x20\x20\x20// Stub - real tags will be generated by extractor\n\
             ];\n\n",
            manufacturer.to_uppercase(),
            manufacturer.to_uppercase()
        ));

        code.push_str(&format!(
            "/// Get {} tag by ID\n\
             pub fn get_{}_tag(tag_id: u16) -> Option<&'static {}Tag> {{\n\
             \x20\x20\x20\x20{}_TAGS.iter().find(|tag| tag.id == tag_id)\n\
             }}\n",
            manufacturer.to_lowercase(),
            manufacturer.to_lowercase(),
            manufacturer.to_uppercase(),
            manufacturer.to_uppercase()
        ));

        Ok(code)
    }
}

impl Extractor for PrintConvTablesExtractor {
    fn extract(&self, exiftool_path: &Path) -> Result<(), String> {
        println!("Extracting PrintConv table for {}", self.manufacturer_file);

        let manufacturer_path = exiftool_path
            .join("lib/Image/ExifTool") 
            .join(&self.manufacturer_file);

        let mut tags = Vec::new();

        // Always attempt extraction (never fail completely)
        match self.parse_tag_table(&manufacturer_path) {
            Ok(parsed_tags) => {
                tags = parsed_tags;
                println!("Found {} tags with PrintConv", tags.len());
            }
            Err(e) => {
                println!("Warning: Failed to parse: {}", e);
                println!("  - Generating stub implementation");
            }
        }

        // Always generate code (real or stub)
        let code = if tags.is_empty() {
            self.generate_stub_code()?
        } else {
            self.generate_real_code(&tags)?
        };

        // Always write output
        self.write_output(&code)?;

        // Clear completion message
        println!("PrintConv table extraction completed successfully");
        if tags.is_empty() {
            println!("  - Using stub implementation (no data found)");
        } else {
            println!("  - Generated {} tag definitions", tags.len());
        }

        Ok(())
    }
}

impl PrintConvTablesExtractor {
    fn parse_tag_table(&self, manufacturer_path: &Path) -> Result<Vec<TagEntry>, String> {
        if !manufacturer_path.exists() {
            return Err(format!("File not found: {}", manufacturer_path.display()));
        }

        let content = fs::read_to_string(manufacturer_path)
            .map_err(|e| format!("Failed to read file: {}", e))?;

        let manufacturer = self.manufacturer_file.trim_end_matches(".pm");
        let table_pattern = format!("%Image::ExifTool::{}::Main = (", manufacturer);
        
        let table_start = content.find(&table_pattern)
            .ok_or_else(|| format!("Could not find {} main table", manufacturer))?;
        
        // Extract table content
        let table_content = &content[table_start..];
        let search_end = table_content.find("\n%").unwrap_or(table_content.len().min(500000));
        let search_content = &table_content[..search_end];

        let mut tags = Vec::new();

        // Parse tag definitions with names
        let tag_re = Regex::new(r"(?s)(0x[0-9a-fA-F]+)\s*=>\s*\{([^}]+)\}")
            .map_err(|e| format!("Regex error: {}", e))?;
        
        let name_re = Regex::new(r"Name\s*=>\s*'([^']+)'")
            .map_err(|e| format!("Name regex error: {}", e))?;

        for cap in tag_re.captures_iter(search_content) {
            let tag_hex = &cap[1];
            let tag_content = &cap[2];
            
            // Extract tag name
            if let Some(name_cap) = name_re.captures(tag_content) {
                let tag_name = name_cap[1].to_string();
                
                // Map to PrintConvId (simplified heuristic)
                let printconv_id = self.map_to_printconv_id(&tag_name, tag_content);
                
                tags.push(TagEntry {
                    id: tag_hex.to_string(),
                    name: tag_name,
                    printconv_id,
                });
            }
        }

        Ok(tags)
    }

    fn map_to_printconv_id(&self, tag_name: &str, tag_content: &str) -> String {
        // Simple heuristics to map tag names to PrintConvId variants
        let name_lower = tag_name.to_lowercase();
        
        // Universal patterns
        if name_lower.contains("quality") {
            return "PrintConvId::Quality".to_string();
        }
        if name_lower.contains("flash") && name_lower.contains("mode") {
            return "PrintConvId::FlashMode".to_string();
        }
        if name_lower.contains("white") && name_lower.contains("balance") {
            return "PrintConvId::WhiteBalance".to_string();
        }
        if name_lower.contains("metering") {
            return "PrintConvId::MeteringMode".to_string();
        }
        if name_lower.contains("autobracket") || name_lower.contains("autobracketing") {
            return "PrintConvId::OnOff".to_string();
        }
        
        // Check PrintConv content for simple On/Off patterns
        if tag_content.contains("PrintConv") {
            if tag_content.contains("0 => 'Off'") && tag_content.contains("1 => 'On'") {
                return "PrintConvId::OnOff".to_string();
            }
            if tag_content.contains("0 => 'No'") && tag_content.contains("1 => 'Yes'") {
                return "PrintConvId::YesNo".to_string();
            }
        }
        
        // Manufacturer-specific patterns
        let manufacturer = self.manufacturer_file.trim_end_matches(".pm");
        if name_lower.contains("model") {
            return format!("PrintConvId::{}ModelLookup", manufacturer);
        }
        if name_lower.contains("lens") {
            return format!("PrintConvId::{}LensType", manufacturer);
        }
        if name_lower.contains("picture") && name_lower.contains("mode") {
            return format!("PrintConvId::{}PictureMode", manufacturer);
        }
        if name_lower.contains("scene") {
            return format!("PrintConvId::{}SceneMode", manufacturer);
        }
        
        // Default to manufacturer-specific lookup
        format!("PrintConvId::{}{}", manufacturer, tag_name.replace(' ', ""))
    }

    fn generate_real_code(&self, tags: &[TagEntry]) -> Result<String, String> {
        let manufacturer = self.manufacturer_file.trim_end_matches(".pm");
        let mut code = String::new();

        // Add header
        code.push_str(&format!(
            "//! Auto-generated {} tag table with PrintConv mappings\n\
             //!\n\
             //! EXIFTOOL-SOURCE: lib/Image/ExifTool/{}\n\
             //! EXIFTOOL-VERSION: 12.65\n\
             //!\n\
             //! This file is auto-generated by exiftool_sync extract printconv-tables.\n\
             //! Do not edit manually.\n\n\
             #![doc = \"EXIFTOOL-SOURCE: lib/Image/ExifTool/{}\"]\n\n\
             use crate::core::print_conv::PrintConvId;\n\n",
            manufacturer.to_lowercase(),
            self.manufacturer_file,
            self.manufacturer_file
        ));

        // Add tag structure
        code.push_str(&format!(
            "#[derive(Debug, Clone)]\n\
             pub struct {}Tag {{\n\
             \x20\x20\x20\x20pub id: u16,\n\
             \x20\x20\x20\x20pub name: &'static str,\n\
             \x20\x20\x20\x20pub print_conv: PrintConvId,\n\
             }}\n\n",
            manufacturer.to_uppercase()
        ));

        // Add tag table
        code.push_str(&format!(
            "/// {} tag definitions with PrintConv mappings\n\
             pub const {}_TAGS: &[{}Tag] = &[\n",
            manufacturer,
            manufacturer.to_uppercase(),
            manufacturer.to_uppercase()
        ));

        for tag in tags {
            // Convert hex string to u16
            let tag_id = if tag.id.starts_with("0x") {
                u16::from_str_radix(&tag.id[2..], 16).unwrap_or(0)
            } else {
                tag.id.parse().unwrap_or(0)
            };

            code.push_str(&format!(
                "    {}Tag {{ id: 0x{:04x}, name: \"{}\", print_conv: {} }},\n",
                manufacturer.to_uppercase(),
                tag_id,
                tag.name,
                tag.printconv_id
            ));
        }

        code.push_str("];\n\n");

        // Add lookup function
        code.push_str(&format!(
            "/// Get {} tag by ID\n\
             pub fn get_{}_tag(tag_id: u16) -> Option<&'static {}Tag> {{\n\
             \x20\x20\x20\x20{}_TAGS.iter().find(|tag| tag.id == tag_id)\n\
             }}\n",
            manufacturer.to_lowercase(),
            manufacturer.to_lowercase(),
            manufacturer.to_uppercase(),
            manufacturer.to_uppercase()
        ));

        Ok(code)
    }

    fn write_output(&self, code: &str) -> Result<(), String> {
        let manufacturer = self.manufacturer_file.trim_end_matches(".pm").to_lowercase();
        let output_path = format!("src/tables/{}_tags.rs", manufacturer);
        
        // Create directory if needed
        if let Some(parent) = Path::new(&output_path).parent() {
            fs::create_dir_all(parent)
                .map_err(|e| format!("Failed to create directory: {}", e))?;
        }
        
        fs::write(&output_path, code)
            .map_err(|e| format!("Failed to write {}: {}", output_path, e))?;
            
        println!("Generated: {}", output_path);
        
        Ok(())
    }
}