//! Modular tag kits with embedded PrintConv for exif
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: Exif.pm table: Main
//! Extracted at: Tue Jul 22 17:30:04 2025 GMT

pub mod camera;
pub mod color;
pub mod core;
pub mod datetime;
pub mod document;
pub mod exif_specific;
pub mod gps;
pub mod interop;
pub mod other;
pub mod thumbnail;
pub mod windows_xp;

use crate::expressions::ExpressionEvaluator;
use crate::types::TagValue;
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// All tag kits for exif
pub static EXIF_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    // interop tags
    for (id, tag_def) in interop::get_interop_tags() {
        map.insert(id, tag_def);
    }

    // thumbnail tags
    for (id, tag_def) in thumbnail::get_thumbnail_tags() {
        map.insert(id, tag_def);
    }

    // gps tags
    for (id, tag_def) in gps::get_gps_tags() {
        map.insert(id, tag_def);
    }

    // core tags
    for (id, tag_def) in core::get_core_tags() {
        map.insert(id, tag_def);
    }

    // datetime tags
    for (id, tag_def) in datetime::get_datetime_tags() {
        map.insert(id, tag_def);
    }

    // document tags
    for (id, tag_def) in document::get_document_tags() {
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        map.insert(id, tag_def);
    }

    // windows_xp tags
    for (id, tag_def) in windows_xp::get_windows_xp_tags() {
        map.insert(id, tag_def);
    }

    // exif_specific tags
    for (id, tag_def) in exif_specific::get_exif_specific_tags() {
        map.insert(id, tag_def);
    }

    // camera tags
    for (id, tag_def) in camera::get_camera_tags() {
        map.insert(id, tag_def);
    }

    // color tags
    for (id, tag_def) in color::get_color_tags() {
        map.insert(id, tag_def);
    }

    map
});

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    if let Some(tag_kit) = EXIF_TAG_KITS.get(&tag_id) {
        match &tag_kit.print_conv {
            PrintConvType::None => value.clone(),
            PrintConvType::Simple(lookup) => {
                // Convert value to string key for lookup
                let key = match value {
                    TagValue::U8(v) => v.to_string(),
                    TagValue::U16(v) => v.to_string(),
                    TagValue::U32(v) => v.to_string(),
                    TagValue::I16(v) => v.to_string(),
                    TagValue::I32(v) => v.to_string(),
                    TagValue::String(s) => s.clone(),
                    _ => return value.clone(),
                };

                if let Some(result) = lookup.get(&key) {
                    TagValue::String(result.to_string())
                } else {
                    TagValue::String(format!("Unknown ({})", value))
                }
            }
            PrintConvType::Expression(expr) => {
                // TODO: Implement expression evaluation
                warnings.push(format!(
                    "Expression PrintConv not yet implemented for tag {}: {}",
                    tag_kit.name, expr
                ));
                value.clone()
            }
            PrintConvType::Manual(func_name) => {
                // TODO: Look up in manual registry
                warnings.push(format!(
                    "Manual PrintConv '{}' not found for tag {}",
                    func_name, tag_kit.name
                ));
                value.clone()
            }
        }
    } else {
        // Tag not found in kit
        value.clone()
    }
}
