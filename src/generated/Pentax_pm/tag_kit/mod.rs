//! Modular tag kits with embedded PrintConv for Pentax_pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: Pentax.pm table: AEInfo
//!
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub mod color;
pub mod core;
pub mod datetime;
pub mod document;
pub mod gps;
pub mod interop;
pub mod other;
pub mod thumbnail;

use crate::expressions::ExpressionEvaluator;
use crate::tiff_types::ByteOrder;
use crate::types::{Result, TagValue};
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
    pub subdirectory: Option<SubDirectoryType>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// Type alias for subdirectory processor function
pub type SubDirectoryProcessor =
    fn(&[u8], ByteOrder, Option<&str>) -> Result<Vec<(String, TagValue)>>;

#[derive(Debug, Clone)]
pub enum SubDirectoryType {
    Binary { processor: SubDirectoryProcessor },
}

/// All tag kits for Pentax_pm
pub static PENTAX_PM_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map: HashMap<u32, TagKitDef> = HashMap::new();

    // color tags
    for (id, tag_def) in color::get_color_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // core tags
    for (id, tag_def) in core::get_core_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // datetime tags
    for (id, tag_def) in datetime::get_datetime_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // document tags
    for (id, tag_def) in document::get_document_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // gps tags
    for (id, tag_def) in gps::get_gps_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // interop tags
    for (id, tag_def) in interop::get_interop_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // thumbnail tags
    for (id, tag_def) in thumbnail::get_thumbnail_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    map
});

// Helper functions for reading binary data
fn model_matches(model: &str, pattern: &str) -> bool {
    // ExifTool regexes are already in a compatible format
    // Just need to ensure proper escaping was preserved

    match regex::Regex::new(pattern) {
        Ok(re) => re.is_match(model),
        Err(e) => {
            tracing::warn!("Failed to compile model regex '{}': {}", pattern, e);
            false
        }
    }
}

fn format_matches(format: &str, pattern: &str) -> bool {
    if let Ok(re) = regex::Regex::new(pattern) {
        re.is_match(format)
    } else {
        tracing::warn!("Failed to compile format regex: {}", pattern);
        false
    }
}

fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16u array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {
    if data.len() < 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s".to_string(),
        ));
    }
    Ok(match byte_order {
        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),
        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),
    })
}

// Subdirectory processing functions
fn process_pentax_lensdata(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AutoAperture at offset 0.1

    // MinAperture at offset 0.2

    // LensFStops at offset 0.3

    // LensKind at offset 1

    // NominalMaxAperture at offset 10

    // NominalMinAperture at offset 10.1

    // LC10 at offset 11

    // LC11 at offset 12

    // NewLensDataHook at offset 12.1

    // LC12 at offset 13

    // MaxAperture at offset 14.1

    // LC14 at offset 15

    // LC15 at offset 16

    // LC1 at offset 2

    // MinFocusDistance at offset 3

    // FocusRangeIndex at offset 3.1

    // LC3 at offset 4

    // LC4 at offset 5

    // LC5 at offset 6

    // LC6 at offset 7

    // LC7 at offset 8

    Ok(tags)
}

fn process_pentax_lensrec(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensType at offset 0
    if data.len() >= 2 {
        // TODO: Handle format int8u
    }

    // ExtenderStatus at offset 3

    Ok(tags)
}

fn process_pentax_srinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SRResult at offset 0

    // ShakeReduction at offset 1

    // SRHalfPressTime at offset 2

    // SRFocalLength at offset 3

    Ok(tags)
}

fn process_pentax_srinfo2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SRResult at offset 0

    // ShakeReduction at offset 1

    Ok(tags)
}

fn process_pentax_faceinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FacesDetected at offset 0

    // FacePosition at offset 2
    if data.len() >= 6 {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_pentax_awbinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WhiteBalanceAutoAdjustment at offset 0

    // TungstenAWB at offset 1

    Ok(tags)
}

fn process_pentax_timeinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WorldTimeLocation at offset 0.1

    // HometownDST at offset 0.2

    // DestinationDST at offset 0.3

    // HometownCity at offset 2

    // DestinationCity at offset 3

    Ok(tags)
}

fn process_pentax_lenscorr(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // DistortionCorrection at offset 0

    // ChromaticAberrationCorrection at offset 1

    // PeripheralIlluminationCorr at offset 2

    // DiffractionCorrection at offset 3

    Ok(tags)
}

fn process_pentax_camerasettings(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PictureMode2 at offset 0

    // ProgramLine at offset 1.1

    // EVSteps at offset 1.2

    // E-DialInProgram at offset 1.3

    // ApertureRingUse at offset 1.4

    // WhiteBalanceSet at offset 10

    // MultipleExposureSet at offset 10.1

    // RawAndJpgRecording at offset 13

    // JpgRecordedPixels at offset 14.1

    // LinkAEToAFPoint at offset 14.2

    // SensitivitySteps at offset 14.3

    // ISOAuto at offset 14.4

    // FlashOptions2 at offset 16

    // MeteringMode3 at offset 16.1

    // SRActive at offset 17.1

    // Rotation at offset 17.2

    // ISOSetting at offset 17.3

    // SensitivitySteps at offset 17.4

    // TvExposureTimeSetting at offset 18

    // AvApertureSetting at offset 19

    // FlashOptions at offset 2

    // MeteringMode2 at offset 2.1

    // SvISOSetting at offset 20

    // BaseExposureCompensation at offset 21

    // AFPointMode at offset 3

    // FocusMode2 at offset 3.1

    // AFPointSelected2 at offset 4
    if data.len() >= 10 {
        // TODO: Handle format int16u
    }

    // ISOFloor at offset 6

    // DriveMode2 at offset 7

    // ExposureBracketStepSize at offset 8

    // BracketShotNumber at offset 9

    Ok(tags)
}

fn process_pentax_camerasettingsunknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_pentax_aeinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AEExposureTime at offset 0

    // AEAperture at offset 1

    // AEMaxAperture2 at offset 10

    // AEMinAperture at offset 11

    // AEMeteringMode at offset 12

    // AEWhiteBalance at offset 13

    // AEMeteringMode2 at offset 13.1

    // FlashExposureCompSet at offset 14
    if data.len() >= 29 {
        // TODO: Handle format int8s
    }

    // AE_ISO at offset 2

    // LevelIndicator at offset 21

    // AEXv at offset 3

    // AEBXv at offset 4
    if data.len() >= 9 {
        // TODO: Handle format int8s
    }

    // AEMinExposureTime at offset 5

    // AEProgramMode at offset 6

    // AEFlags at offset 7

    // AEApertureSteps at offset 8

    // AEMaxAperture at offset 9

    Ok(tags)
}

fn process_pentax_aeinfo2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AEApertureSteps at offset 11

    // SceneMode at offset 15

    // AEMaxAperture at offset 16

    // AEMaxAperture2 at offset 17

    // AEMinAperture at offset 18

    // AEMinExposureTime at offset 19

    // AEExposureTime at offset 2

    // AEAperture at offset 3

    // AE_ISO at offset 4

    // AEXv at offset 5

    // AEBXv at offset 6
    if data.len() >= 13 {
        // TODO: Handle format int8s
    }

    // AEError at offset 8
    if data.len() >= 17 {
        // TODO: Handle format int8s
    }

    Ok(tags)
}

fn process_pentax_aeinfo3(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AEExposureTime at offset 16

    // AEAperture at offset 17

    // AE_ISO at offset 18

    // AEMaxAperture at offset 28

    // AEMaxAperture2 at offset 29

    // AEMinAperture at offset 30

    // AEMinExposureTime at offset 31

    Ok(tags)
}

fn process_pentax_aeinfounknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_pentax_lensinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensType at offset 0
    if data.len() >= 2 {
        // TODO: Handle format int8u
    }

    // LensData at offset 3
    if data.len() >= 40 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_pentax_lensinfo2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensType at offset 0
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // LensData at offset 4
    if data.len() >= 42 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_pentax_lensinfo3(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensType at offset 1
    if data.len() >= 6 {
        // TODO: Handle format int8u
    }

    // LensData at offset 13
    if data.len() >= 60 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_pentax_lensinfo4(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensType at offset 1
    if data.len() >= 6 {
        // TODO: Handle format int8u
    }

    // LensData at offset 12
    if data.len() >= 60 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_pentax_lensinfo5(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensType at offset 1
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // LensData at offset 15
    if data.len() >= 64 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_pentax_flashinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FlashStatus at offset 0

    // InternalFlashMode at offset 1

    // ExternalFlashMode at offset 2

    // ExternalFlashGuideNumber at offset 24.1

    // ExternalFlashExposureComp at offset 25

    // ExternalFlashBounce at offset 26

    // InternalFlashStrength at offset 3

    Ok(tags)
}

fn process_pentax_flashinfounknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_pentax_camerainfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PentaxModelID at offset 0

    // ManufactureDate at offset 1

    // ProductionCode at offset 2
    if data.len() >= 16 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_pentax_batteryinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PowerAvailable at offset 0.2

    // GripBatteryState at offset 16

    // GripBatteryPercent at offset 17

    // GripBatteryVoltage at offset 18
    if data.len() >= 40 {
        // TODO: Handle format int32u
    }

    // GripBatteryADLoad at offset 5

    // BodyBatteryVoltage3 at offset 6
    if data.len() >= 14 {
        // TODO: Handle format int16u
    }

    // BodyBatteryVoltage4 at offset 8
    if data.len() >= 18 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_pentax_afinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFPointsUnknown1 at offset 0
    if data.len() >= 2 {
        // TODO: Handle format int16u
    }

    // AFPointsInFocus at offset 11

    // AFPointsUnknown2 at offset 2
    if data.len() >= 6 {
        // TODO: Handle format int16u
    }

    // AFPointValues at offset 20
    if data.len() >= 178 {
        // TODO: Handle format int16uRev
    }

    // AFPointsSelected at offset 298
    if data.len() >= 697 {
        // TODO: Handle format int8u
    }

    // AFPointsUnknown at offset 399
    if data.len() >= 899 {
        // TODO: Handle format int8u
    }

    // AFPredictor at offset 4
    if data.len() >= 10 {
        if let Ok(value) = read_int16s(&data[8..10], byte_order) {
            tags.push(("AFPredictor".to_string(), TagValue::I16(value)));
        }
    }

    // LiveView at offset 506

    // AFHold at offset 509

    // AFIntegrationTime at offset 7

    Ok(tags)
}

fn process_pentax_kelvinwb(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // KelvinWB_Daylight at offset 1
    if data.len() >= 10 {
        if let Ok(values) = read_int16u_array(&data[2..10], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_Daylight".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_03 at offset 13
    if data.len() >= 34 {
        if let Ok(values) = read_int16u_array(&data[26..34], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_03".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_04 at offset 17
    if data.len() >= 42 {
        if let Ok(values) = read_int16u_array(&data[34..42], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_04".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_05 at offset 21
    if data.len() >= 50 {
        if let Ok(values) = read_int16u_array(&data[42..50], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_05".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_06 at offset 25
    if data.len() >= 58 {
        if let Ok(values) = read_int16u_array(&data[50..58], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_06".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_07 at offset 29
    if data.len() >= 66 {
        if let Ok(values) = read_int16u_array(&data[58..66], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_07".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_08 at offset 33
    if data.len() >= 74 {
        if let Ok(values) = read_int16u_array(&data[66..74], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_08".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_09 at offset 37
    if data.len() >= 82 {
        if let Ok(values) = read_int16u_array(&data[74..82], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_09".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_10 at offset 41
    if data.len() >= 90 {
        if let Ok(values) = read_int16u_array(&data[82..90], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_10".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_11 at offset 45
    if data.len() >= 98 {
        if let Ok(values) = read_int16u_array(&data[90..98], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_11".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_12 at offset 49
    if data.len() >= 106 {
        if let Ok(values) = read_int16u_array(&data[98..106], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_12".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_01 at offset 5
    if data.len() >= 18 {
        if let Ok(values) = read_int16u_array(&data[10..18], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_01".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_13 at offset 53
    if data.len() >= 114 {
        if let Ok(values) = read_int16u_array(&data[106..114], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_13".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_14 at offset 57
    if data.len() >= 122 {
        if let Ok(values) = read_int16u_array(&data[114..122], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_14".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_15 at offset 61
    if data.len() >= 130 {
        if let Ok(values) = read_int16u_array(&data[122..130], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_15".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_16 at offset 65
    if data.len() >= 138 {
        if let Ok(values) = read_int16u_array(&data[130..138], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_16".to_string(), TagValue::String(value_str)));
        }
    }

    // KelvinWB_02 at offset 9
    if data.len() >= 26 {
        if let Ok(values) = read_int16u_array(&data[18..26], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("KelvinWB_02".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_pentax_colorinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WBShiftAB at offset 16

    // WBShiftGM at offset 17

    Ok(tags)
}

fn process_pentax_evstepinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // EVSteps at offset 0

    // SensitivitySteps at offset 1

    // LiveView at offset 3

    Ok(tags)
}

fn process_pentax_shotinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CameraOrientation at offset 1

    Ok(tags)
}

fn process_pentax_facepos(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Face1Position at offset 0
    if data.len() >= 4 {
        if let Ok(values) = read_int16u_array(&data[0..4], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face1Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face6Position at offset 10
    if data.len() >= 24 {
        if let Ok(values) = read_int16u_array(&data[20..24], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face6Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face7Position at offset 12
    if data.len() >= 28 {
        if let Ok(values) = read_int16u_array(&data[24..28], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face7Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face8Position at offset 14
    if data.len() >= 32 {
        if let Ok(values) = read_int16u_array(&data[28..32], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face8Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face9Position at offset 16
    if data.len() >= 36 {
        if let Ok(values) = read_int16u_array(&data[32..36], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face9Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face10Position at offset 18
    if data.len() >= 40 {
        if let Ok(values) = read_int16u_array(&data[36..40], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face10Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face2Position at offset 2
    if data.len() >= 8 {
        if let Ok(values) = read_int16u_array(&data[4..8], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face2Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face11Position at offset 20
    if data.len() >= 44 {
        if let Ok(values) = read_int16u_array(&data[40..44], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face11Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face12Position at offset 22
    if data.len() >= 48 {
        if let Ok(values) = read_int16u_array(&data[44..48], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face12Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face13Position at offset 24
    if data.len() >= 52 {
        if let Ok(values) = read_int16u_array(&data[48..52], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face13Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face14Position at offset 26
    if data.len() >= 56 {
        if let Ok(values) = read_int16u_array(&data[52..56], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face14Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face15Position at offset 28
    if data.len() >= 60 {
        if let Ok(values) = read_int16u_array(&data[56..60], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face15Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face16Position at offset 30
    if data.len() >= 64 {
        if let Ok(values) = read_int16u_array(&data[60..64], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face16Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face17Position at offset 32
    if data.len() >= 68 {
        if let Ok(values) = read_int16u_array(&data[64..68], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face17Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face18Position at offset 34
    if data.len() >= 72 {
        if let Ok(values) = read_int16u_array(&data[68..72], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face18Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face19Position at offset 36
    if data.len() >= 76 {
        if let Ok(values) = read_int16u_array(&data[72..76], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face19Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face20Position at offset 38
    if data.len() >= 80 {
        if let Ok(values) = read_int16u_array(&data[76..80], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face20Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face3Position at offset 4
    if data.len() >= 12 {
        if let Ok(values) = read_int16u_array(&data[8..12], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face3Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face21Position at offset 40
    if data.len() >= 84 {
        if let Ok(values) = read_int16u_array(&data[80..84], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face21Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face22Position at offset 42
    if data.len() >= 88 {
        if let Ok(values) = read_int16u_array(&data[84..88], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face22Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face23Position at offset 44
    if data.len() >= 92 {
        if let Ok(values) = read_int16u_array(&data[88..92], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face23Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face24Position at offset 46
    if data.len() >= 96 {
        if let Ok(values) = read_int16u_array(&data[92..96], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face24Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face25Position at offset 48
    if data.len() >= 100 {
        if let Ok(values) = read_int16u_array(&data[96..100], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face25Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face26Position at offset 50
    if data.len() >= 104 {
        if let Ok(values) = read_int16u_array(&data[100..104], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face26Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face27Position at offset 52
    if data.len() >= 108 {
        if let Ok(values) = read_int16u_array(&data[104..108], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face27Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face28Position at offset 54
    if data.len() >= 112 {
        if let Ok(values) = read_int16u_array(&data[108..112], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face28Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face29Position at offset 56
    if data.len() >= 116 {
        if let Ok(values) = read_int16u_array(&data[112..116], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face29Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face30Position at offset 58
    if data.len() >= 120 {
        if let Ok(values) = read_int16u_array(&data[116..120], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face30Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face4Position at offset 6
    if data.len() >= 16 {
        if let Ok(values) = read_int16u_array(&data[12..16], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face4Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face31Position at offset 60
    if data.len() >= 124 {
        if let Ok(values) = read_int16u_array(&data[120..124], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face31Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face32Position at offset 62
    if data.len() >= 128 {
        if let Ok(values) = read_int16u_array(&data[124..128], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face32Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face5Position at offset 8
    if data.len() >= 20 {
        if let Ok(values) = read_int16u_array(&data[16..20], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face5Position".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_pentax_facesize(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Face1Size at offset 0
    if data.len() >= 4 {
        if let Ok(values) = read_int16u_array(&data[0..4], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face1Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face6Size at offset 10
    if data.len() >= 24 {
        if let Ok(values) = read_int16u_array(&data[20..24], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face6Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face7Size at offset 12
    if data.len() >= 28 {
        if let Ok(values) = read_int16u_array(&data[24..28], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face7Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face8Size at offset 14
    if data.len() >= 32 {
        if let Ok(values) = read_int16u_array(&data[28..32], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face8Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face9Size at offset 16
    if data.len() >= 36 {
        if let Ok(values) = read_int16u_array(&data[32..36], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face9Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face10Size at offset 18
    if data.len() >= 40 {
        if let Ok(values) = read_int16u_array(&data[36..40], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face10Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face2Size at offset 2
    if data.len() >= 8 {
        if let Ok(values) = read_int16u_array(&data[4..8], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face2Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face11Size at offset 20
    if data.len() >= 44 {
        if let Ok(values) = read_int16u_array(&data[40..44], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face11Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face12Size at offset 22
    if data.len() >= 48 {
        if let Ok(values) = read_int16u_array(&data[44..48], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face12Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face13Size at offset 24
    if data.len() >= 52 {
        if let Ok(values) = read_int16u_array(&data[48..52], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face13Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face14Size at offset 26
    if data.len() >= 56 {
        if let Ok(values) = read_int16u_array(&data[52..56], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face14Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face15Size at offset 28
    if data.len() >= 60 {
        if let Ok(values) = read_int16u_array(&data[56..60], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face15Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face16Size at offset 30
    if data.len() >= 64 {
        if let Ok(values) = read_int16u_array(&data[60..64], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face16Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face17Size at offset 32
    if data.len() >= 68 {
        if let Ok(values) = read_int16u_array(&data[64..68], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face17Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face18Size at offset 34
    if data.len() >= 72 {
        if let Ok(values) = read_int16u_array(&data[68..72], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face18Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face19Size at offset 36
    if data.len() >= 76 {
        if let Ok(values) = read_int16u_array(&data[72..76], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face19Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face20Size at offset 38
    if data.len() >= 80 {
        if let Ok(values) = read_int16u_array(&data[76..80], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face20Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face3Size at offset 4
    if data.len() >= 12 {
        if let Ok(values) = read_int16u_array(&data[8..12], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face3Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face21Size at offset 40
    if data.len() >= 84 {
        if let Ok(values) = read_int16u_array(&data[80..84], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face21Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face22Size at offset 42
    if data.len() >= 88 {
        if let Ok(values) = read_int16u_array(&data[84..88], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face22Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face23Size at offset 44
    if data.len() >= 92 {
        if let Ok(values) = read_int16u_array(&data[88..92], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face23Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face24Size at offset 46
    if data.len() >= 96 {
        if let Ok(values) = read_int16u_array(&data[92..96], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face24Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face25Size at offset 48
    if data.len() >= 100 {
        if let Ok(values) = read_int16u_array(&data[96..100], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face25Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face26Size at offset 50
    if data.len() >= 104 {
        if let Ok(values) = read_int16u_array(&data[100..104], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face26Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face27Size at offset 52
    if data.len() >= 108 {
        if let Ok(values) = read_int16u_array(&data[104..108], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face27Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face28Size at offset 54
    if data.len() >= 112 {
        if let Ok(values) = read_int16u_array(&data[108..112], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face28Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face29Size at offset 56
    if data.len() >= 116 {
        if let Ok(values) = read_int16u_array(&data[112..116], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face29Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face30Size at offset 58
    if data.len() >= 120 {
        if let Ok(values) = read_int16u_array(&data[116..120], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face30Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face4Size at offset 6
    if data.len() >= 16 {
        if let Ok(values) = read_int16u_array(&data[12..16], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face4Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face31Size at offset 60
    if data.len() >= 124 {
        if let Ok(values) = read_int16u_array(&data[120..124], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face31Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face32Size at offset 62
    if data.len() >= 128 {
        if let Ok(values) = read_int16u_array(&data[124..128], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face32Size".to_string(), TagValue::String(value_str)));
        }
    }

    // Face5Size at offset 8
    if data.len() >= 20 {
        if let Ok(values) = read_int16u_array(&data[16..20], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face5Size".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_pentax_filterinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SourceDirectoryIndex at offset 0
    if data.len() >= 2 {
        // TODO: Handle format int16u
    }

    // DigitalFilter07 at offset 107
    if data.len() >= 141 {
        // TODO: Handle format undef
    }

    // DigitalFilter08 at offset 124
    if data.len() >= 158 {
        // TODO: Handle format undef
    }

    // DigitalFilter09 at offset 141
    if data.len() >= 175 {
        // TODO: Handle format undef
    }

    // DigitalFilter10 at offset 158
    if data.len() >= 192 {
        // TODO: Handle format undef
    }

    // DigitalFilter11 at offset 175
    if data.len() >= 209 {
        // TODO: Handle format undef
    }

    // DigitalFilter12 at offset 192
    if data.len() >= 226 {
        // TODO: Handle format undef
    }

    // SourceFileIndex at offset 2
    if data.len() >= 4 {
        // TODO: Handle format int16u
    }

    // DigitalFilter13 at offset 209
    if data.len() >= 243 {
        // TODO: Handle format undef
    }

    // DigitalFilter02 at offset 22
    if data.len() >= 56 {
        // TODO: Handle format undef
    }

    // DigitalFilter14 at offset 226
    if data.len() >= 260 {
        // TODO: Handle format undef
    }

    // DigitalFilter15 at offset 243
    if data.len() >= 277 {
        // TODO: Handle format undef
    }

    // DigitalFilter16 at offset 260
    if data.len() >= 294 {
        // TODO: Handle format undef
    }

    // DigitalFilter17 at offset 277
    if data.len() >= 311 {
        // TODO: Handle format undef
    }

    // DigitalFilter18 at offset 294
    if data.len() >= 328 {
        // TODO: Handle format undef
    }

    // DigitalFilter19 at offset 311
    if data.len() >= 345 {
        // TODO: Handle format undef
    }

    // DigitalFilter20 at offset 328
    if data.len() >= 362 {
        // TODO: Handle format undef
    }

    // DigitalFilter03 at offset 39
    if data.len() >= 73 {
        // TODO: Handle format undef
    }

    // DigitalFilter01 at offset 5
    if data.len() >= 39 {
        // TODO: Handle format undef
    }

    // DigitalFilter04 at offset 56
    if data.len() >= 90 {
        // TODO: Handle format undef
    }

    // DigitalFilter05 at offset 73
    if data.len() >= 107 {
        // TODO: Handle format undef
    }

    // DigitalFilter06 at offset 90
    if data.len() >= 124 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_pentax_levelinfok3iii(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CameraOrientation at offset 1

    // RollAngle at offset 3
    if data.len() >= 5 {
        if let Ok(value) = read_int16s(&data[3..5], byte_order) {
            tags.push(("RollAngle".to_string(), TagValue::I16(value)));
        }
    }

    // PitchAngle at offset 5
    if data.len() >= 7 {
        if let Ok(value) = read_int16s(&data[5..7], byte_order) {
            tags.push(("PitchAngle".to_string(), TagValue::I16(value)));
        }
    }

    Ok(tags)
}

fn process_pentax_levelinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LevelOrientation at offset 0

    // CompositionAdjust at offset 0.1

    // RollAngle at offset 1

    // PitchAngle at offset 2

    // CompositionAdjustX at offset 5

    // CompositionAdjustY at offset 6

    // CompositionAdjustRotation at offset 7

    Ok(tags)
}

fn process_pentax_wblevels(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_RGGBLevelsShade at offset 11
    if data.len() >= 30 {
        if let Ok(values) = read_int16u_array(&data[22..30], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsDaylight at offset 2
    if data.len() >= 12 {
        if let Ok(values) = read_int16u_array(&data[4..12], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 20
    if data.len() >= 48 {
        if let Ok(values) = read_int16u_array(&data[40..48], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 29
    if data.len() >= 66 {
        if let Ok(values) = read_int16u_array(&data[58..66], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescentD at offset 38
    if data.len() >= 84 {
        if let Ok(values) = read_int16u_array(&data[76..84], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescentD".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescentN at offset 47
    if data.len() >= 102 {
        if let Ok(values) = read_int16u_array(&data[94..102], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescentN".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescentW at offset 56
    if data.len() >= 120 {
        if let Ok(values) = read_int16u_array(&data[112..120], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescentW".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 65
    if data.len() >= 138 {
        if let Ok(values) = read_int16u_array(&data[130..138], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescentL at offset 74
    if data.len() >= 156 {
        if let Ok(values) = read_int16u_array(&data[148..156], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescentL".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown at offset 83
    if data.len() >= 174 {
        if let Ok(values) = read_int16u_array(&data[166..174], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUserSelected at offset 92
    if data.len() >= 192 {
        if let Ok(values) = read_int16u_array(&data[184..192], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUserSelected".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_pentax_cafpointinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // NumCAFPoints at offset 1

    // CAFGridSize at offset 1.1

    // CAFPointsInFocus at offset 2

    // CAFPointsSelected at offset 2.1

    Ok(tags)
}

fn process_pentax_lensinfoq(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensModel at offset 12
    if data.len() >= 84 {
        // TODO: Handle format string
    }

    // LensInfo at offset 42
    if data.len() >= 124 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_pentax_pixelshiftinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PixelShiftResolution at offset 0

    Ok(tags)
}

fn process_pentax_afpointinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // NumAFPoints at offset 2
    if data.len() >= 6 {
        // TODO: Handle format int16u
    }

    // AFPointsInFocus at offset 4

    // AFPointsSelected at offset 4.1

    // AFPointsSpecial at offset 4.2

    Ok(tags)
}

fn process_pentax_tempinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SensorTemperature at offset 12
    if data.len() >= 26 {
        if let Ok(value) = read_int16s(&data[24..26], byte_order) {
            tags.push(("SensorTemperature".to_string(), TagValue::I16(value)));
        }
    }

    // SensorTemperature2 at offset 14
    if data.len() >= 30 {
        if let Ok(value) = read_int16s(&data[28..30], byte_order) {
            tags.push(("SensorTemperature2".to_string(), TagValue::I16(value)));
        }
    }

    // CameraTemperature4 at offset 20
    if data.len() >= 42 {
        if let Ok(value) = read_int16s(&data[40..42], byte_order) {
            tags.push(("CameraTemperature4".to_string(), TagValue::I16(value)));
        }
    }

    // CameraTemperature5 at offset 22
    if data.len() >= 46 {
        if let Ok(value) = read_int16s(&data[44..46], byte_order) {
            tags.push(("CameraTemperature5".to_string(), TagValue::I16(value)));
        }
    }

    // SensorTemperature at offset 42
    if data.len() >= 86 {
        if let Ok(value) = read_int16s(&data[84..86], byte_order) {
            tags.push(("SensorTemperature".to_string(), TagValue::I16(value)));
        }
    }

    Ok(tags)
}

fn process_pentax_unknowninfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_pentax_faceinfok3iii(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FaceImageSize at offset 0
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // FaceInfoK3III at offset 0.1

    // Face1AArea at offset 10
    if data.len() >= 56 {
        // TODO: Handle format int32u
    }

    // Face6AArea at offset 110
    if data.len() >= 456 {
        // TODO: Handle format int32u
    }

    // Face6AEye1 at offset 114
    if data.len() >= 472 {
        // TODO: Handle format int32u
    }

    // Face6AEye2 at offset 118
    if data.len() >= 488 {
        // TODO: Handle format int32u
    }

    // Face7AArea at offset 130
    if data.len() >= 536 {
        // TODO: Handle format int32u
    }

    // Face7AEye1 at offset 134
    if data.len() >= 552 {
        // TODO: Handle format int32u
    }

    // Face7AEye2 at offset 138
    if data.len() >= 568 {
        // TODO: Handle format int32u
    }

    // Face1AEye1 at offset 14
    if data.len() >= 72 {
        // TODO: Handle format int32u
    }

    // Face8AArea at offset 150
    if data.len() >= 616 {
        // TODO: Handle format int32u
    }

    // Face8AEye1 at offset 154
    if data.len() >= 632 {
        // TODO: Handle format int32u
    }

    // Face8AEye2 at offset 158
    if data.len() >= 648 {
        // TODO: Handle format int32u
    }

    // Face9AArea at offset 170
    if data.len() >= 696 {
        // TODO: Handle format int32u
    }

    // Face9AEye1 at offset 174
    if data.len() >= 712 {
        // TODO: Handle format int32u
    }

    // Face9AEye2 at offset 178
    if data.len() >= 728 {
        // TODO: Handle format int32u
    }

    // Face1AEye2 at offset 18
    if data.len() >= 88 {
        // TODO: Handle format int32u
    }

    // Face10AArea at offset 190
    if data.len() >= 776 {
        // TODO: Handle format int32u
    }

    // Face10AEye1 at offset 194
    if data.len() >= 792 {
        // TODO: Handle format int32u
    }

    // Face10AEye2 at offset 198
    if data.len() >= 808 {
        // TODO: Handle format int32u
    }

    // CAFArea at offset 2
    if data.len() >= 24 {
        // TODO: Handle format int32u
    }

    // Face1BArea at offset 210
    if data.len() >= 856 {
        // TODO: Handle format int32u
    }

    // Face1BEye1 at offset 214
    if data.len() >= 872 {
        // TODO: Handle format int32u
    }

    // Face1BEye2 at offset 218
    if data.len() >= 888 {
        // TODO: Handle format int32u
    }

    // Face2BArea at offset 230
    if data.len() >= 936 {
        // TODO: Handle format int32u
    }

    // Face2BEye1 at offset 234
    if data.len() >= 952 {
        // TODO: Handle format int32u
    }

    // Face2BEye2 at offset 238
    if data.len() >= 968 {
        // TODO: Handle format int32u
    }

    // Face3BArea at offset 250
    if data.len() >= 1016 {
        // TODO: Handle format int32u
    }

    // Face3BEye1 at offset 254
    if data.len() >= 1032 {
        // TODO: Handle format int32u
    }

    // Face3BEye2 at offset 258
    if data.len() >= 1048 {
        // TODO: Handle format int32u
    }

    // Face4BArea at offset 270
    if data.len() >= 1096 {
        // TODO: Handle format int32u
    }

    // Face4BEye1 at offset 274
    if data.len() >= 1112 {
        // TODO: Handle format int32u
    }

    // Face4BEye2 at offset 278
    if data.len() >= 1128 {
        // TODO: Handle format int32u
    }

    // Face5BArea at offset 290
    if data.len() >= 1176 {
        // TODO: Handle format int32u
    }

    // Face5BEye1 at offset 294
    if data.len() >= 1192 {
        // TODO: Handle format int32u
    }

    // Face5BEye2 at offset 298
    if data.len() >= 1208 {
        // TODO: Handle format int32u
    }

    // Face2AArea at offset 30
    if data.len() >= 136 {
        // TODO: Handle format int32u
    }

    // Face6BArea at offset 310
    if data.len() >= 1256 {
        // TODO: Handle format int32u
    }

    // Face6BEye1 at offset 314
    if data.len() >= 1272 {
        // TODO: Handle format int32u
    }

    // Face6BEye2 at offset 318
    if data.len() >= 1288 {
        // TODO: Handle format int32u
    }

    // Face7BArea at offset 330
    if data.len() >= 1336 {
        // TODO: Handle format int32u
    }

    // Face7BEye1 at offset 334
    if data.len() >= 1352 {
        // TODO: Handle format int32u
    }

    // Face7BEye2 at offset 338
    if data.len() >= 1368 {
        // TODO: Handle format int32u
    }

    // Face2AEye1 at offset 34
    if data.len() >= 152 {
        // TODO: Handle format int32u
    }

    // Face8BArea at offset 350
    if data.len() >= 1416 {
        // TODO: Handle format int32u
    }

    // Face8BEye1 at offset 354
    if data.len() >= 1432 {
        // TODO: Handle format int32u
    }

    // Face8BEye2 at offset 358
    if data.len() >= 1448 {
        // TODO: Handle format int32u
    }

    // Face9BArea at offset 370
    if data.len() >= 1496 {
        // TODO: Handle format int32u
    }

    // Face9BEye1 at offset 374
    if data.len() >= 1512 {
        // TODO: Handle format int32u
    }

    // Face9BEye2 at offset 378
    if data.len() >= 1528 {
        // TODO: Handle format int32u
    }

    // Face2AEye2 at offset 38
    if data.len() >= 168 {
        // TODO: Handle format int32u
    }

    // Face10BArea at offset 390
    if data.len() >= 1576 {
        // TODO: Handle format int32u
    }

    // Face10BEye1 at offset 394
    if data.len() >= 1592 {
        // TODO: Handle format int32u
    }

    // Face10BEye2 at offset 398
    if data.len() >= 1608 {
        // TODO: Handle format int32u
    }

    // Face3AArea at offset 50
    if data.len() >= 216 {
        // TODO: Handle format int32u
    }

    // Face3AEye1 at offset 54
    if data.len() >= 232 {
        // TODO: Handle format int32u
    }

    // Face3AEye2 at offset 58
    if data.len() >= 248 {
        // TODO: Handle format int32u
    }

    // FacesDetectedA at offset 6

    // Face4AArea at offset 70
    if data.len() >= 296 {
        // TODO: Handle format int32u
    }

    // Face4AEye1 at offset 74
    if data.len() >= 312 {
        // TODO: Handle format int32u
    }

    // Face4AEye2 at offset 78
    if data.len() >= 328 {
        // TODO: Handle format int32u
    }

    // FacesDetectedB at offset 8

    // Face5AArea at offset 90
    if data.len() >= 376 {
        // TODO: Handle format int32u
    }

    // Face5AEye1 at offset 94
    if data.len() >= 392 {
        // TODO: Handle format int32u
    }

    // Face5AEye2 at offset 98
    if data.len() >= 408 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_pentax_afinfok3iii(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFInfo at offset 0

    // AFMode at offset 0.1

    // AFSelectionMode at offset 1

    // AFAreaSize at offset 11
    if data.len() >= 26 {
        if let Ok(values) = read_int16u_array(&data[22..26], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("AFAreaSize".to_string(), TagValue::String(value_str)));
        }
    }

    // NumAFPoints at offset 3

    // AFFrameSize at offset 7
    if data.len() >= 18 {
        if let Ok(values) = read_int16u_array(&data[14..18], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("AFFrameSize".to_string(), TagValue::String(value_str)));
        }
    }

    // AFAreas at offset 7.1

    Ok(tags)
}

// Functions for tables not extracted by tag kit
fn process_pentax_main(data: &[u8], _byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

pub fn process_tag_0x0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x3_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x3_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_lensdata(data, byte_order)
}

pub fn process_tag_0x4_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_lensdata(data, byte_order)
}

pub fn process_tag_0xc_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $$self{NewLensData} = 1
    // Would dispatch to: Image::ExifTool::Pentax::LensData
    Ok(vec![])
}

pub fn process_tag_0xd_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xd_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_lensdata(data, byte_order)
}

pub fn process_tag_0xf_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xf_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_lensdata(data, byte_order)
}

pub fn process_tag_0x3f_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x3f_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_lensrec(data, byte_order)
}

pub fn process_tag_0x5c_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x5c_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    match count {
        4 => {
            debug!("Matched count 4 for variant pentax_srinfo");
            process_pentax_srinfo(data, byte_order)
        }
        _ => Ok(vec![]), // No matching variant
    }
}

pub fn process_tag_0x60_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x60_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_faceinfo(data, byte_order)
}

pub fn process_tag_0x68_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x68_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_awbinfo(data, byte_order)
}

pub fn process_tag_0x6b_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x6b_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_timeinfo(data, byte_order)
}

pub fn process_tag_0x7d_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x7d_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_lenscorr(data, byte_order)
}

pub fn process_tag_0x205_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x205_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $count < 25
    // Would dispatch to: Image::ExifTool::Pentax::CameraSettings
    Ok(vec![])
}

pub fn process_tag_0x206_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x206_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $count <= 25 and $count != 21 and $$self{AEInfoSize} = $count
    // Would dispatch to: Image::ExifTool::Pentax::AEInfo
    match count {
        21 => {
            debug!("Matched count 21 for variant pentax_aeinfo2");
            process_pentax_aeinfo2(data, byte_order)
        }
        48 => {
            debug!("Matched count 48 for variant pentax_aeinfo3");
            process_pentax_aeinfo3(data, byte_order)
        }
        64 => {
            debug!("Matched count 64 for variant pentax_aeinfo3");
            process_pentax_aeinfo3(data, byte_order)
        }
        _ => Ok(vec![]), // No matching variant
    }
}

pub fn process_tag_0x207_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x207_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Model condition: $$self{Model}=~/(\\*ist|GX-1[LS])/ or ($$self{Model}=~/(K100D|K110D)/ and $$valPt=~/^.{20}(\\xff|\\0\\0)/s)
    if let Some(model) = &model {
        let mut evaluator = ExpressionEvaluator::new();
        let processor_context = ProcessorContext::default().with_model(model.to_string());
        if evaluator.evaluate_context_condition(&processor_context, "$$self{Model}=~/(\\*ist|GX-1[LS])/ or ($$self{Model}=~/(K100D|K110D)/ and $$valPt=~/^.{20}(\\xff|\\0\\0)/s)").unwrap_or(false) {
            debug!("Model condition matched: $$self{{Model}}=~/(\\*ist|GX-1[LS])/ or ($$self{{Model}}=~/(K100D|K110D)/ and $$valPt=~/^.{{20}}(\\xff|\\0\\0)/s) for pentax_lensinfo");
            return process_pentax_lensinfo(data, byte_order);
        }
    }
    // Runtime condition not yet supported: $count != 90 and $count != 91 and $count != 80 and $count != 128 and $count != 168
    // Would dispatch to: Image::ExifTool::Pentax::LensInfo2
    match count {
        90 => {
            debug!("Matched count 90 for variant pentax_lensinfo3");
            process_pentax_lensinfo3(data, byte_order)
        }
        91 => {
            debug!("Matched count 91 for variant pentax_lensinfo4");
            process_pentax_lensinfo4(data, byte_order)
        }
        80 => {
            debug!("Matched count 80 for variant pentax_lensinfo5");
            process_pentax_lensinfo5(data, byte_order)
        }
        128 => {
            debug!("Matched count 128 for variant pentax_lensinfo5");
            process_pentax_lensinfo5(data, byte_order)
        }
        _ => Ok(vec![]), // No matching variant
    }
}

pub fn process_tag_0x208_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x208_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    match count {
        27 => {
            debug!("Matched count 27 for variant pentax_flashinfo");
            process_pentax_flashinfo(data, byte_order)
        }
        _ => Ok(vec![]), // No matching variant
    }
}

pub fn process_tag_0x215_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x215_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_camerainfo(data, byte_order)
}

pub fn process_tag_0x216_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x216_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_batteryinfo(data, byte_order)
}

pub fn process_tag_0x21f_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x21f_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_afinfo(data, byte_order)
}

pub fn process_tag_0x221_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x221_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_kelvinwb(data, byte_order)
}

pub fn process_tag_0x222_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x222_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_colorinfo(data, byte_order)
}

pub fn process_tag_0x224_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x224_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_evstepinfo(data, byte_order)
}

pub fn process_tag_0x226_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x226_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_shotinfo(data, byte_order)
}

pub fn process_tag_0x227_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x227_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $$self{FacesDetected}
    // Would dispatch to: Image::ExifTool::Pentax::FacePos
    Ok(vec![])
}

pub fn process_tag_0x228_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x228_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $$self{FacesDetected}
    // Would dispatch to: Image::ExifTool::Pentax::FaceSize
    Ok(vec![])
}

pub fn process_tag_0x22a_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x22a_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $$self{Make} =~ /^RICOH/
    // Would dispatch to: Image::ExifTool::Pentax::FilterInfo
    Ok(vec![])
}

pub fn process_tag_0x22b_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x22b_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $$self{Model} eq \"PENTAX K-3 Mark III\"
    // Would dispatch to: Image::ExifTool::Pentax::LevelInfoK3III
    Ok(vec![])
}

pub fn process_tag_0x22d_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x22d_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    match count {
        100 => {
            debug!("Matched count 100 for variant pentax_wblevels");
            process_pentax_wblevels(data, byte_order)
        }
        _ => Ok(vec![]), // No matching variant
    }
}

pub fn process_tag_0x238_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x238_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_cafpointinfo(data, byte_order)
}

pub fn process_tag_0x239_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x239_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_lensinfoq(data, byte_order)
}

pub fn process_tag_0x243_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x243_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_pixelshiftinfo(data, byte_order)
}

pub fn process_tag_0x245_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x245_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_afpointinfo(data, byte_order)
}

pub fn process_tag_0x3ff_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x3ff_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Model condition: $$self{Model} =~ /K-(01|3|30|5|50|500)\\b/
    if let Some(model) = &model {
        let mut evaluator = ExpressionEvaluator::new();
        let processor_context = ProcessorContext::default().with_model(model.to_string());
        if evaluator
            .evaluate_context_condition(
                &processor_context,
                "$$self{Model} =~ /K-(01|3|30|5|50|500)\\b/",
            )
            .unwrap_or(false)
        {
            debug!("Model condition matched: $$self{{Model}} =~ /K-(01|3|30|5|50|500)\\b/ for pentax_tempinfo");
            return process_pentax_tempinfo(data, byte_order);
        }
    }
    Ok(vec![])
}

pub fn process_tag_0x40b_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x40b_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_faceinfok3iii(data, byte_order)
}

pub fn process_tag_0x40c_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x40c_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_pentax_afinfok3iii(data, byte_order)
}

pub fn process_tag_0xe00_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe00_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    match tag_id {
        0 => crate::implementations::print_conv::exposuretime_print_conv(value),
        2 => crate::implementations::print_conv::exposuretime_print_conv(value),
        5 => crate::implementations::print_conv::exposuretime_print_conv(value),
        16 => crate::implementations::print_conv::exposuretime_print_conv(value),
        18 => crate::implementations::print_conv::exposuretime_print_conv(value),
        19 => crate::implementations::print_conv::exposuretime_print_conv(value),
        31 => crate::implementations::print_conv::exposuretime_print_conv(value),
        38 => crate::implementations::print_conv::exposuretime_print_conv(value),
        42 => crate::implementations::print_conv::lensinfo_print_conv(value),
        56 => crate::implementations::print_conv::exposuretime_print_conv(value),
        207 => crate::implementations::print_conv::gpslatituderef_print_conv(value),
        233 => crate::implementations::print_conv::gpslongituderef_print_conv(value),
        259 => crate::implementations::print_conv::gpsaltituderef_print_conv(value),
        260 => crate::implementations::print_conv::gpsaltitude_print_conv(value),
        519 => crate::implementations::print_conv::lensinfo_print_conv(value),
        _ => {
            // Fall back to shared handling
            if let Some(tag_kit) = PENTAX_PM_TAG_KITS.get(&tag_id) {
                crate::implementations::generic::apply_fallback_print_conv(
                    tag_id,
                    &tag_kit.name,
                    "Pentax",
                    value,
                    crate::to_print_conv_ref!(&tag_kit.print_conv),
                )
            } else {
                value.clone()
            }
        }
    }
}

/// Apply ValueConv for a tag from this module
pub fn apply_value_conv(
    tag_id: u32,
    value: &TagValue,
    _errors: &mut Vec<String>,
) -> Result<TagValue> {
    match tag_id {
        20 => {
            if let Some(tag_kit) = PENTAX_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Pentax",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        24 => {
            if let Some(tag_kit) = PENTAX_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Pentax",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        38 => crate::implementations::value_conv::reciprocal_10_value_conv(value),
        42 => {
            if let Some(tag_kit) = PENTAX_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Pentax",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        53 => {
            if let Some(tag_kit) = PENTAX_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Pentax",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        56 => crate::implementations::value_conv::reciprocal_10_value_conv(value),
        209 => crate::implementations::value_conv::gps_coordinate_value_conv(value),
        235 => crate::implementations::value_conv::gps_coordinate_value_conv(value),
        284 => crate::implementations::value_conv::gpstimestamp_value_conv(value),
        322 => crate::implementations::value_conv::exif_date_value_conv(value),
        515 => {
            if let Some(tag_kit) = PENTAX_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Pentax",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        516 => {
            if let Some(tag_kit) = PENTAX_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Pentax",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        0 => {
            // Compiled arithmetic: 24*exp(-($val-32)*log(2)/8)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    24.0_f64 * ((-val - 32.0_f64 * 2.0_f64.ln()) / 8.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        1 => {
            // Compiled arithmetic: exp(($val-68)*log(2)/16)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    (((val - 68.0_f64) * 2.0_f64.ln()) / 16.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        2 => {
            // Compiled arithmetic: 100*exp(($val-32)*log(2)/8)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    100.0_f64 * (((val - 32.0_f64) * 2.0_f64.ln()) / 8.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        3 => {
            // Compiled arithmetic: ($val-64)/8
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64((val - 64.0_f64) / 8.0_f64)),
                None => Ok(value.clone()),
            }
        }
        4 => {
            // Compiled arithmetic: $val / 8
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 8.0_f64)),
                None => Ok(value.clone()),
            }
        }
        5 => {
            // Compiled arithmetic: 24*exp(-($val-32)*log(2)/8)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    24.0_f64 * ((-val - 32.0_f64 * 2.0_f64.ln()) / 8.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        6 => {
            // Compiled arithmetic: $val / 8
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 8.0_f64)),
                None => Ok(value.clone()),
            }
        }
        7 => {
            // Compiled arithmetic: $val * 2
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val * 2.0_f64)),
                None => Ok(value.clone()),
            }
        }
        8 => {
            // Compiled arithmetic: -($val-64)/8
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(-val - 64.0_f64 / 8.0_f64)),
                None => Ok(value.clone()),
            }
        }
        9 => {
            // Compiled arithmetic: exp(($val-68)*log(2)/16)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    (((val - 68.0_f64) * 2.0_f64.ln()) / 16.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        10 => {
            // Compiled arithmetic: exp(($val-68)*log(2)/16)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    (((val - 68.0_f64) * 2.0_f64.ln()) / 16.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        11 => {
            // Compiled arithmetic: exp(($val-68)*log(2)/16)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    (((val - 68.0_f64) * 2.0_f64.ln()) / 16.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        12 => {
            // Compiled arithmetic: $val / 10
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 10.0_f64)),
                None => Ok(value.clone()),
            }
        }
        14 => {
            // Compiled arithmetic: Image::ExifTool::Pentax::PentaxEv($val)
            match value.as_f64() {
                Some(val) => Ok(crate::implementations::missing::missing_print_conv(
                    0,
                    "Image::ExifTool::Pentax::PentaxEv",
                    "Expression",
                    "Image::ExifTool::Pentax::PentaxEv($val)",
                    &TagValue::F64(val),
                )),
                None => Ok(value.clone()),
            }
        }
        16 => {
            // Compiled arithmetic: exp(($val-68)*log(2)/16)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    (((val - 68.0_f64) * 2.0_f64.ln()) / 16.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        17 => {
            // Compiled arithmetic: exp(($val-68)*log(2)/16)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    (((val - 68.0_f64) * 2.0_f64.ln()) / 16.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        18 => {
            // Compiled arithmetic: exp(($val-68)*log(2)/16)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    (((val - 68.0_f64) * 2.0_f64.ln()) / 16.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        19 => {
            // Compiled arithmetic: 24*exp(-($val-32)*log(2)/8)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    24.0_f64 * ((-val - 32.0_f64 * 2.0_f64.ln()) / 8.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        21 => {
            // Compiled arithmetic: Image::ExifTool::Pentax::PentaxEv(64-$val)
            match value.as_f64() {
                Some(val) => Ok(crate::implementations::missing::missing_print_conv(
                    0,
                    "Image::ExifTool::Pentax::PentaxEv",
                    "Expression",
                    "Image::ExifTool::Pentax::PentaxEv($val)",
                    &TagValue::F64(64.0_f64 - val),
                )),
                None => Ok(value.clone()),
            }
        }
        22 => {
            // Compiled arithmetic: ($val - 50) / 10
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64((val - 50.0_f64) / 10.0_f64)),
                None => Ok(value.clone()),
            }
        }
        27 => {
            // Compiled arithmetic: $val / 256
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 256.0_f64)),
                None => Ok(value.clone()),
            }
        }
        28 => {
            // Compiled arithmetic: exp(($val-68)*log(2)/16)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    (((val - 68.0_f64) * 2.0_f64.ln()) / 16.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        29 => {
            // Compiled arithmetic: exp(($val-68)*log(2)/16)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    (((val - 68.0_f64) * 2.0_f64.ln()) / 16.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        30 => {
            // Compiled arithmetic: exp(($val-68)*log(2)/16)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    (((val - 68.0_f64) * 2.0_f64.ln()) / 16.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        31 => {
            // Compiled arithmetic: 24*exp(-($val-32)*log(2)/8)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(
                    24.0_f64 * ((-val - 32.0_f64 * 2.0_f64.ln()) / 8.0_f64).exp(),
                )),
                None => Ok(value.clone()),
            }
        }
        45 => {
            // Compiled arithmetic: $val/1024
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1024.0_f64)),
                None => Ok(value.clone()),
            }
        }
        60 => {
            // Compiled arithmetic: $val & 0x7ff
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(((val as i64) & (2047.0_f64 as i64)) as f64)),
                None => Ok(value.clone()),
            }
        }
        64 => {
            // Compiled arithmetic: ($val - 50) / 10
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64((val - 50.0_f64) / 10.0_f64)),
                None => Ok(value.clone()),
            }
        }
        77 => {
            // Compiled arithmetic: $val / 256
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 256.0_f64)),
                None => Ok(value.clone()),
            }
        }
        80 => {
            // Compiled arithmetic: 53190 - $val
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(53190.0_f64 - val)),
                None => Ok(value.clone()),
            }
        }
        _ => {
            // Fall back to missing handler for unknown expressions
            if let Some(tag_kit) = PENTAX_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Pentax",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
    }
}

/// Check if a tag has subdirectory processing
pub fn has_subdirectory(tag_id: u32) -> bool {
    if let Some(tag_kit) = PENTAX_PM_TAG_KITS.get(&tag_id) {
        tag_kit.subdirectory.is_some()
    } else {
        false
    }
}

/// Process subdirectory tags and return multiple extracted tags
pub fn process_subdirectory(
    tag_id: u32,
    value: &TagValue,
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<HashMap<String, TagValue>> {
    use tracing::debug;
    let mut result = HashMap::new();

    debug!("process_subdirectory called for tag_id: 0x{:04x}", tag_id);

    if let Some(tag_kit) = PENTAX_PM_TAG_KITS.get(&tag_id) {
        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {
            debug!("Found subdirectory processor for tag_id: 0x{:04x}", tag_id);
            let bytes = match value {
                TagValue::U16Array(arr) => {
                    debug!("Converting U16Array with {} elements to bytes", arr.len());
                    // Convert U16 array to bytes based on byte order
                    let mut bytes = Vec::with_capacity(arr.len() * 2);
                    for val in arr {
                        match byte_order {
                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),
                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),
                        }
                    }
                    bytes
                }
                TagValue::U8Array(arr) => arr.clone(),
                _ => return Ok(result), // Not array data
            };

            debug!("Calling processor with {} bytes", bytes.len());
            // Process subdirectory and collect all extracted tags
            match processor(&bytes, byte_order, model) {
                Ok(extracted_tags) => {
                    debug!("Processor returned {} tags", extracted_tags.len());
                    for (name, value) in extracted_tags {
                        result.insert(name, value);
                    }
                }
                Err(e) => {
                    debug!("Processor error: {:?}", e);
                }
            }
        } else {
            debug!(
                "No subdirectory processor found for tag_id: 0x{:04x}",
                tag_id
            );
        }
    } else {
        debug!("Tag not found in TAG_KITS: 0x{:04x}", tag_id);
    }

    Ok(result)
}
