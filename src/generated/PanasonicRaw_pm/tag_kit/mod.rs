//! Modular tag kits with embedded PrintConv for PanasonicRaw_pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: PanasonicRaw.pm table: Main
//!
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub mod camera;
pub mod core;
pub mod document;
pub mod exif_specific;
pub mod gps;
pub mod interop;
pub mod other;

use crate::expressions::ExpressionEvaluator;
use crate::tiff_types::ByteOrder;
use crate::types::{Result, TagValue};
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
    pub subdirectory: Option<SubDirectoryType>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// Type alias for subdirectory processor function
pub type SubDirectoryProcessor = fn(&[u8], ByteOrder) -> Result<Vec<(String, TagValue)>>;

#[derive(Debug, Clone)]
pub enum SubDirectoryType {
    Binary { processor: SubDirectoryProcessor },
}

/// All tag kits for PanasonicRaw_pm
pub static PANASONICRAW_PM_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    // camera tags
    for (id, tag_def) in camera::get_camera_tags() {
        map.insert(id, tag_def);
    }

    // core tags
    for (id, tag_def) in core::get_core_tags() {
        map.insert(id, tag_def);
    }

    // document tags
    for (id, tag_def) in document::get_document_tags() {
        map.insert(id, tag_def);
    }

    // exif_specific tags
    for (id, tag_def) in exif_specific::get_exif_specific_tags() {
        map.insert(id, tag_def);
    }

    // gps tags
    for (id, tag_def) in gps::get_gps_tags() {
        map.insert(id, tag_def);
    }

    // interop tags
    for (id, tag_def) in interop::get_interop_tags() {
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        map.insert(id, tag_def);
    }

    map
});

// Helper functions for reading binary data
fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16u array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {
    if data.len() < 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s".to_string(),
        ));
    }
    Ok(match byte_order {
        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),
        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),
    })
}

// Subdirectory processing functions
fn process_panasonicraw_wbinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WBType1 at offset 1

    // WBType4 at offset 10

    // WB_RBLevels4 at offset 11
    if data.len() >= 26 {
        if let Ok(values) = read_int16u_array(&data[22..26], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevels4".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType5 at offset 13

    // WB_RBLevels5 at offset 14
    if data.len() >= 32 {
        if let Ok(values) = read_int16u_array(&data[28..32], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevels5".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType6 at offset 16

    // WB_RBLevels6 at offset 17
    if data.len() >= 38 {
        if let Ok(values) = read_int16u_array(&data[34..38], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevels6".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType7 at offset 19

    // WB_RBLevels1 at offset 2
    if data.len() >= 8 {
        if let Ok(values) = read_int16u_array(&data[4..8], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevels1".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RBLevels7 at offset 20
    if data.len() >= 44 {
        if let Ok(values) = read_int16u_array(&data[40..44], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevels7".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType2 at offset 4

    // WB_RBLevels2 at offset 5
    if data.len() >= 14 {
        if let Ok(values) = read_int16u_array(&data[10..14], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevels2".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType3 at offset 7

    // WB_RBLevels3 at offset 8
    if data.len() >= 20 {
        if let Ok(values) = read_int16u_array(&data[16..20], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevels3".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_panasonicraw_wbinfo2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WBType1 at offset 1

    // WB_RGBLevels3 at offset 10
    if data.len() >= 26 {
        if let Ok(values) = read_int16u_array(&data[20..26], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels3".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType4 at offset 13

    // WB_RGBLevels4 at offset 14
    if data.len() >= 34 {
        if let Ok(values) = read_int16u_array(&data[28..34], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels4".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType5 at offset 17

    // WB_RGBLevels5 at offset 18
    if data.len() >= 42 {
        if let Ok(values) = read_int16u_array(&data[36..42], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels5".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGBLevels1 at offset 2
    if data.len() >= 10 {
        if let Ok(values) = read_int16u_array(&data[4..10], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels1".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType6 at offset 21

    // WB_RGBLevels6 at offset 22
    if data.len() >= 50 {
        if let Ok(values) = read_int16u_array(&data[44..50], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels6".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType7 at offset 25

    // WB_RGBLevels7 at offset 26
    if data.len() >= 58 {
        if let Ok(values) = read_int16u_array(&data[52..58], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels7".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType2 at offset 5

    // WB_RGBLevels2 at offset 6
    if data.len() >= 18 {
        if let Ok(values) = read_int16u_array(&data[12..18], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels2".to_string(), TagValue::String(value_str)));
        }
    }

    // WBType3 at offset 9

    Ok(tags)
}

fn process_panasonicraw_distortioninfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // DistortionParam11 at offset 11

    // DistortionN at offset 12

    // DistortionParam02 at offset 2

    // DistortionParam04 at offset 4

    // DistortionScale at offset 5

    // DistortionCorrection at offset 7.1

    // DistortionParam08 at offset 8

    // DistortionParam09 at offset 9

    Ok(tags)
}

pub fn process_tag_0x13_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x13_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x27_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x27_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x2e_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2e_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x119_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x119_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x120_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x120_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x2bc_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2bc_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x83bb_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x83bb_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x8769_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x8769_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x8825_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x8825_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    if let Some(tag_kit) = PANASONICRAW_PM_TAG_KITS.get(&tag_id) {
        // Normal PrintConv processing only
        match &tag_kit.print_conv {
            PrintConvType::None => value.clone(),
            PrintConvType::Simple(lookup) => {
                // Convert value to string key for lookup
                let key = match value {
                    TagValue::U8(v) => v.to_string(),
                    TagValue::U16(v) => v.to_string(),
                    TagValue::U32(v) => v.to_string(),
                    TagValue::I16(v) => v.to_string(),
                    TagValue::I32(v) => v.to_string(),
                    TagValue::String(s) => s.clone(),
                    _ => return value.clone(),
                };

                if let Some(result) = lookup.get(&key) {
                    TagValue::String(result.to_string())
                } else {
                    TagValue::String(format!("Unknown ({})", value))
                }
            }
            PrintConvType::Expression(expr) => {
                // TODO: Implement expression evaluation
                warnings.push(format!(
                    "Expression PrintConv not yet implemented for tag {}: {}",
                    tag_kit.name, expr
                ));
                value.clone()
            }
            PrintConvType::Manual(func_name) => {
                // TODO: Look up in manual registry
                warnings.push(format!(
                    "Manual PrintConv '{}' not found for tag {}",
                    func_name, tag_kit.name
                ));
                value.clone()
            }
        }
    } else {
        // Tag not found in kit
        value.clone()
    }
}

/// Check if a tag has subdirectory processing
pub fn has_subdirectory(tag_id: u32) -> bool {
    if let Some(tag_kit) = PANASONICRAW_PM_TAG_KITS.get(&tag_id) {
        tag_kit.subdirectory.is_some()
    } else {
        false
    }
}

/// Process subdirectory tags and return multiple extracted tags
pub fn process_subdirectory(
    tag_id: u32,
    value: &TagValue,
    byte_order: ByteOrder,
) -> Result<HashMap<String, TagValue>> {
    use tracing::debug;
    let mut result = HashMap::new();

    debug!("process_subdirectory called for tag_id: 0x{:04x}", tag_id);

    if let Some(tag_kit) = PANASONICRAW_PM_TAG_KITS.get(&tag_id) {
        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {
            debug!("Found subdirectory processor for tag_id: 0x{:04x}", tag_id);
            let bytes = match value {
                TagValue::U16Array(arr) => {
                    debug!("Converting U16Array with {} elements to bytes", arr.len());
                    // Convert U16 array to bytes based on byte order
                    let mut bytes = Vec::with_capacity(arr.len() * 2);
                    for val in arr {
                        match byte_order {
                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),
                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),
                        }
                    }
                    bytes
                }
                TagValue::U8Array(arr) => arr.clone(),
                _ => return Ok(result), // Not array data
            };

            debug!("Calling processor with {} bytes", bytes.len());
            // Process subdirectory and collect all extracted tags
            match processor(&bytes, byte_order) {
                Ok(extracted_tags) => {
                    debug!("Processor returned {} tags", extracted_tags.len());
                    for (name, value) in extracted_tags {
                        result.insert(name, value);
                    }
                }
                Err(e) => {
                    debug!("Processor error: {:?}", e);
                }
            }
        } else {
            debug!(
                "No subdirectory processor found for tag_id: 0x{:04x}",
                tag_id
            );
        }
    } else {
        debug!("Tag not found in TAG_KITS: 0x{:04x}", tag_id);
    }

    Ok(result)
}
