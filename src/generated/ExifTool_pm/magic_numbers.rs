//! Generated magic number patterns from ExifTool's magicNumber hash
//!
//! Source: ExifTool.pm %magicNumber
//!
//! This file is auto-generated by codegen/src/strategies/magic_numbers.rs. Do not edit manually.

use regex::bytes::{Regex, RegexBuilder};
use std::collections::HashMap;
use std::sync::LazyLock;

/// Literal magic number patterns as byte slices for fast comparison
/// These patterns can be matched directly without regex compilation
pub static LITERAL_MAGIC_NUMBERS: LazyLock<HashMap<&'static str, &'static [u8]>> =
    LazyLock::new(|| {
        let mut map = HashMap::new();

        map.insert(
            "ALIAS",
            &[98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0][..],
        );
        map.insert(
            "ASF",
            &[
                48, 38, 178, 117, 142, 102, 207, 17, 166, 217, 0, 170, 0, 98, 206, 108,
            ][..],
        );
        map.insert("AVC", &[43, 65, 43, 86, 43, 67, 43][..]);
        map.insert("BMP", &[66, 77][..]);
        map.insert("BPG", &[66, 80, 71, 251][..]);
        map.insert("DCX", &[177, 104, 222, 58][..]);
        map.insert("DEX", &[100, 101, 120, 10, 48, 51, 53, 0][..]);
        map.insert("DOCX", &[80, 75, 3, 4][..]);
        map.insert(
            "DXF",
            &[
                115, 42, 48, 115, 43, 0, 63, 115, 42, 83, 69, 67, 84, 73, 79, 78, 115, 43, 50, 115,
                43, 72, 69, 65, 68, 69, 82,
            ][..],
        );
        map.insert("EXR", &[118, 47, 49, 1][..]);
        map.insert("EXV", &[255, 1, 69, 120, 105, 118, 50][..]);
        map.insert("FLV", &[70, 76, 86, 1][..]);
        map.insert(
            "FPF",
            &[
                70, 80, 70, 32, 80, 117, 98, 108, 105, 99, 32, 73, 109, 97, 103, 101, 32, 70, 111,
                114, 109, 97, 116, 0,
            ][..],
        );
        map.insert("FPX", &[208, 207, 17, 224, 161, 177, 26, 225][..]);
        map.insert("GZIP", &[31, 139, 8][..]);
        map.insert(
            "IND",
            &[
                6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29,
            ][..],
        );
        map.insert("JPEG", &[255, 216, 255][..]);
        map.insert("LFP", &[137, 76, 70, 80, 13, 10, 26, 10][..]);
        map.insert("LRI", &[76, 69, 76, 82, 32, 0][..]);
        map.insert(
            "MIFF",
            &[
                105, 100, 61, 73, 109, 97, 103, 101, 77, 97, 103, 105, 99, 107,
            ][..],
        );
        map.insert("MKV", &[26, 69, 223, 163][..]);
        map.insert("MOI", &[86, 54][..]);
        map.insert("MXF", &[6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2][..]);
        map.insert(
            "MacOS",
            &[
                0, 5, 22, 7, 0, 46, 0, 0, 77, 97, 99, 32, 79, 83, 32, 88, 32, 32, 32, 32, 32, 32,
                32, 32,
            ][..],
        );
        map.insert("NKA", &[78, 73, 75, 79, 78, 65, 68, 74][..]);
        map.insert(
            "PDF",
            &[115, 42, 37, 80, 68, 70, 45, 100, 43, 46, 100, 43][..],
        );
        map.insert("PGF", &[80, 71, 70][..]);
        map.insert("PHP", &[60, 63, 112, 104, 112, 115][..]);
        map.insert("RAF", &[70, 85, 74, 73, 70, 73, 76, 77][..]);
        map.insert("RAR", &[82, 97, 114, 33, 26, 7, 1, 63, 0][..]);
        map.insert("RWZ", &[114, 97, 119, 122, 111, 114][..]);
        map.insert("TNEF", &[120, 159, 62, 34, 46, 46, 1, 6, 144, 8, 0][..]);
        map.insert("Torrent", &[100, 100, 43, 58, 119, 43][..]);
        map.insert(
            "VRD",
            &[
                67, 65, 78, 79, 78, 32, 79, 80, 84, 73, 79, 78, 65, 76, 32, 68, 65, 84, 65, 0,
            ][..],
        );
        map.insert("WPG", &[255, 87, 80, 67][..]);
        map.insert(
            "WTV",
            &[
                183, 216, 0, 32, 55, 73, 218, 17, 166, 78, 0, 7, 233, 94, 173, 141,
            ][..],
        );
        map.insert("X3F", &[70, 79, 86, 98][..]);
        map.insert("XCF", &[103, 105, 109, 112, 32, 120, 99, 102, 32][..]);
        map.insert("XISF", &[88, 73, 83, 70, 48, 49, 48, 48][..]);
        map.insert("ZIP", &[80, 75, 3, 4][..]);

        map
    });

/// Complex regex magic number patterns
/// These patterns require regex compilation and are used as fallback
pub static REGEX_MAGIC_NUMBERS: LazyLock<HashMap<&'static str, Regex>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    // Pattern: .{4}\\x57\\x90\\x75\\x36
    if let Ok(regex) = RegexBuilder::new(r".{4}\x57\x90\x75\x36")
        .unicode(false)
        .build()
    {
        map.insert("AA", regex);
    }

    // Pattern: \\xff[\\xf0\\xf1]
    if let Ok(regex) = RegexBuilder::new(r"\xff[\xf0\xf1]").unicode(false).build() {
        map.insert("AAC", regex);
    }

    // Pattern: (FORM....AIF[FC]|AT&TFORM)
    if let Ok(regex) = RegexBuilder::new(r"(FORM....AIF[FC]|AT&TFORM)")
        .unicode(false)
        .build()
    {
        map.insert("AIFF", regex);
    }

    // Pattern: (MAC |APETAGEX|ID3)
    if let Ok(regex) = RegexBuilder::new(r"(MAC |APETAGEX|ID3)")
        .unicode(false)
        .build()
    {
        map.insert("APE", regex);
    }

    // Pattern: (II\\x2b\\0|MM\\0\\x2b)
    if let Ok(regex) = RegexBuilder::new(r"(II\x2b\0|MM\0\x2b)")
        .unicode(false)
        .build()
    {
        map.insert("BTF", regex);
    }

    // Pattern: BZh[1-9]\\x31\\x41\\x59\\x26\\x53\\x59
    if let Ok(regex) = RegexBuilder::new(r"BZh[1-9]\x31\x41\x59\x26\x53\x59")
        .unicode(false)
        .build()
    {
        map.insert("BZ2", regex);
    }

    // Pattern: ITSF.{20}\\x10\\xfd\\x01\\x7c\\xaa\\x7b\\xd0\\x11\\x9e\\x0c\\0\\xa0\\xc9\\x22\\xe6\\xec
    if let Ok(regex) = RegexBuilder::new(
        r"ITSF.{20}\x10\xfd\x01\x7c\xaa\x7b\xd0\x11\x9e\x0c\0\xa0\xc9\x22\xe6\xec",
    )
    .unicode(false)
    .build()
    {
        map.insert("CHM", regex);
    }

    // Pattern: (II|MM).{4}HEAP(CCDR|JPGM)
    if let Ok(regex) = RegexBuilder::new(r"(II|MM).{4}HEAP(CCDR|JPGM)")
        .unicode(false)
        .build()
    {
        map.insert("CRW", regex);
    }

    // Pattern: ZISRAWFILE\\0{6}
    if let Ok(regex) = RegexBuilder::new(r"ZISRAWFILE\0{6}").unicode(false).build() {
        map.insert("CZI", regex);
    }

    // Pattern: (.{128}DICM|\\0[\\x02\\x04\\x06\\x08]\\0[\\0-\\x20]|[\\x02\\x04\\x06\\x08]\\0[\\0-\\x20]\\0)
    if let Ok(regex) = RegexBuilder::new(
        r"(.{128}DICM|\0[\x02\x04\x06\x08]\0[\0-\x20]|[\x02\x04\x06\x08]\0[\0-\x20]\0)",
    )
    .unicode(false)
    .build()
    {
        map.insert("DICOM", regex);
    }

    // Pattern: (SDPX|XPDS)
    if let Ok(regex) = RegexBuilder::new(r"(SDPX|XPDS)").unicode(false).build() {
        map.insert("DPX", regex);
    }

    // Pattern: IIII[\\x04|\\x05]\\0\\x04\\0
    if let Ok(regex) = RegexBuilder::new(r"IIII[\x04|\x05]\0\x04\0")
        .unicode(false)
        .build()
    {
        map.insert("DR4", regex);
    }

    // Pattern: DSD \\x1c\\0{7}.{16}fmt
    if let Ok(regex) = RegexBuilder::new(r"DSD \x1c\0{7}.{16}fmt ")
        .unicode(false)
        .build()
    {
        map.insert("DSF", regex);
    }

    // Pattern: (\\x02dss|\\x03ds2)
    if let Ok(regex) = RegexBuilder::new(r"(\x02dss|\x03ds2)")
        .unicode(false)
        .build()
    {
        map.insert("DSS", regex);
    }

    // Pattern: \\x1f\\x07\\0[\\x3f\\xbf]
    if let Ok(regex) = RegexBuilder::new(r"\x1f\x07\0[\x3f\xbf]")
        .unicode(false)
        .build()
    {
        map.insert("DV", regex);
    }

    // Pattern: \\(DWF V\\d
    if let Ok(regex) = RegexBuilder::new(r"\(DWF V\d").unicode(false).build() {
        map.insert("DWF", regex);
    }

    // Pattern: AC10\\d{2}\\0
    if let Ok(regex) = RegexBuilder::new(r"AC10\d{2}\0").unicode(false).build() {
        map.insert("DWG", regex);
    }

    // Pattern: (%!PS|%!Ad|\\xc5\\xd0\\xd3\\xc6)
    if let Ok(regex) = RegexBuilder::new(r"(%!PS|%!Ad|\xc5\xd0\xd3\xc6)")
        .unicode(false)
        .build()
    {
        map.insert("EPS", regex);
    }

    // Pattern: (MZ|\\xca\\xfe\\xba\\xbe|\\xfe\\xed\\xfa[\\xce\\xcf]|[\\xce\\xcf]\\xfa\\xed\\xfe|Joy!peff|\\x7fELF|#!\\s*/\\S*bin/|!<arch>\\x0a)
    if let Ok(regex) = RegexBuilder::new(r"(MZ|\xca\xfe\xba\xbe|\xfe\xed\xfa[\xce\xcf]|[\xce\xcf]\xfa\xed\xfe|Joy!peff|\x7fELF|#!\s*/\S*bin/|!<arch>\x0a)")
        .unicode(false)
        .build() {
        map.insert("EXE", regex);
    }

    // Pattern: (II\\x2a\\0|MM\\0\\x2a)
    if let Ok(regex) = RegexBuilder::new(r"(II\x2a\0|MM\0\x2a)")
        .unicode(false)
        .build()
    {
        map.insert("EXIF", regex);
    }

    // Pattern: SIMPLE  = {20}T
    if let Ok(regex) = RegexBuilder::new(r"SIMPLE  = {20}T").unicode(false).build() {
        map.insert("FITS", regex);
    }

    // Pattern: (fLaC|ID3)
    if let Ok(regex) = RegexBuilder::new(r"(fLaC|ID3)").unicode(false).build() {
        map.insert("FLAC", regex);
    }

    // Pattern: FLIF[0-\\x6f][0-2]
    if let Ok(regex) = RegexBuilder::new(r"FLIF[0-\x6f][0-2]")
        .unicode(false)
        .build()
    {
        map.insert("FLIF", regex);
    }

    // Pattern: [AF]FF\\0
    if let Ok(regex) = RegexBuilder::new(r"[AF]FF\0").unicode(false).build() {
        map.insert("FLIR", regex);
    }

    // Pattern: ((\\0\\x01\\0\\0|OTTO|true|typ1)[\\0\\x01]|ttcf\\0[\\x01\\x02]\\0\\0|\\0[\\x01\\x02]|(.{6})?%!(PS-(AdobeFont-|Bitstream )|FontType1-)|Start(Comp|Master)?FontMetrics|wOF[F2])
    if let Ok(regex) = RegexBuilder::new(r"((\0\x01\0\0|OTTO|true|typ1)[\0\x01]|ttcf\0[\x01\x02]\0\0|\0[\x01\x02]|(.{6})?%!(PS-(AdobeFont-|Bitstream )|FontType1-)|Start(Comp|Master)?FontMetrics|wOF[F2])")
        .unicode(false)
        .build() {
        map.insert("Font", regex);
    }

    // Pattern: GIF8[79]a
    if let Ok(regex) = RegexBuilder::new(r"GIF8[79]a").unicode(false).build() {
        map.insert("GIF", regex);
    }

    // Pattern: #\\?(RADIANCE|RGBE)\\x0a
    if let Ok(regex) = RegexBuilder::new(r"#\?(RADIANCE|RGBE)\x0a")
        .unicode(false)
        .build()
    {
        map.insert("HDR", regex);
    }

    // Pattern: (\\xef\\xbb\\xbf)?\\s*(?i)<(!DOCTYPE\\s+HTML|HTML|\\?xml)
    if let Ok(regex) = RegexBuilder::new(r"(\xef\xbb\xbf)?\s*(?i)<(!DOCTYPE\s+HTML|HTML|\?xml)")
        .unicode(false)
        .build()
    {
        map.insert("HTML", regex);
    }

    // Pattern: .{12}(scnr|mntr|prtr|link|spac|abst|nmcl|nkpf|cenc|mid |mlnk|mvis)(XYZ |Lab |Luv |YCbr|Yxy |RGB |GRAY|HSV |HLS |CMYK|CMY |[2-9A-F]CLR|nc..|\\0{4}){2}
    if let Ok(regex) = RegexBuilder::new(r".{12}(scnr|mntr|prtr|link|spac|abst|nmcl|nkpf|cenc|mid |mlnk|mvis)(XYZ |Lab |Luv |YCbr|Yxy |RGB |GRAY|HSV |HLS |CMYK|CMY |[2-9A-F]CLR|nc..|\0{4}){2}")
        .unicode(false)
        .build() {
        map.insert("ICC", regex);
    }

    // Pattern: \\0\\0[\\x01\\x02]\\0[^0]\\0
    if let Ok(regex) = RegexBuilder::new(r"\0\0[\x01\x02]\0[^0]\0")
        .unicode(false)
        .build()
    {
        map.insert("ICO", regex);
    }

    // Pattern: .{4}itch
    if let Ok(regex) = RegexBuilder::new(r".{4}itch").unicode(false).build() {
        map.insert("ITC", regex);
    }

    // Pattern: (\\0\\0\\0\\x0cjP(  |\\x1a\\x1a)\\x0d\\x0a\\x87\\x0a|\\xff\\x4f\\xff\\x51\\0)
    if let Ok(regex) =
        RegexBuilder::new(r"(\0\0\0\x0cjP(  |\x1a\x1a)\x0d\x0a\x87\x0a|\xff\x4f\xff\x51\0)")
            .unicode(false)
            .build()
    {
        map.insert("JP2", regex);
    }

    // Pattern: (\\xef\\xbb\\xbf)?\\s*(\\[\\s*)?\\{\\s*\"[^\"]*\"\\s*:
    if let Ok(regex) = RegexBuilder::new(r#"(\\xef\\xbb\\xbf)?\\s*(\\[\\s*)?\\{\\s*"[^"]*"\\s*:"#)
        .unicode(false)
        .build()
    {
        map.insert("JSON", regex);
    }

    // Pattern: .{4}jumb\\0.{3}jumd
    if let Ok(regex) = RegexBuilder::new(r".{4}jumb\0.{3}jumd")
        .unicode(false)
        .build()
    {
        map.insert("JUMBF", regex);
    }

    // Pattern: (\\xff\\x0a|\\0\\0\\0\\x0cJXL \\x0d\\x0a......ftypjxl )
    if let Ok(regex) = RegexBuilder::new(r"(\xff\x0a|\0\0\0\x0cJXL \x0d\x0a......ftypjxl )")
        .unicode(false)
        .build()
    {
        map.insert("JXL", regex);
    }

    // Pattern: \\x70\\0{3}.{4}\\x2a.{4}<\\0
    if let Ok(regex) = RegexBuilder::new(r"\x70\0{3}.{4}\x2a.{4}<\0")
        .unicode(false)
        .build()
    {
        map.insert("LIF", regex);
    }

    // Pattern: .{4}\\x01\\x14\\x02\\0{5}\\xc0\\0{6}\\x46
    if let Ok(regex) = RegexBuilder::new(r".{4}\x01\x14\x02\0{5}\xc0\0{6}\x46")
        .unicode(false)
        .build()
    {
        map.insert("LNK", regex);
    }

    // Pattern: .{0,191}?\\x47(.{187}|.{191})\\x47(.{187}|.{191})\\x47
    if let Ok(regex) = RegexBuilder::new(r".{0,191}?\x47(.{187}|.{191})\x47(.{187}|.{191})\x47")
        .unicode(false)
        .build()
    {
        map.insert("M2TS", regex);
    }

    // Pattern: ~[\\x10\\x18]\\x04.0MIE
    if let Ok(regex) = RegexBuilder::new(r"~[\x10\x18]\x04.0MIE")
        .unicode(false)
        .build()
    {
        map.insert("MIE", regex);
    }

    // Pattern: .{4}(free|skip|wide|ftyp|pnot|PICT|pict|moov|mdat|junk|uuid)
    if let Ok(regex) =
        RegexBuilder::new(r".{4}(free|skip|wide|ftyp|pnot|PICT|pict|moov|mdat|junk|uuid)")
            .unicode(false)
            .build()
    {
        map.insert("MOV", regex);
    }

    // Pattern: (MP\\+|ID3)
    if let Ok(regex) = RegexBuilder::new(r"(MP\+|ID3)").unicode(false).build() {
        map.insert("MPC", regex);
    }

    // Pattern: \\0\\0\\x01[\\xb0-\\xbf]
    if let Ok(regex) = RegexBuilder::new(r"\0\0\x01[\xb0-\xbf]")
        .unicode(false)
        .build()
    {
        map.insert("MPEG", regex);
    }

    // Pattern: .{64}[\\x01\\x02\\x03]\\0\\0\\0[\\x01\\x02\\x03]\\0\\0\\0[\\x01\\x02\\x03]\\0\\0\\0.{132}MAP[\\0 ](\\x44\\x44|\\x44\\x41|\\x11\\x11)\\0\\0
    if let Ok(regex) = RegexBuilder::new(r".{64}[\x01\x02\x03]\0\0\0[\x01\x02\x03]\0\0\0[\x01\x02\x03]\0\0\0.{132}MAP[\0 ](\x44\x44|\x44\x41|\x11\x11)\0\0")
        .unicode(false)
        .build() {
        map.insert("MRC", regex);
    }

    // Pattern: \\0MR[MI]
    if let Ok(regex) = RegexBuilder::new(r"\0MR[MI]").unicode(false).build() {
        map.insert("MRW", regex);
    }

    // Pattern: (OggS|ID3)
    if let Ok(regex) = RegexBuilder::new(r"(OggS|ID3)").unicode(false).build() {
        map.insert("OGG", regex);
    }

    // Pattern: (II|MM)
    if let Ok(regex) = RegexBuilder::new(r"(II|MM)").unicode(false).build() {
        map.insert("ORF", regex);
    }

    // Pattern: \\xa1\\xb2(\\xc3\\xd4|\\x3c\\x4d)\\0.\\0.|(\\xd4\\xc3|\\x4d\\x3c)\\xb2\\xa1.\\0.\\0|\\x0a\\x0d\\x0d\\x0a.{4}(\\x1a\\x2b\\x3c\\x4d|\\x4d\\x3c\\x2b\\x1a)|GMBU\\0\\x02
    if let Ok(regex) = RegexBuilder::new(r"\xa1\xb2(\xc3\xd4|\x3c\x4d)\0.\0.|(\xd4\xc3|\x4d\x3c)\xb2\xa1.\0.\0|\x0a\x0d\x0d\x0a.{4}(\x1a\x2b\x3c\x4d|\x4d\x3c\x2b\x1a)|GMBU\0\x02")
        .unicode(false)
        .build() {
        map.insert("PCAP", regex);
    }

    // Pattern: \\x0a[\\0-\\x05]\\x01[\\x01\\x02\\x04\\x08].{64}[\\0-\\x02]
    if let Ok(regex) = RegexBuilder::new(r"\x0a[\0-\x05]\x01[\x01\x02\x04\x08].{64}[\0-\x02]")
        .unicode(false)
        .build()
    {
        map.insert("PCX", regex);
    }

    // Pattern: .{60}(\\.pdfADBE|TEXtREAd|BVokBDIC|DB99DBOS|PNRdPPrs|DataPPrs|vIMGView|PmDBPmDB|InfoINDB|ToGoToGo|SDocSilX|JbDbJBas|JfDbJFil|DATALSdb|Mdb1Mdb1|BOOKMOBI|DataPlkr|DataSprd|SM01SMem|TEXtTlDc|InfoTlIf|DataTlMl|DataTlPt|dataTDBP|TdatTide|ToRaTRPW|zTXTGPlm|BDOCWrdS)
    if let Ok(regex) = RegexBuilder::new(r".{60}(\.pdfADBE|TEXtREAd|BVokBDIC|DB99DBOS|PNRdPPrs|DataPPrs|vIMGView|PmDBPmDB|InfoINDB|ToGoToGo|SDocSilX|JbDbJBas|JfDbJFil|DATALSdb|Mdb1Mdb1|BOOKMOBI|DataPlkr|DataSprd|SM01SMem|TEXtTlDc|InfoTlIf|DataTlMl|DataTlPt|dataTDBP|TdatTide|ToRaTRPW|zTXTGPlm|BDOCWrdS)")
        .unicode(false)
        .build() {
        map.insert("PDB", regex);
    }

    // Pattern: P[Ff]\\x0a\\d+ \\d+\\x0a[-+0-9.]+\\x0a
    if let Ok(regex) = RegexBuilder::new(r"P[Ff]\x0a\d+ \d+\x0a[-+0-9.]+\x0a")
        .unicode(false)
        .build()
    {
        map.insert("PFM", regex);
    }

    // Pattern: (.{10}|.{522})(\\x11\\x01|\\x00\\x11)
    if let Ok(regex) = RegexBuilder::new(r"(.{10}|.{522})(\x11\x01|\x00\x11)")
        .unicode(false)
        .build()
    {
        map.insert("PICT", regex);
    }

    // Pattern: (bplist0|\\s*<|\\xfe\\xff\\x00)
    if let Ok(regex) = RegexBuilder::new(r"(bplist0|\s*<|\xfe\xff\x00)")
        .unicode(false)
        .build()
    {
        map.insert("PLIST", regex);
    }

    // Pattern: .{8}\\0{3}\\x7c.{112}\\xff\\xd8\\xff\\xdb
    if let Ok(regex) = RegexBuilder::new(r".{8}\0{3}\x7c.{112}\xff\xd8\xff\xdb")
        .unicode(false)
        .build()
    {
        map.insert("PMP", regex);
    }

    // Pattern: (\\x89P|\\x8aM|\\x8bJ)NG\\r\\n\\x1a\\n
    if let Ok(regex) = RegexBuilder::new(r"(\x89P|\x8aM|\x8bJ)NG\r\n\x1a\n")
        .unicode(false)
        .build()
    {
        map.insert("PNG", regex);
    }

    // Pattern: P[1-6]\\s+
    if let Ok(regex) = RegexBuilder::new(r"P[1-6]\s+").unicode(false).build() {
        map.insert("PPM", regex);
    }

    // Pattern: (%!PS|%!Ad|\\xc5\\xd0\\xd3\\xc6)
    if let Ok(regex) = RegexBuilder::new(r"(%!PS|%!Ad|\xc5\xd0\xd3\xc6)")
        .unicode(false)
        .build()
    {
        map.insert("PS", regex);
    }

    // Pattern: 8BPS\\0[\\x01\\x02]
    if let Ok(regex) = RegexBuilder::new(r"8BPS\0[\x01\x02]")
        .unicode(false)
        .build()
    {
        map.insert("PSD", regex);
    }

    // Pattern: Paint Shop Pro Image File\\x0a\\x1a\\0{5}
    if let Ok(regex) = RegexBuilder::new(r"Paint Shop Pro Image File\x0a\x1a\0{5}")
        .unicode(false)
        .build()
    {
        map.insert("PSP", regex);
    }

    // Pattern: .{4}(idsc|idat|iicc)
    if let Ok(regex) = RegexBuilder::new(r".{4}(idsc|idat|iicc)")
        .unicode(false)
        .build()
    {
        map.insert("QTIF", regex);
    }

    // Pattern: \\0\\0..RED(1|2)
    if let Ok(regex) = RegexBuilder::new(r"\0\0..RED(1|2)").unicode(false).build() {
        map.insert("R3D", regex);
    }

    // Pattern: (.{25}ARECOYK|II|MM)
    if let Ok(regex) = RegexBuilder::new(r"(.{25}ARECOYK|II|MM)")
        .unicode(false)
        .build()
    {
        map.insert("RAW", regex);
    }

    // Pattern: (RIFF|LA0[234]|OFR |LPAC|wvpk|RF64)
    if let Ok(regex) = RegexBuilder::new(r"(RIFF|LA0[234]|OFR |LPAC|wvpk|RF64)")
        .unicode(false)
        .build()
    {
        map.insert("RIFF", regex);
    }

    // Pattern: (....)?\\0\\0\\x01\\0
    if let Ok(regex) = RegexBuilder::new(r"(....)?\0\0\x01\0")
        .unicode(false)
        .build()
    {
        map.insert("RSRC", regex);
    }

    // Pattern: [\\n\\r]*\\{[\\n\\r]*\\\\rtf
    if let Ok(regex) = RegexBuilder::new(r"[\n\r]*\{[\n\r]*\\rtf")
        .unicode(false)
        .build()
    {
        map.insert("RTF", regex);
    }

    // Pattern: (\\.RMF|\\.ra\\xfd|pnm://|rtsp://|http://)
    if let Ok(regex) = RegexBuilder::new(r"(\.RMF|\.ra\xfd|pnm://|rtsp://|http://)")
        .unicode(false)
        .build()
    {
        map.insert("Real", regex);
    }

    // Pattern: [FC]WS[^\\0]
    if let Ok(regex) = RegexBuilder::new(r"[FC]WS[^\0]").unicode(false).build() {
        map.insert("SWF", regex);
    }

    // Pattern: .{257}ustar(  )?\\0
    if let Ok(regex) = RegexBuilder::new(r".{257}ustar(  )?\0")
        .unicode(false)
        .build()
    {
        map.insert("TAR", regex);
    }

    // Pattern: (II|MM)
    if let Ok(regex) = RegexBuilder::new(r"(II|MM)").unicode(false).build() {
        map.insert("TIFF", regex);
    }

    // Pattern: (\\xff\\xfe|(\\0\\0)?\\xfe\\xff|(\\xef\\xbb\\xbf)?[\\x07-\\x0d\\x20-\\x7e\\x80-\\xfe]*$)
    if let Ok(regex) = RegexBuilder::new(
        r"(\xff\xfe|(\0\0)?\xfe\xff|(\xef\xbb\xbf)?[\x07-\x0d\x20-\x7e\x80-\xfe]*$)",
    )
    .unicode(false)
    .build()
    {
        map.insert("TXT", regex);
    }

    // Pattern: (?i)BEGIN:(VCARD|VCALENDAR|VNOTE)\\r\\n
    if let Ok(regex) = RegexBuilder::new(r"(?i)BEGIN:(VCARD|VCALENDAR|VNOTE)\r\n")
        .unicode(false)
        .build()
    {
        map.insert("VCard", regex);
    }

    // Pattern: (\\xd7\\xcd\\xc6\\x9a\\0\\0|\\x01\\0\\x09\\0\\0\\x03)
    if let Ok(regex) = RegexBuilder::new(r"(\xd7\xcd\xc6\x9a\0\0|\x01\0\x09\0\0\x03)")
        .unicode(false)
        .build()
    {
        map.insert("WMF", regex);
    }

    // Pattern: \\0{0,3}(\\xfe\\xff|\\xff\\xfe|\\xef\\xbb\\xbf)?\\0{0,3}\\s*<
    if let Ok(regex) = RegexBuilder::new(r"\0{0,3}(\xfe\xff|\xff\xfe|\xef\xbb\xbf)?\0{0,3}\s*<")
        .unicode(false)
        .build()
    {
        map.insert("XMP", regex);
    }

    map
});
