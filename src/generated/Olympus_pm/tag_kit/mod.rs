//! Modular tag kits with embedded PrintConv for Olympus_pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: Olympus.pm table: AFInfo
//!
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub mod camera;
pub mod color;
pub mod core;
pub mod datetime;
pub mod document;
pub mod interop;
pub mod other;
pub mod thumbnail;

use crate::expressions::ExpressionEvaluator;
use crate::tiff_types::ByteOrder;
use crate::types::{Result, TagValue};
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
    pub subdirectory: Option<SubDirectoryType>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// Type alias for subdirectory processor function
pub type SubDirectoryProcessor =
    fn(&[u8], ByteOrder, Option<&str>) -> Result<Vec<(String, TagValue)>>;

#[derive(Debug, Clone)]
pub enum SubDirectoryType {
    Binary { processor: SubDirectoryProcessor },
}

/// All tag kits for Olympus_pm
pub static OLYMPUS_PM_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map: HashMap<u32, TagKitDef> = HashMap::new();

    // camera tags
    for (id, tag_def) in camera::get_camera_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // color tags
    for (id, tag_def) in color::get_color_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // core tags
    for (id, tag_def) in core::get_core_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // datetime tags
    for (id, tag_def) in datetime::get_datetime_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // document tags
    for (id, tag_def) in document::get_document_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // interop tags
    for (id, tag_def) in interop::get_interop_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // thumbnail tags
    for (id, tag_def) in thumbnail::get_thumbnail_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    map
});

// Helper functions for reading binary data
fn model_matches(model: &str, pattern: &str) -> bool {
    // ExifTool regexes are already in a compatible format
    // Just need to ensure proper escaping was preserved

    match regex::Regex::new(pattern) {
        Ok(re) => re.is_match(model),
        Err(e) => {
            tracing::warn!("Failed to compile model regex '{}': {}", pattern, e);
            false
        }
    }
}

fn format_matches(format: &str, pattern: &str) -> bool {
    if let Ok(re) = regex::Regex::new(pattern) {
        re.is_match(format)
    } else {
        tracing::warn!("Failed to compile format regex: {}", pattern);
        false
    }
}

fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16u array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {
    if data.len() < 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s".to_string(),
        ));
    }
    Ok(match byte_order {
        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),
        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),
    })
}

// Subdirectory processing functions
fn process_olympus_prms(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // DateTime1 at offset 131
    if data.len() >= 310 {
        // TODO: Handle format string
    }

    // DateTime2 at offset 157
    if data.len() >= 362 {
        // TODO: Handle format string
    }

    // Make at offset 18
    if data.len() >= 84 {
        // TODO: Handle format string
    }

    // LensModel at offset 383
    if data.len() >= 830 {
        // TODO: Handle format string
    }

    // Model at offset 44
    if data.len() >= 136 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_olympus_scrn2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // OlympusPreview at offset 2

    Ok(tags)
}

fn process_olympus_thmb2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ThumbnailWidth at offset 0
    if data.len() >= 2 {
        // TODO: Handle format int16u
    }

    // ThumbnailHeight at offset 2
    if data.len() >= 6 {
        // TODO: Handle format int16u
    }

    // ThumbnailLength at offset 4
    if data.len() >= 12 {
        // TODO: Handle format int32u
    }

    // ThumbnailImage at offset 8

    Ok(tags)
}

fn process_olympus_scrn(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PreviewImageLength at offset 0
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // PreviewImage at offset 4

    Ok(tags)
}

fn process_olympus_movableinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Thumbnail at offset 131

    // ISO at offset 4
    if data.len() >= 12 {
        // TODO: Handle format int32u
    }

    // EncoderVersion at offset 44
    if data.len() >= 120 {
        // TODO: Handle format string
    }

    // DecoderVersion at offset 60
    if data.len() >= 152 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_olympus_thumbnail(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ThumbnailOffset at offset 4

    Ok(tags)
}

fn process_olympus_textinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TagResolution at offset Resolution

    // CameraType at offset Type

    Ok(tags)
}

fn process_olympus_aftargetinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFFrameSize at offset 0
    if data.len() >= 4 {
        if let Ok(values) = read_int16u_array(&data[0..4], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("AFFrameSize".to_string(), TagValue::String(value_str)));
        }
    }

    // AFFocusArea at offset 2
    if data.len() >= 12 {
        if let Ok(values) = read_int16u_array(&data[4..12], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("AFFocusArea".to_string(), TagValue::String(value_str)));
        }
    }

    // AFSelectedArea at offset 6
    if data.len() >= 20 {
        if let Ok(values) = read_int16u_array(&data[12..20], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("AFSelectedArea".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_olympus_subjectdetectinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SubjectDetectFrameSize at offset 0
    if data.len() >= 4 {
        if let Ok(values) = read_int16u_array(&data[0..4], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "SubjectDetectFrameSize".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // SubjectDetectStatus at offset 10

    // SubjectDetectArea at offset 2
    if data.len() >= 12 {
        if let Ok(values) = read_int16u_array(&data[4..12], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("SubjectDetectArea".to_string(), TagValue::String(value_str)));
        }
    }

    // SubjectDetectDetail at offset 6
    if data.len() >= 20 {
        if let Ok(values) = read_int16u_array(&data[12..20], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "SubjectDetectDetail".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_olympus_afinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CAFSensitivity at offset 1580
    if data.len() >= 3161 {
        // TODO: Handle format int8s
    }

    Ok(tags)
}

// Functions for tables not extracted by tag kit
fn process_olympus_camerasettings(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_olympus_equipment(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_olympus_fetags(data: &[u8], _byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_olympus_focusinfo(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_olympus_imageprocessing(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_olympus_main(data: &[u8], _byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_olympus_rawdevelopment(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_olympus_rawdevelopment2(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_olympus_rawdevsubifd(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_olympus_rawinfo(data: &[u8], _byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_olympus_unknowninfo(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

pub fn process_tag_0x0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x1_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x1_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::Minolta::CameraSettings
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x2_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_olympus_scrn(data, byte_order)
}

pub fn process_tag_0x3_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x3_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::Minolta::CameraSettings
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x68_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x68_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $$valPt =~ /^DIGI/
    // Would dispatch to: Image::ExifTool::Olympus::MovableInfo
    Ok(vec![])
}

pub fn process_tag_0x72_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x72_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $$valPt =~ /^DIGI/
    // Would dispatch to: Image::ExifTool::Olympus::MovableInfo
    Ok(vec![])
}

pub fn process_tag_0x83_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x83_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_olympus_thumbnail(data, byte_order)
}

pub fn process_tag_0x129_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x129_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_olympus_thmb2(data, byte_order)
}

pub fn process_tag_0x208_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x208_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_olympus_textinfo(data, byte_order)
}

pub fn process_tag_0x30a_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x30a_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_olympus_aftargetinfo(data, byte_order)
}

pub fn process_tag_0x30b_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x30b_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_olympus_subjectdetectinfo(data, byte_order)
}

pub fn process_tag_0x328_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x328_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_olympus_afinfo(data, byte_order)
}

pub fn process_tag_0xe00_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe00_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::PrintIM::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x2010_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2010_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::Equipment
    Ok(vec![])
}

pub fn process_tag_0x2020_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2020_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::CameraSettings
    Ok(vec![])
}

pub fn process_tag_0x2030_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2030_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::RawDevelopment
    Ok(vec![])
}

pub fn process_tag_0x2031_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2031_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::RawDevelopment2
    Ok(vec![])
}

pub fn process_tag_0x2040_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2040_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::ImageProcessing
    Ok(vec![])
}

pub fn process_tag_0x2050_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2050_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\" and not $$self{OlympusCAMER}
    // Would dispatch to: Image::ExifTool::Olympus::FocusInfo
    // Runtime condition not yet supported: not $$self{OlympusCAMER}
    // Would dispatch to: Image::ExifTool::Olympus::FocusInfo
    Ok(vec![])
}

pub fn process_tag_0x2100_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2100_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::FETags
    Ok(vec![])
}

pub fn process_tag_0x2200_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2200_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::FETags
    Ok(vec![])
}

pub fn process_tag_0x2300_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2300_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::FETags
    Ok(vec![])
}

pub fn process_tag_0x2400_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2400_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::FETags
    Ok(vec![])
}

pub fn process_tag_0x2500_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2500_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::FETags
    Ok(vec![])
}

pub fn process_tag_0x2600_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2600_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::FETags
    Ok(vec![])
}

pub fn process_tag_0x2700_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2700_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::FETags
    Ok(vec![])
}

pub fn process_tag_0x2800_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2800_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::FETags
    Ok(vec![])
}

pub fn process_tag_0x2900_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2900_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::FETags
    Ok(vec![])
}

pub fn process_tag_0x3000_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x3000_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::RawInfo
    Ok(vec![])
}

pub fn process_tag_0x4000_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4000_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::Main
    Ok(vec![])
}

pub fn process_tag_0x5000_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x5000_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Format condition not yet supported: $format ne \"ifd\" and $format ne \"int32u\"
    // Would dispatch to: Image::ExifTool::Olympus::UnknownInfo
    Ok(vec![])
}

pub fn process_tag_0x8000_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x8000_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_olympus_rawdevsubifd(data, byte_order)
}

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    match tag_id {
        38 => crate::implementations::print_conv::exposuretime_print_conv(value),
        40 => crate::implementations::print_conv::fnumber_print_conv(value),
        42 => crate::implementations::print_conv::fnumber_print_conv(value),
        48 => crate::implementations::print_conv::print_fraction(value),
        50 => crate::implementations::print_conv::print_fraction(value),
        54 => crate::implementations::print_conv::exposuretime_print_conv(value),
        58 => crate::implementations::print_conv::fnumber_print_conv(value),
        66 => crate::implementations::print_conv::print_fraction(value),
        90 => crate::implementations::print_conv::fnumber_print_conv(value),
        94 => crate::implementations::print_conv::fnumber_print_conv(value),
        4096 => crate::implementations::print_conv::exposuretime_print_conv(value),
        _ => {
            // Fall back to shared handling
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                crate::implementations::generic::apply_fallback_print_conv(
                    tag_id,
                    &tag_kit.name,
                    "Olympus",
                    value,
                    crate::to_print_conv_ref!(&tag_kit.print_conv),
                )
            } else {
                value.clone()
            }
        }
    }
}

/// Apply ValueConv for a tag from this module
pub fn apply_value_conv(
    tag_id: u32,
    value: &TagValue,
    _errors: &mut Vec<String>,
) -> Result<TagValue> {
    match tag_id {
        0 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        38 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        54 => crate::implementations::value_conv::reciprocal_10_value_conv(value),
        62 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        513 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        517 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        518 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        519 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        522 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        769 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        773 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        795 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        2305 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        2307 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        2308 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        4096 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        4098 => crate::implementations::value_conv::apex_aperture_value_conv(value),
        4119 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        4120 => {
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        512 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        532 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        542 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        552 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        562 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        572 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        582 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        592 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        602 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        612 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        622 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        632 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        642 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        652 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        662 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        672 => {
            // Compiled arithmetic: $val / 1000
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 1000.0_f64)),
                None => Ok(value.clone()),
            }
        }
        776 => {
            // Compiled arithmetic: ($val & 0x1f) . " " . ($val & 0xffe0)
            match value.as_f64() {
                Some(val) => Ok(TagValue::String(format!(
                    "{} {}",
                    ((val as i64) & (31.0_f64 as i64)) as f64,
                    ((val as i64) & (65504.0_f64 as i64)) as f64
                ))),
                None => Ok(value.clone()),
            }
        }
        2304 => {
            // Compiled arithmetic: $val / 10
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(val / 10.0_f64)),
                None => Ok(value.clone()),
            }
        }
        4097 => {
            // Compiled arithmetic: 100 * 2 ** ($val - 5)
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(100.0_f64 * 2.0_f64.powf(val - 5.0_f64))),
                None => Ok(value.clone()),
            }
        }
        4870 => {
            // Compiled arithmetic: $val ? $val : undef
            match value.as_f64() {
                Some(val) => Ok(if val != 0.0 {
                    TagValue::F64(val)
                } else {
                    value.clone()
                }),
                None => Ok(value.clone()),
            }
        }
        5376 => {
            // Compiled arithmetic: 84 - 3 * $val / 26
            match value.as_f64() {
                Some(val) => Ok(TagValue::F64(84.0_f64 - ((3.0_f64 * val) / 26.0_f64))),
                None => Ok(value.clone()),
            }
        }
        _ => {
            // Fall back to missing handler for unknown expressions
            if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Olympus",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
    }
}

/// Check if a tag has subdirectory processing
pub fn has_subdirectory(tag_id: u32) -> bool {
    if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
        tag_kit.subdirectory.is_some()
    } else {
        false
    }
}

/// Process subdirectory tags and return multiple extracted tags
pub fn process_subdirectory(
    tag_id: u32,
    value: &TagValue,
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<HashMap<String, TagValue>> {
    use tracing::debug;
    let mut result = HashMap::new();

    debug!("process_subdirectory called for tag_id: 0x{:04x}", tag_id);

    if let Some(tag_kit) = OLYMPUS_PM_TAG_KITS.get(&tag_id) {
        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {
            debug!("Found subdirectory processor for tag_id: 0x{:04x}", tag_id);
            let bytes = match value {
                TagValue::U16Array(arr) => {
                    debug!("Converting U16Array with {} elements to bytes", arr.len());
                    // Convert U16 array to bytes based on byte order
                    let mut bytes = Vec::with_capacity(arr.len() * 2);
                    for val in arr {
                        match byte_order {
                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),
                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),
                        }
                    }
                    bytes
                }
                TagValue::U8Array(arr) => arr.clone(),
                _ => return Ok(result), // Not array data
            };

            debug!("Calling processor with {} bytes", bytes.len());
            // Process subdirectory and collect all extracted tags
            match processor(&bytes, byte_order, model) {
                Ok(extracted_tags) => {
                    debug!("Processor returned {} tags", extracted_tags.len());
                    for (name, value) in extracted_tags {
                        result.insert(name, value);
                    }
                }
                Err(e) => {
                    debug!("Processor error: {:?}", e);
                }
            }
        } else {
            debug!(
                "No subdirectory processor found for tag_id: 0x{:04x}",
                tag_id
            );
        }
    } else {
        debug!("Tag not found in TAG_KITS: 0x{:04x}", tag_id);
    }

    Ok(result)
}
