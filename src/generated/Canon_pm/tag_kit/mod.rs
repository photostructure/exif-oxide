//! Modular tag kits with embedded PrintConv for Canon_pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: Canon.pm table: CameraSettings
//!
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub mod color;
pub mod core;
pub mod datetime;
pub mod document;
pub mod interop;
pub mod other;
pub mod thumbnail;

use crate::expressions::ExpressionEvaluator;
use crate::tiff_types::ByteOrder;
use crate::types::{Result, TagValue};
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
    pub subdirectory: Option<SubDirectoryType>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// Type alias for subdirectory processor function
pub type SubDirectoryProcessor = fn(&[u8], ByteOrder) -> Result<Vec<(String, TagValue)>>;

#[derive(Debug, Clone)]
pub enum SubDirectoryType {
    Binary { processor: SubDirectoryProcessor },
}

/// All tag kits for Canon_pm
pub static CANON_PM_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    // color tags
    for (id, tag_def) in color::get_color_tags() {
        map.insert(id, tag_def);
    }

    // core tags
    for (id, tag_def) in core::get_core_tags() {
        map.insert(id, tag_def);
    }

    // datetime tags
    for (id, tag_def) in datetime::get_datetime_tags() {
        map.insert(id, tag_def);
    }

    // document tags
    for (id, tag_def) in document::get_document_tags() {
        map.insert(id, tag_def);
    }

    // interop tags
    for (id, tag_def) in interop::get_interop_tags() {
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        map.insert(id, tag_def);
    }

    // thumbnail tags
    for (id, tag_def) in thumbnail::get_thumbnail_tags() {
        map.insert(id, tag_def);
    }

    map
});

// Helper functions for reading binary data
fn model_matches(model: &str, pattern: &str) -> bool {
    // ExifTool regexes are already in a compatible format
    // Just need to ensure proper escaping was preserved

    match regex::Regex::new(pattern) {
        Ok(re) => re.is_match(model),
        Err(e) => {
            tracing::warn!("Failed to compile model regex '{}': {}", pattern, e);
            false
        }
    }
}

fn format_matches(format: &str, pattern: &str) -> bool {
    if let Ok(re) = regex::Regex::new(pattern) {
        re.is_match(format)
    } else {
        tracing::warn!("Failed to compile format regex: {}", pattern);
        false
    }
}

fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16u array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {
    if data.len() < 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s".to_string(),
        ));
    }
    Ok(match byte_order {
        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),
        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),
    })
}

// Subdirectory processing functions
fn process_canon_camerasettings(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MacroMode at offset 1

    // CanonImageSize at offset 10

    // EasyMode at offset 11

    // DigitalZoom at offset 12

    // Contrast at offset 13

    // Saturation at offset 14

    // Sharpness at offset 15

    // CameraISO at offset 16

    // MeteringMode at offset 17

    // FocusRange at offset 18

    // AFPoint at offset 19

    // SelfTimer at offset 2

    // CanonExposureMode at offset 20

    // LensType at offset 22
    if data.len() >= 44 {
        // TODO: Handle format int16u
    }

    // MaxFocalLength at offset 23
    if data.len() >= 46 {
        // TODO: Handle format int16u
    }

    // MinFocalLength at offset 24
    if data.len() >= 48 {
        // TODO: Handle format int16u
    }

    // FocalUnits at offset 25

    // MaxAperture at offset 26

    // MinAperture at offset 27

    // FlashActivity at offset 28

    // FlashBits at offset 29

    // Quality at offset 3

    // FocusContinuous at offset 32

    // AESetting at offset 33

    // ImageStabilization at offset 34

    // DisplayAperture at offset 35

    // SpotMeteringMode at offset 39

    // CanonFlashMode at offset 4

    // PhotoEffect at offset 40

    // ManualFlashOutput at offset 41

    // ColorTone at offset 42

    // SRAWQuality at offset 46

    // ContinuousDrive at offset 5

    // FocusBracketing at offset 50

    // Clarity at offset 51

    // HDR-PQ at offset 52

    // FocusMode at offset 7

    // RecordMode at offset 9

    Ok(tags)
}

fn process_canon_focallength(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FocalType at offset 0

    // FocalLength at offset 1

    Ok(tags)
}

fn process_canon_shotinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AutoISO at offset 1

    // OpticalZoomCode at offset 10

    // CameraTemperature at offset 12

    // FlashGuideNumber at offset 13

    // AFPointsInFocus at offset 14

    // FlashExposureComp at offset 15

    // AutoExposureBracketing at offset 16

    // AEBBracketValue at offset 17

    // ControlMode at offset 18

    // FocusDistanceUpper at offset 19
    if data.len() >= 38 {
        // TODO: Handle format int16u
    }

    // BaseISO at offset 2

    // FocusDistanceLower at offset 20
    if data.len() >= 40 {
        // TODO: Handle format int16u
    }

    // FNumber at offset 21

    // MeasuredEV2 at offset 23

    // BulbDuration at offset 24

    // CameraType at offset 26

    // AutoRotate at offset 27

    // NDFilter at offset 28

    // SelfTimer2 at offset 29

    // MeasuredEV at offset 3

    // FlashOutput at offset 33

    // TargetAperture at offset 4

    // TargetExposureTime at offset 5

    // ExposureCompensation at offset 6

    // WhiteBalance at offset 7

    // SlowShutter at offset 8

    // SequenceNumber at offset 9

    Ok(tags)
}

fn process_canon_panorama(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PanoramaDirection at offset 5

    Ok(tags)
}

fn process_canon_unknownd30(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_canon_camerainfo1d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FocalLength at offset 10
    if data.len() >= 12 {
        // TODO: Handle format int16u
    }

    // LensType at offset 13
    if data.len() >= 15 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 14
    if data.len() >= 16 {
        // TODO: Handle format int16u
    }

    // MaxFocalLength at offset 16
    if data.len() >= 18 {
        // TODO: Handle format int16u
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // SharpnessFrequency at offset 65

    // Sharpness at offset 66
    if data.len() >= 67 {
        // TODO: Handle format int8s
    }

    // WhiteBalance at offset 68

    // SharpnessFrequency at offset 71

    // WhiteBalance at offset 74

    // PictureStyle at offset 75

    // ColorTemperature at offset 78
    if data.len() >= 80 {
        // TODO: Handle format int16u
    }

    // PictureStyle at offset 81

    Ok(tags)
}

fn process_canon_camerainfo1dmkii(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // JPEGQuality at offset 102

    // PictureStyle at offset 108

    // Saturation at offset 110
    if data.len() >= 111 {
        // TODO: Handle format int8s
    }

    // ColorTone at offset 111
    if data.len() >= 112 {
        // TODO: Handle format int8s
    }

    // Sharpness at offset 114
    if data.len() >= 115 {
        // TODO: Handle format int8s
    }

    // Contrast at offset 115
    if data.len() >= 116 {
        // TODO: Handle format int8s
    }

    // ISO at offset 117
    if data.len() >= 127 {
        // TODO: Handle format string
    }

    // LensType at offset 12
    if data.len() >= 14 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 17
    if data.len() >= 19 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 19
    if data.len() >= 21 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FocalType at offset 45

    // WhiteBalance at offset 54

    // ColorTemperature at offset 55
    if data.len() >= 57 {
        // TODO: Handle format int16uRev
    }

    // CanonImageSize at offset 57
    if data.len() >= 59 {
        // TODO: Handle format int16u
    }

    // FocalLength at offset 9
    if data.len() >= 11 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfo1dmkiin(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PictureStyle at offset 115

    // Sharpness at offset 116
    if data.len() >= 117 {
        // TODO: Handle format int8s
    }

    // Contrast at offset 117
    if data.len() >= 118 {
        // TODO: Handle format int8s
    }

    // Saturation at offset 118
    if data.len() >= 119 {
        // TODO: Handle format int8s
    }

    // ColorTone at offset 119
    if data.len() >= 120 {
        // TODO: Handle format int8s
    }

    // LensType at offset 12
    if data.len() >= 14 {
        // TODO: Handle format int16uRev
    }

    // ISO at offset 121
    if data.len() >= 131 {
        // TODO: Handle format string
    }

    // MinFocalLength at offset 17
    if data.len() >= 19 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 19
    if data.len() >= 21 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // WhiteBalance at offset 54

    // ColorTemperature at offset 55
    if data.len() >= 57 {
        // TODO: Handle format int16uRev
    }

    // FocalLength at offset 9
    if data.len() >= 11 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfo1dmkiii(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TimeStamp1 at offset 1114
    if data.len() >= 1118 {
        // TODO: Handle format int32u
    }

    // TimeStamp at offset 1118
    if data.len() >= 1122 {
        // TODO: Handle format int32u
    }

    // PictureStyle at offset 134

    // CameraTemperature at offset 24
    if data.len() >= 25 {
        // TODO: Handle format int8u
    }

    // MacroMagnification at offset 27

    // LensType at offset 273
    if data.len() >= 275 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 275
    if data.len() >= 277 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 277
    if data.len() >= 279 {
        // TODO: Handle format int16uRev
    }

    // FocalLength at offset 29
    if data.len() >= 31 {
        // TODO: Handle format int16uRev
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 310
    if data.len() >= 322 {
        // TODO: Handle format string
    }

    // FileIndex at offset 370
    if data.len() >= 374 {
        // TODO: Handle format int32u
    }

    // ShutterCount at offset 374
    if data.len() >= 378 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 382
    if data.len() >= 386 {
        // TODO: Handle format int32u
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // CameraOrientation at offset 48

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // FocusDistanceUpper at offset 67
    if data.len() >= 69 {
        // TODO: Handle format int16uRev
    }

    // PictureStyleInfo at offset 682

    // FocusDistanceLower at offset 69
    if data.len() >= 71 {
        // TODO: Handle format int16uRev
    }

    // WhiteBalance at offset 94
    if data.len() >= 96 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 98
    if data.len() >= 100 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_canon_camerainfo1dmkiv(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersionLookAhead at offset 0

    // WhiteBalance at offset 120
    if data.len() >= 242 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 124
    if data.len() >= 250 {
        // TODO: Handle format int16u
    }

    // FlashMeteringMode at offset 21

    // CameraTemperature at offset 25
    if data.len() >= 51 {
        // TODO: Handle format int8u
    }

    // FNumber at offset 3
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 30
    if data.len() >= 62 {
        // TODO: Handle format int16uRev
    }

    // LensType at offset 335
    if data.len() >= 672 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 337
    if data.len() >= 676 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 339
    if data.len() >= 680 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 9 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 493
    if data.len() >= 998 {
        // TODO: Handle format string
    }

    // CameraOrientation at offset 53

    // FileIndex at offset 556
    if data.len() >= 1116 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 568
    if data.len() >= 1140 {
        // TODO: Handle format int32u
    }

    // ISO at offset 6
    if data.len() >= 13 {
        // TODO: Handle format int8u
    }

    // HighlightTonePriority at offset 7

    // MeasuredEV2 at offset 8

    // FocusDistanceUpper at offset 84
    if data.len() >= 170 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 86
    if data.len() >= 174 {
        // TODO: Handle format int16uRev
    }

    // PictureStyleInfo at offset 872

    // MeasuredEV3 at offset 9

    Ok(tags)
}

fn process_canon_camerainfo1dx(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersionLookAhead at offset 0

    // PictureStyleInfo at offset 1012

    // CameraOrientation at offset 125

    // FocusDistanceUpper at offset 140
    if data.len() >= 142 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 142
    if data.len() >= 144 {
        // TODO: Handle format int16uRev
    }

    // WhiteBalance at offset 188
    if data.len() >= 190 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 192
    if data.len() >= 194 {
        // TODO: Handle format int16u
    }

    // PictureStyle at offset 244
    if data.len() >= 245 {
        // TODO: Handle format int8u
    }

    // CameraTemperature at offset 27
    if data.len() >= 28 {
        // TODO: Handle format int8u
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 35
    if data.len() >= 37 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // LensType at offset 423
    if data.len() >= 425 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 425
    if data.len() >= 427 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 427
    if data.len() >= 429 {
        // TODO: Handle format int16uRev
    }

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 640
    if data.len() >= 652 {
        // TODO: Handle format string
    }

    // FileIndex at offset 720
    if data.len() >= 724 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 732
    if data.len() >= 736 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_canon_camerainfo5d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PictureStyle at offset 108
    if data.len() >= 109 {
        // TODO: Handle format int8u
    }

    // LensType at offset 12
    if data.len() >= 14 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 147
    if data.len() >= 149 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 149
    if data.len() >= 151 {
        // TODO: Handle format int16uRev
    }

    // LensType at offset 151
    if data.len() >= 153 {
        // TODO: Handle format int16uRev
    }

    // FirmwareRevision at offset 164
    if data.len() >= 180 {
        // TODO: Handle format string
    }

    // ShortOwnerName at offset 172
    if data.len() >= 204 {
        // TODO: Handle format string
    }

    // DirectoryIndex at offset 204
    if data.len() >= 208 {
        // TODO: Handle format int32u
    }

    // FileIndex at offset 208
    if data.len() >= 210 {
        // TODO: Handle format int16u
    }

    // CameraTemperature at offset 23
    if data.len() >= 24 {
        // TODO: Handle format int8u
    }

    // FilterEffectMonochrome at offset 255

    // ToningEffectMonochrome at offset 264

    // UserDef1PictureStyle at offset 268
    if data.len() >= 270 {
        // TODO: Handle format int16u
    }

    // MacroMagnification at offset 27

    // UserDef2PictureStyle at offset 270
    if data.len() >= 272 {
        // TODO: Handle format int16u
    }

    // UserDef3PictureStyle at offset 272
    if data.len() >= 274 {
        // TODO: Handle format int16u
    }

    // TimeStamp at offset 284
    if data.len() >= 288 {
        // TODO: Handle format int32u
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // CameraOrientation at offset 39

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 40
    if data.len() >= 42 {
        // TODO: Handle format int16uRev
    }

    // AFPointsInFocus5D at offset 56
    if data.len() >= 58 {
        // TODO: Handle format int16uRev
    }

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // WhiteBalance at offset 84
    if data.len() >= 86 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 88
    if data.len() >= 90 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_canon_camerainfo5dmkii(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersionLookAhead at offset 0

    // WhiteBalance at offset 111
    if data.len() >= 113 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 115
    if data.len() >= 117 {
        // TODO: Handle format int16u
    }

    // PictureStyle at offset 167
    if data.len() >= 168 {
        // TODO: Handle format int8u
    }

    // HighISONoiseReduction at offset 189

    // AutoLightingOptimizer at offset 191

    // FlashMeteringMode at offset 21

    // LensType at offset 230
    if data.len() >= 232 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 232
    if data.len() >= 234 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 234
    if data.len() >= 236 {
        // TODO: Handle format int16uRev
    }

    // CameraTemperature at offset 25
    if data.len() >= 26 {
        // TODO: Handle format int8u
    }

    // MacroMagnification at offset 27

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 30
    if data.len() >= 32 {
        // TODO: Handle format int16uRev
    }

    // FirmwareVersion at offset 382
    if data.len() >= 394 {
        // TODO: Handle format string
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FileIndex at offset 443
    if data.len() >= 447 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 455
    if data.len() >= 459 {
        // TODO: Handle format int32u
    }

    // CameraOrientation at offset 49

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // HighlightTonePriority at offset 7

    // PictureStyleInfo at offset 759

    // FocusDistanceUpper at offset 80
    if data.len() >= 82 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 82
    if data.len() >= 84 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfo5dmkiii(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersionLookAhead at offset 0

    // CameraOrientation at offset 125

    // FocusDistanceUpper at offset 140
    if data.len() >= 142 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 142
    if data.len() >= 144 {
        // TODO: Handle format int16uRev
    }

    // WhiteBalance at offset 188
    if data.len() >= 190 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 192
    if data.len() >= 194 {
        // TODO: Handle format int16u
    }

    // PictureStyle at offset 244
    if data.len() >= 245 {
        // TODO: Handle format int8u
    }

    // CameraTemperature at offset 27
    if data.len() >= 28 {
        // TODO: Handle format int8u
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // LensType at offset 339
    if data.len() >= 341 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 341
    if data.len() >= 343 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 343
    if data.len() >= 345 {
        // TODO: Handle format int16uRev
    }

    // FocalLength at offset 35
    if data.len() >= 37 {
        // TODO: Handle format int16uRev
    }

    // LensSerialNumber at offset 356
    if data.len() >= 366 {
        // TODO: Handle format undef
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 572
    if data.len() >= 584 {
        // TODO: Handle format string
    }

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // FileIndex at offset 652
    if data.len() >= 656 {
        // TODO: Handle format int32u
    }

    // FileIndex2 at offset 656
    if data.len() >= 660 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 664
    if data.len() >= 668 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex2 at offset 668
    if data.len() >= 672 {
        // TODO: Handle format int32u
    }

    // PictureStyleInfo at offset 944

    Ok(tags)
}

fn process_canon_camerainfo6d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CameraOrientation at offset 131

    // FocusDistanceUpper at offset 146
    if data.len() >= 148 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 148
    if data.len() >= 150 {
        // TODO: Handle format int16uRev
    }

    // WhiteBalance at offset 194
    if data.len() >= 196 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 198
    if data.len() >= 200 {
        // TODO: Handle format int16u
    }

    // PictureStyle at offset 250
    if data.len() >= 251 {
        // TODO: Handle format int8u
    }

    // CameraTemperature at offset 27
    if data.len() >= 28 {
        // TODO: Handle format int8u
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 35
    if data.len() >= 37 {
        // TODO: Handle format int16uRev
    }

    // LensType at offset 353
    if data.len() >= 355 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 355
    if data.len() >= 357 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 357
    if data.len() >= 359 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 598
    if data.len() >= 610 {
        // TODO: Handle format string
    }

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // FileIndex at offset 682
    if data.len() >= 686 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 694
    if data.len() >= 698 {
        // TODO: Handle format int32u
    }

    // PictureStyleInfo at offset 966

    Ok(tags)
}

fn process_canon_camerainfo7d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersionLookAhead at offset 0

    // WhiteBalance at offset 119
    if data.len() >= 121 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 123
    if data.len() >= 125 {
        // TODO: Handle format int16u
    }

    // CameraPictureStyle at offset 175

    // HighISONoiseReduction at offset 201

    // FlashMeteringMode at offset 21

    // CameraTemperature at offset 25
    if data.len() >= 26 {
        // TODO: Handle format int8u
    }

    // LensType at offset 274
    if data.len() >= 276 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 276
    if data.len() >= 278 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 278
    if data.len() >= 280 {
        // TODO: Handle format int16uRev
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 30
    if data.len() >= 32 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 428
    if data.len() >= 440 {
        // TODO: Handle format string
    }

    // FileIndex at offset 491
    if data.len() >= 495 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 503
    if data.len() >= 507 {
        // TODO: Handle format int32u
    }

    // CameraOrientation at offset 53

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // HighlightTonePriority at offset 7

    // MeasuredEV2 at offset 8

    // PictureStyleInfo at offset 807

    // FocusDistanceUpper at offset 84
    if data.len() >= 86 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 86
    if data.len() >= 88 {
        // TODO: Handle format int16uRev
    }

    // MeasuredEV at offset 9

    Ok(tags)
}

fn process_canon_camerainfo40d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WhiteBalance at offset 111
    if data.len() >= 113 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 115
    if data.len() >= 117 {
        // TODO: Handle format int16u
    }

    // FlashMeteringMode at offset 21

    // LensType at offset 214
    if data.len() >= 216 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 216
    if data.len() >= 218 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 218
    if data.len() >= 220 {
        // TODO: Handle format int16uRev
    }

    // LensModel at offset 2347
    if data.len() >= 2475 {
        // TODO: Handle format string
    }

    // CameraTemperature at offset 24
    if data.len() >= 25 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 255
    if data.len() >= 267 {
        // TODO: Handle format string
    }

    // MacroMagnification at offset 27

    // FocalLength at offset 29
    if data.len() >= 31 {
        // TODO: Handle format int16uRev
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FileIndex at offset 307
    if data.len() >= 311 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 319
    if data.len() >= 323 {
        // TODO: Handle format int32u
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // CameraOrientation at offset 48

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // PictureStyleInfo at offset 603

    // FocusDistanceUpper at offset 67
    if data.len() >= 69 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 69
    if data.len() >= 71 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfo50d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersionLookAhead at offset 0

    // WhiteBalance at offset 111
    if data.len() >= 113 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 115
    if data.len() >= 117 {
        // TODO: Handle format int16u
    }

    // PictureStyle at offset 167
    if data.len() >= 168 {
        // TODO: Handle format int8u
    }

    // HighISONoiseReduction at offset 189

    // AutoLightingOptimizer at offset 191

    // FlashMeteringMode at offset 21

    // LensType at offset 234
    if data.len() >= 236 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 236
    if data.len() >= 238 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 238
    if data.len() >= 240 {
        // TODO: Handle format int16uRev
    }

    // CameraTemperature at offset 25
    if data.len() >= 26 {
        // TODO: Handle format int8u
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 30
    if data.len() >= 32 {
        // TODO: Handle format int16uRev
    }

    // FirmwareVersion at offset 350
    if data.len() >= 362 {
        // TODO: Handle format string
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FileIndex at offset 411
    if data.len() >= 415 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 423
    if data.len() >= 427 {
        // TODO: Handle format int32u
    }

    // CameraOrientation at offset 49

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // HighlightTonePriority at offset 7

    // PictureStyleInfo at offset 727

    // FocusDistanceUpper at offset 80
    if data.len() >= 82 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 82
    if data.len() >= 84 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfo60d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorTemperature at offset 125
    if data.len() >= 127 {
        // TODO: Handle format int16u
    }

    // LensType at offset 232
    if data.len() >= 234 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 234
    if data.len() >= 236 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 236
    if data.len() >= 238 {
        // TODO: Handle format int16uRev
    }

    // CameraTemperature at offset 25
    if data.len() >= 26 {
        // TODO: Handle format int8u
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 30
    if data.len() >= 32 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 409
    if data.len() >= 421 {
        // TODO: Handle format string
    }

    // FileIndex at offset 473
    if data.len() >= 477 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 485
    if data.len() >= 489 {
        // TODO: Handle format int32u
    }

    // CameraOrientation at offset 54

    // CameraOrientation at offset 58

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // PictureStyleInfo at offset 761

    // PictureStyleInfo at offset 801

    // FocusDistanceUpper at offset 85
    if data.len() >= 87 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 87
    if data.len() >= 89 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfo70d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CameraOrientation at offset 132

    // FocusDistanceUpper at offset 147
    if data.len() >= 149 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 149
    if data.len() >= 151 {
        // TODO: Handle format int16uRev
    }

    // ColorTemperature at offset 199
    if data.len() >= 201 {
        // TODO: Handle format int16u
    }

    // CameraTemperature at offset 27
    if data.len() >= 28 {
        // TODO: Handle format int8u
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 35
    if data.len() >= 37 {
        // TODO: Handle format int16uRev
    }

    // LensType at offset 358
    if data.len() >= 360 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 360
    if data.len() >= 362 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 362
    if data.len() >= 364 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 606
    if data.len() >= 618 {
        // TODO: Handle format string
    }

    // FileIndex at offset 691
    if data.len() >= 695 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 703
    if data.len() >= 707 {
        // TODO: Handle format int32u
    }

    // PictureStyleInfo at offset 975

    Ok(tags)
}

fn process_canon_camerainfo80d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersion at offset 1114
    if data.len() >= 1126 {
        // TODO: Handle format string
    }

    // FileIndex at offset 1198
    if data.len() >= 1202 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 1210
    if data.len() >= 1214 {
        // TODO: Handle format int32u
    }

    // CameraOrientation at offset 150

    // FocusDistanceUpper at offset 165
    if data.len() >= 167 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 167
    if data.len() >= 169 {
        // TODO: Handle format int16uRev
    }

    // CameraTemperature at offset 27
    if data.len() >= 28 {
        // TODO: Handle format int8u
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // ColorTemperature at offset 314
    if data.len() >= 316 {
        // TODO: Handle format int16u
    }

    // FocalLength at offset 35
    if data.len() >= 37 {
        // TODO: Handle format int16uRev
    }

    // LensType at offset 393
    if data.len() >= 395 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 395
    if data.len() >= 397 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 397
    if data.len() >= 399 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_canon_camerainfo450d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WhiteBalance at offset 111
    if data.len() >= 113 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 115
    if data.len() >= 117 {
        // TODO: Handle format int16u
    }

    // FlashMeteringMode at offset 21

    // LensType at offset 222
    if data.len() >= 224 {
        // TODO: Handle format int16uRev
    }

    // LensModel at offset 2355
    if data.len() >= 2483 {
        // TODO: Handle format string
    }

    // CameraTemperature at offset 24
    if data.len() >= 25 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 263
    if data.len() >= 275 {
        // TODO: Handle format string
    }

    // MacroMagnification at offset 27

    // OwnerName at offset 271
    if data.len() >= 335 {
        // TODO: Handle format string
    }

    // FocalLength at offset 29
    if data.len() >= 31 {
        // TODO: Handle format int16uRev
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // DirectoryIndex at offset 307
    if data.len() >= 311 {
        // TODO: Handle format int32u
    }

    // FileIndex at offset 319
    if data.len() >= 323 {
        // TODO: Handle format int32u
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // CameraOrientation at offset 48

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // PictureStyleInfo at offset 611

    // FocusDistanceUpper at offset 67
    if data.len() >= 69 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 69
    if data.len() >= 71 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfo500d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WhiteBalance at offset 115
    if data.len() >= 117 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 119
    if data.len() >= 121 {
        // TODO: Handle format int16u
    }

    // PictureStyle at offset 171
    if data.len() >= 172 {
        // TODO: Handle format int8u
    }

    // HighISONoiseReduction at offset 188

    // AutoLightingOptimizer at offset 190

    // FlashMeteringMode at offset 21

    // LensType at offset 246
    if data.len() >= 248 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 248
    if data.len() >= 250 {
        // TODO: Handle format int16uRev
    }

    // CameraTemperature at offset 25
    if data.len() >= 26 {
        // TODO: Handle format int8u
    }

    // MaxFocalLength at offset 250
    if data.len() >= 252 {
        // TODO: Handle format int16uRev
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 30
    if data.len() >= 32 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 400
    if data.len() >= 412 {
        // TODO: Handle format string
    }

    // FileIndex at offset 467
    if data.len() >= 471 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 479
    if data.len() >= 483 {
        // TODO: Handle format int32u
    }

    // CameraOrientation at offset 49

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // HighlightTonePriority at offset 7

    // PictureStyleInfo at offset 779

    // FocusDistanceUpper at offset 80
    if data.len() >= 82 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 82
    if data.len() >= 84 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfo550d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WhiteBalance at offset 120
    if data.len() >= 122 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 124
    if data.len() >= 126 {
        // TODO: Handle format int16u
    }

    // PictureStyle at offset 176
    if data.len() >= 177 {
        // TODO: Handle format int8u
    }

    // FlashMeteringMode at offset 21

    // CameraTemperature at offset 25
    if data.len() >= 26 {
        // TODO: Handle format int8u
    }

    // LensType at offset 255
    if data.len() >= 257 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 257
    if data.len() >= 259 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 259
    if data.len() >= 261 {
        // TODO: Handle format int16uRev
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 30
    if data.len() >= 32 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 420
    if data.len() >= 432 {
        // TODO: Handle format string
    }

    // FileIndex at offset 484
    if data.len() >= 488 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 496
    if data.len() >= 500 {
        // TODO: Handle format int32u
    }

    // CameraOrientation at offset 53

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // HighlightTonePriority at offset 7

    // PictureStyleInfo at offset 796

    // FocusDistanceUpper at offset 84
    if data.len() >= 86 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 86
    if data.len() >= 88 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfo600d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WhiteBalance at offset 123
    if data.len() >= 125 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 127
    if data.len() >= 129 {
        // TODO: Handle format int16u
    }

    // PictureStyle at offset 179
    if data.len() >= 180 {
        // TODO: Handle format int8u
    }

    // FlashMeteringMode at offset 21

    // LensType at offset 234
    if data.len() >= 236 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 236
    if data.len() >= 238 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 238
    if data.len() >= 240 {
        // TODO: Handle format int16uRev
    }

    // CameraTemperature at offset 25
    if data.len() >= 26 {
        // TODO: Handle format int8u
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 30
    if data.len() >= 32 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 411
    if data.len() >= 423 {
        // TODO: Handle format string
    }

    // FileIndex at offset 475
    if data.len() >= 479 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 487
    if data.len() >= 491 {
        // TODO: Handle format int32u
    }

    // CameraOrientation at offset 56

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // HighlightTonePriority at offset 7

    // PictureStyleInfo at offset 763

    // FocusDistanceUpper at offset 87
    if data.len() >= 89 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 89
    if data.len() >= 91 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfo650d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CameraOrientation at offset 125

    // FocusDistanceUpper at offset 140
    if data.len() >= 142 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 142
    if data.len() >= 144 {
        // TODO: Handle format int16uRev
    }

    // WhiteBalance at offset 188
    if data.len() >= 190 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 192
    if data.len() >= 194 {
        // TODO: Handle format int16u
    }

    // PictureStyle at offset 244
    if data.len() >= 245 {
        // TODO: Handle format int8u
    }

    // CameraTemperature at offset 27
    if data.len() >= 28 {
        // TODO: Handle format int8u
    }

    // LensType at offset 295
    if data.len() >= 297 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 297
    if data.len() >= 299 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 299
    if data.len() >= 301 {
        // TODO: Handle format int16uRev
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // FocalLength at offset 35
    if data.len() >= 37 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 539
    if data.len() >= 551 {
        // TODO: Handle format string
    }

    // FirmwareVersion at offset 544
    if data.len() >= 556 {
        // TODO: Handle format string
    }

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // FileIndex at offset 624
    if data.len() >= 628 {
        // TODO: Handle format int32u
    }

    // FileIndex at offset 628
    if data.len() >= 632 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 636
    if data.len() >= 640 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 640
    if data.len() >= 644 {
        // TODO: Handle format int32u
    }

    // PictureStyleInfo at offset 912

    Ok(tags)
}

fn process_canon_camerainfo750d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersion at offset 1085
    if data.len() >= 1097 {
        // TODO: Handle format string
    }

    // FirmwareVersion at offset 1097
    if data.len() >= 1109 {
        // TODO: Handle format string
    }

    // CameraOrientation at offset 150

    // FocusDistanceUpper at offset 165
    if data.len() >= 167 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 167
    if data.len() >= 169 {
        // TODO: Handle format int16uRev
    }

    // CameraTemperature at offset 27
    if data.len() >= 28 {
        // TODO: Handle format int8u
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // WhiteBalance at offset 305
    if data.len() >= 307 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 309
    if data.len() >= 311 {
        // TODO: Handle format int16u
    }

    // FocalLength at offset 35
    if data.len() >= 37 {
        // TODO: Handle format int16uRev
    }

    // PictureStyle at offset 361
    if data.len() >= 362 {
        // TODO: Handle format int8u
    }

    // LensType at offset 388
    if data.len() >= 390 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 390
    if data.len() >= 392 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 392
    if data.len() >= 394 {
        // TODO: Handle format int16uRev
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_canon_camerainfo1000d(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WhiteBalance at offset 111
    if data.len() >= 113 {
        // TODO: Handle format int16u
    }

    // ColorTemperature at offset 115
    if data.len() >= 117 {
        // TODO: Handle format int16u
    }

    // FlashMeteringMode at offset 21

    // LensType at offset 226
    if data.len() >= 228 {
        // TODO: Handle format int16uRev
    }

    // MinFocalLength at offset 228
    if data.len() >= 230 {
        // TODO: Handle format int16uRev
    }

    // MaxFocalLength at offset 230
    if data.len() >= 232 {
        // TODO: Handle format int16uRev
    }

    // LensModel at offset 2359
    if data.len() >= 2487 {
        // TODO: Handle format string
    }

    // CameraTemperature at offset 24
    if data.len() >= 25 {
        // TODO: Handle format int8u
    }

    // FirmwareVersion at offset 267
    if data.len() >= 279 {
        // TODO: Handle format string
    }

    // MacroMagnification at offset 27

    // FocalLength at offset 29
    if data.len() >= 31 {
        // TODO: Handle format int16uRev
    }

    // FNumber at offset 3
    if data.len() >= 4 {
        // TODO: Handle format int8u
    }

    // DirectoryIndex at offset 311
    if data.len() >= 315 {
        // TODO: Handle format int32u
    }

    // FileIndex at offset 323
    if data.len() >= 327 {
        // TODO: Handle format int32u
    }

    // ExposureTime at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    // CameraOrientation at offset 48

    // ISO at offset 6
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    // PictureStyleInfo at offset 615

    // FocusDistanceUpper at offset 67
    if data.len() >= 69 {
        // TODO: Handle format int16uRev
    }

    // FocusDistanceLower at offset 69
    if data.len() >= 71 {
        // TODO: Handle format int16uRev
    }

    Ok(tags)
}

fn process_canon_camerainfor6(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShutterCount at offset 2801
    if data.len() >= 5606 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_canon_camerainfor6m2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShutterCount at offset 3369
    if data.len() >= 6742 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_canon_camerainfog5xii(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShutterCount at offset 2709
    if data.len() >= 5422 {
        // TODO: Handle format int32u
    }

    // DirectoryIndex at offset 2849
    if data.len() >= 5702 {
        // TODO: Handle format int32u
    }

    // FileIndex at offset 2861
    if data.len() >= 5726 {
        // TODO: Handle format int32u
    }

    // ShutterCount at offset 659
    if data.len() >= 1322 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_canon_camerainfopowershot(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ISO at offset 0

    // CameraTemperature at offset 135

    // CameraTemperature at offset 145

    // FNumber at offset 5

    // ExposureTime at offset 6

    Ok(tags)
}

fn process_canon_camerainfopowershot2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ISO at offset 1

    // CameraTemperature at offset 153

    // CameraTemperature at offset 159

    // CameraTemperature at offset 164

    // CameraTemperature at offset 168

    // CameraTemperature at offset 261

    // FNumber at offset 6

    // ExposureTime at offset 7

    Ok(tags)
}

fn process_canon_camerainfounknown32(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CameraTemperature at offset -3
    // CameraTemperature uses negative offset -12 (from end of data)
    if data.len() as i32 + -12 < 0 {
        // Skipping CameraTemperature - negative offset beyond data start
        // (This is normal for some tables)
    } else {
        let cameratemperature_offset = (data.len() as i32 + -12) as usize;
    }

    // CameraTemperature at offset 100

    // CameraTemperature at offset 71

    // CameraTemperature at offset 83

    // CameraTemperature at offset 91

    // CameraTemperature at offset 92

    Ok(tags)
}

fn process_canon_camerainfounknown16(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_canon_camerainfounknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersion at offset 1473
    if data.len() >= 1485 {
        // TODO: Handle format string
    }

    // LensSerialNumber at offset 363
    if data.len() >= 373 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_canon_movieinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FrameRate at offset 1

    // Duration at offset 106
    if data.len() >= 214 {
        // TODO: Handle format int32u
    }

    // AudioBitrate at offset 108
    if data.len() >= 218 {
        // TODO: Handle format int32u
    }

    // AudioSampleRate at offset 110
    if data.len() >= 222 {
        // TODO: Handle format int32u
    }

    // AudioChannels at offset 112
    if data.len() >= 226 {
        // TODO: Handle format int32u
    }

    // VideoCodec at offset 116
    if data.len() >= 238 {
        // TODO: Handle format undef
    }

    // FrameCount at offset 2

    // FrameCount at offset 4
    if data.len() >= 10 {
        // TODO: Handle format int32u
    }

    // FrameRate at offset 6
    if data.len() >= 12 {
        // TODO: Handle format rational32u
    }

    Ok(tags)
}

fn process_canon_afinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // NumAFPoints at offset 0

    // ValidAFPoints at offset 1

    // AFPointsInFocus at offset 10

    // CanonImageWidth at offset 2

    // CanonImageHeight at offset 3

    // AFImageWidth at offset 4

    // AFAreaXPositions at offset 8

    // AFAreaYPositions at offset 9

    Ok(tags)
}

fn process_canon_mycolors(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MyColorMode at offset 2

    Ok(tags)
}

fn process_canon_facedetect1(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Face2Position at offset 10
    if data.len() >= 24 {
        if let Ok(values) = read_int16s_array(&data[20..24], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face2Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face3Position at offset 12
    if data.len() >= 28 {
        if let Ok(values) = read_int16s_array(&data[24..28], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face3Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face4Position at offset 14
    if data.len() >= 32 {
        if let Ok(values) = read_int16s_array(&data[28..32], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face4Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face5Position at offset 16
    if data.len() >= 36 {
        if let Ok(values) = read_int16s_array(&data[32..36], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face5Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face6Position at offset 18
    if data.len() >= 40 {
        if let Ok(values) = read_int16s_array(&data[36..40], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face6Position".to_string(), TagValue::String(value_str)));
        }
    }

    // FacesDetected at offset 2

    // Face7Position at offset 20
    if data.len() >= 44 {
        if let Ok(values) = read_int16s_array(&data[40..44], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face7Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face8Position at offset 22
    if data.len() >= 48 {
        if let Ok(values) = read_int16s_array(&data[44..48], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face8Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face9Position at offset 24
    if data.len() >= 52 {
        if let Ok(values) = read_int16s_array(&data[48..52], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face9Position".to_string(), TagValue::String(value_str)));
        }
    }

    // FaceDetectFrameSize at offset 3
    if data.len() >= 10 {
        if let Ok(values) = read_int16u_array(&data[6..10], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FaceDetectFrameSize".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // Face1Position at offset 8
    if data.len() >= 20 {
        if let Ok(values) = read_int16s_array(&data[16..20], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face1Position".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_canon_facedetect2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_canon_afinfo2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFInfoSize at offset 0

    // AFAreaMode at offset 1

    // AFAreaXPositions at offset 10

    // AFAreaYPositions at offset 11

    // AFPointsInFocus at offset 12

    // PrimaryAFPoint at offset 14

    // NumAFPoints at offset 2

    // ValidAFPoints at offset 3

    // CanonImageWidth at offset 4

    // CanonImageHeight at offset 5

    // AFImageWidth at offset 6

    // AFAreaWidths at offset 8

    // AFAreaHeights at offset 9

    Ok(tags)
}

fn process_canon_contrastinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // IntelligentContrast at offset 4

    Ok(tags)
}

fn process_canon_wbinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_GRBGLevelsDaylight at offset 10
    if data.len() >= 52 {
        // TODO: Handle format int32s
    }

    // WB_GRBGLevelsCloudy at offset 18
    if data.len() >= 84 {
        // TODO: Handle format int32s
    }

    // WB_GRBGLevelsAuto at offset 2
    if data.len() >= 20 {
        // TODO: Handle format int32s
    }

    // WB_GRBGLevelsTungsten at offset 26
    if data.len() >= 116 {
        // TODO: Handle format int32s
    }

    // WB_GRBGLevelsFluorescent at offset 34
    if data.len() >= 148 {
        // TODO: Handle format int32s
    }

    // WB_GRBGLevelsFluorHigh at offset 42
    if data.len() >= 180 {
        // TODO: Handle format int32s
    }

    // WB_GRBGLevelsFlash at offset 50
    if data.len() >= 212 {
        // TODO: Handle format int32s
    }

    // WB_GRBGLevelsUnderwater at offset 58
    if data.len() >= 244 {
        // TODO: Handle format int32s
    }

    // WB_GRBGLevelsCustom1 at offset 66
    if data.len() >= 276 {
        // TODO: Handle format int32s
    }

    // WB_GRBGLevelsCustom2 at offset 74
    if data.len() >= 308 {
        // TODO: Handle format int32s
    }

    Ok(tags)
}

fn process_canon_facedetect3(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_canon_timeinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TimeZone at offset 1

    // TimeZoneCity at offset 2

    // DaylightSavings at offset 3

    Ok(tags)
}

fn process_canon_colorcoefs(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_RGGBLevelsAsShot at offset 0
    if data.len() >= 8 {
        if let Ok(values) = read_int16s_array(&data[0..8], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsMeasured at offset 10
    if data.len() >= 28 {
        if let Ok(values) = read_int16s_array(&data[20..28], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsMeasured".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown11 at offset 100
    if data.len() >= 208 {
        if let Ok(values) = read_int16s_array(&data[200..208], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 104

    // WB_RGGBLevelsUnknown12 at offset 105
    if data.len() >= 218 {
        if let Ok(values) = read_int16s_array(&data[210..218], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown12 at offset 109

    // WB_RGGBLevelsUnknown13 at offset 110
    if data.len() >= 228 {
        if let Ok(values) = read_int16s_array(&data[220..228], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown13 at offset 114

    // WB_RGGBLevelsUnknown at offset 15
    if data.len() >= 38 {
        if let Ok(values) = read_int16s_array(&data[30..38], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown at offset 19

    // WB_RGGBLevelsDaylight at offset 20
    if data.len() >= 48 {
        if let Ok(values) = read_int16s_array(&data[40..48], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 25
    if data.len() >= 58 {
        if let Ok(values) = read_int16s_array(&data[50..58], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 30
    if data.len() >= 68 {
        if let Ok(values) = read_int16s_array(&data[60..68], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 35
    if data.len() >= 78 {
        if let Ok(values) = read_int16s_array(&data[70..78], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 40
    if data.len() >= 88 {
        if let Ok(values) = read_int16s_array(&data[80..88], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsKelvin at offset 45
    if data.len() >= 98 {
        if let Ok(values) = read_int16s_array(&data[90..98], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsAuto at offset 5
    if data.len() >= 18 {
        if let Ok(values) = read_int16s_array(&data[10..18], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsFlash at offset 50
    if data.len() >= 108 {
        if let Ok(values) = read_int16s_array(&data[100..108], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown2 at offset 55
    if data.len() >= 118 {
        if let Ok(values) = read_int16s_array(&data[110..118], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown2 at offset 59

    // WB_RGGBLevelsUnknown3 at offset 60
    if data.len() >= 128 {
        if let Ok(values) = read_int16s_array(&data[120..128], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown3 at offset 64

    // WB_RGGBLevelsUnknown4 at offset 65
    if data.len() >= 138 {
        if let Ok(values) = read_int16s_array(&data[130..138], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown4 at offset 69

    // WB_RGGBLevelsUnknown5 at offset 70
    if data.len() >= 148 {
        if let Ok(values) = read_int16s_array(&data[140..148], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown5 at offset 74

    // WB_RGGBLevelsUnknown6 at offset 75
    if data.len() >= 158 {
        if let Ok(values) = read_int16s_array(&data[150..158], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown6 at offset 79

    // WB_RGGBLevelsUnknown7 at offset 80
    if data.len() >= 168 {
        if let Ok(values) = read_int16s_array(&data[160..168], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown7 at offset 84

    // WB_RGGBLevelsUnknown8 at offset 85
    if data.len() >= 178 {
        if let Ok(values) = read_int16s_array(&data[170..178], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown8 at offset 89

    // WB_RGGBLevelsUnknown9 at offset 90
    if data.len() >= 188 {
        if let Ok(values) = read_int16s_array(&data[180..188], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown9 at offset 94

    // WB_RGGBLevelsUnknown10 at offset 95
    if data.len() >= 198 {
        if let Ok(values) = read_int16s_array(&data[190..198], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown10 at offset 99

    Ok(tags)
}

fn process_canon_colorcoefs2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_RGGBLevelsAsShot at offset 0
    if data.len() >= 8 {
        if let Ok(values) = read_int16s_array(&data[0..8], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown3 at offset 103

    // WB_RGGBLevelsUnknown4 at offset 104
    if data.len() >= 216 {
        if let Ok(values) = read_int16s_array(&data[208..216], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown4 at offset 111

    // WB_RGGBLevelsUnknown5 at offset 112
    if data.len() >= 232 {
        if let Ok(values) = read_int16s_array(&data[224..232], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown5 at offset 119

    // WB_RGGBLevelsUnknown6 at offset 120
    if data.len() >= 248 {
        if let Ok(values) = read_int16s_array(&data[240..248], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown6 at offset 127

    // WB_RGGBLevelsUnknown7 at offset 128
    if data.len() >= 264 {
        if let Ok(values) = read_int16s_array(&data[256..264], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown7 at offset 135

    // WB_RGGBLevelsUnknown8 at offset 136
    if data.len() >= 280 {
        if let Ok(values) = read_int16s_array(&data[272..280], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown8 at offset 143

    // WB_RGGBLevelsUnknown9 at offset 144
    if data.len() >= 296 {
        if let Ok(values) = read_int16s_array(&data[288..296], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown9 at offset 151

    // WB_RGGBLevelsUnknown10 at offset 152
    if data.len() >= 312 {
        if let Ok(values) = read_int16s_array(&data[304..312], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown10 at offset 159

    // WB_RGGBLevelsMeasured at offset 16
    if data.len() >= 40 {
        if let Ok(values) = read_int16s_array(&data[32..40], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsMeasured".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown11 at offset 160
    if data.len() >= 328 {
        if let Ok(values) = read_int16s_array(&data[320..328], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 167

    // WB_RGGBLevelsUnknown12 at offset 168
    if data.len() >= 344 {
        if let Ok(values) = read_int16s_array(&data[336..344], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown12 at offset 175

    // WB_RGGBLevelsUnknown13 at offset 176
    if data.len() >= 360 {
        if let Ok(values) = read_int16s_array(&data[352..360], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown13 at offset 183

    // WB_RGGBLevelsUnknown at offset 24
    if data.len() >= 56 {
        if let Ok(values) = read_int16s_array(&data[48..56], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown at offset 31

    // WB_RGGBLevelsDaylight at offset 32
    if data.len() >= 72 {
        if let Ok(values) = read_int16s_array(&data[64..72], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 40
    if data.len() >= 88 {
        if let Ok(values) = read_int16s_array(&data[80..88], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 48
    if data.len() >= 104 {
        if let Ok(values) = read_int16s_array(&data[96..104], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 56
    if data.len() >= 120 {
        if let Ok(values) = read_int16s_array(&data[112..120], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 64
    if data.len() >= 136 {
        if let Ok(values) = read_int16s_array(&data[128..136], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsKelvin at offset 72
    if data.len() >= 152 {
        if let Ok(values) = read_int16s_array(&data[144..152], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsAuto at offset 8
    if data.len() >= 24 {
        if let Ok(values) = read_int16s_array(&data[16..24], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsFlash at offset 80
    if data.len() >= 168 {
        if let Ok(values) = read_int16s_array(&data[160..168], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown2 at offset 88
    if data.len() >= 184 {
        if let Ok(values) = read_int16s_array(&data[176..184], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown2 at offset 95

    // WB_RGGBLevelsUnknown3 at offset 96
    if data.len() >= 200 {
        if let Ok(values) = read_int16s_array(&data[192..200], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_colorcalib(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CameraColorCalibration01 at offset 0
    if data.len() >= 8 {
        if let Ok(values) = read_int16s_array(&data[0..8], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration01".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration04 at offset 12
    if data.len() >= 32 {
        if let Ok(values) = read_int16s_array(&data[24..32], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration04".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration05 at offset 16
    if data.len() >= 40 {
        if let Ok(values) = read_int16s_array(&data[32..40], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration05".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration06 at offset 20
    if data.len() >= 48 {
        if let Ok(values) = read_int16s_array(&data[40..48], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration06".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration07 at offset 24
    if data.len() >= 56 {
        if let Ok(values) = read_int16s_array(&data[48..56], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration07".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration08 at offset 28
    if data.len() >= 64 {
        if let Ok(values) = read_int16s_array(&data[56..64], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration08".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration09 at offset 32
    if data.len() >= 72 {
        if let Ok(values) = read_int16s_array(&data[64..72], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration09".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration10 at offset 36
    if data.len() >= 80 {
        if let Ok(values) = read_int16s_array(&data[72..80], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration02 at offset 4
    if data.len() >= 16 {
        if let Ok(values) = read_int16s_array(&data[8..16], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration02".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration11 at offset 40
    if data.len() >= 88 {
        if let Ok(values) = read_int16s_array(&data[80..88], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration12 at offset 44
    if data.len() >= 96 {
        if let Ok(values) = read_int16s_array(&data[88..96], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration13 at offset 48
    if data.len() >= 104 {
        if let Ok(values) = read_int16s_array(&data[96..104], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration14 at offset 52
    if data.len() >= 112 {
        if let Ok(values) = read_int16s_array(&data[104..112], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration15 at offset 56
    if data.len() >= 120 {
        if let Ok(values) = read_int16s_array(&data[112..120], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration03 at offset 8
    if data.len() >= 24 {
        if let Ok(values) = read_int16s_array(&data[16..24], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration03".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_fileinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FilterEffect at offset 14

    // ToningEffect at offset 15

    // MacroMagnification at offset 16

    // LiveViewShooting at offset 19

    // FocusDistanceUpper at offset 20
    if data.len() >= 40 {
        // TODO: Handle format int16u
    }

    // FocusDistanceLower at offset 21
    if data.len() >= 42 {
        // TODO: Handle format int16u
    }

    // ShutterMode at offset 23

    // FlashExposureLock at offset 25

    // BracketMode at offset 3

    // AntiFlicker at offset 32

    // RawJpgQuality at offset 6

    // RFLensType at offset 61
    if data.len() >= 122 {
        // TODO: Handle format int16u
    }

    // RawJpgSize at offset 7

    // LongExposureNoiseReduction2 at offset 8

    // WBBracketMode at offset 9

    Ok(tags)
}

fn process_canon_serialinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // InternalSerialNumber at offset 9
    if data.len() >= 20 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_canon_cropinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_canon_aspectinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AspectRatio at offset 0

    Ok(tags)
}

fn process_canon_processing(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ToneCurve at offset 1

    // PictureStyle at offset 10

    // DigitalGain at offset 11

    // WBShiftAB at offset 12

    // WBShiftGM at offset 13

    // Sharpness at offset 2

    // SharpnessFrequency at offset 3

    // WhiteBalance at offset 8

    Ok(tags)
}

fn process_canon_colorbalance(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_RGGBLevelsAuto at offset 1
    if data.len() >= 10 {
        if let Ok(values) = read_int16s_array(&data[2..10], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsCloudy at offset 13
    if data.len() >= 34 {
        if let Ok(values) = read_int16s_array(&data[26..34], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 17
    if data.len() >= 42 {
        if let Ok(values) = read_int16s_array(&data[34..42], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 21
    if data.len() >= 50 {
        if let Ok(values) = read_int16s_array(&data[42..50], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 25
    if data.len() >= 58 {
        if let Ok(values) = read_int16s_array(&data[50..58], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsKelvin at offset 33
    if data.len() >= 74 {
        if let Ok(values) = read_int16s_array(&data[66..74], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBBlackLevels at offset 37
    if data.len() >= 82 {
        if let Ok(values) = read_int16s_array(&data[74..82], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBBlackLevels".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsDaylight at offset 5
    if data.len() >= 18 {
        if let Ok(values) = read_int16s_array(&data[10..18], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 9
    if data.len() >= 26 {
        if let Ok(values) = read_int16s_array(&data[18..26], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_measuredcolor(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MeasuredRGGB at offset 1
    if data.len() >= 8 {
        if let Ok(values) = read_int16u_array(&data[0..8], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("MeasuredRGGB".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_canon_flags(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_canon_modifiedinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ModifiedToneCurve at offset 1

    // ModifiedPictureStyle at offset 10

    // ModifiedDigitalGain at offset 11

    // ModifiedSharpness at offset 2

    // ModifiedSharpnessFreq at offset 3

    // ModifiedWhiteBalance at offset 8

    Ok(tags)
}

fn process_canon_previewimageinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PreviewQuality at offset 1

    // PreviewImageLength at offset 2

    // PreviewImageStart at offset 5

    Ok(tags)
}

fn process_canon_colorcalib2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CameraColorCalibration01 at offset 0
    if data.len() >= 10 {
        if let Ok(values) = read_int16s_array(&data[0..10], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration01".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration03 at offset 10
    if data.len() >= 30 {
        if let Ok(values) = read_int16s_array(&data[20..30], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration03".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration04 at offset 15
    if data.len() >= 40 {
        if let Ok(values) = read_int16s_array(&data[30..40], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration04".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration05 at offset 20
    if data.len() >= 50 {
        if let Ok(values) = read_int16s_array(&data[40..50], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration05".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration06 at offset 25
    if data.len() >= 60 {
        if let Ok(values) = read_int16s_array(&data[50..60], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration06".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration07 at offset 30
    if data.len() >= 70 {
        if let Ok(values) = read_int16s_array(&data[60..70], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration07".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration08 at offset 35
    if data.len() >= 80 {
        if let Ok(values) = read_int16s_array(&data[70..80], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration08".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration09 at offset 40
    if data.len() >= 90 {
        if let Ok(values) = read_int16s_array(&data[80..90], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration09".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration10 at offset 45
    if data.len() >= 100 {
        if let Ok(values) = read_int16s_array(&data[90..100], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration02 at offset 5
    if data.len() >= 20 {
        if let Ok(values) = read_int16s_array(&data[10..20], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration02".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration11 at offset 50
    if data.len() >= 110 {
        if let Ok(values) = read_int16s_array(&data[100..110], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration12 at offset 55
    if data.len() >= 120 {
        if let Ok(values) = read_int16s_array(&data[110..120], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration13 at offset 60
    if data.len() >= 130 {
        if let Ok(values) = read_int16s_array(&data[120..130], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration14 at offset 65
    if data.len() >= 140 {
        if let Ok(values) = read_int16s_array(&data[130..140], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // CameraColorCalibration15 at offset 70
    if data.len() >= 150 {
        if let Ok(values) = read_int16s_array(&data[140..150], byte_order, 5) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "CameraColorCalibration15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_sensorinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // BlackMaskLeftBorder at offset 9

    Ok(tags)
}

fn process_canon_colordata1(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_RGGBLevelsAsShot at offset 25
    if data.len() >= 58 {
        if let Ok(values) = read_int16s_array(&data[50..58], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsAuto at offset 30
    if data.len() >= 68 {
        if let Ok(values) = read_int16s_array(&data[60..68], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsDaylight at offset 35
    if data.len() >= 78 {
        if let Ok(values) = read_int16s_array(&data[70..78], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 40
    if data.len() >= 88 {
        if let Ok(values) = read_int16s_array(&data[80..88], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 45
    if data.len() >= 98 {
        if let Ok(values) = read_int16s_array(&data[90..98], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 50
    if data.len() >= 108 {
        if let Ok(values) = read_int16s_array(&data[100..108], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 55
    if data.len() >= 118 {
        if let Ok(values) = read_int16s_array(&data[110..118], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 60
    if data.len() >= 128 {
        if let Ok(values) = read_int16s_array(&data[120..128], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCustom1 at offset 65
    if data.len() >= 138 {
        if let Ok(values) = read_int16s_array(&data[130..138], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCustom1".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCustom2 at offset 70
    if data.len() >= 148 {
        if let Ok(values) = read_int16s_array(&data[140..148], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCustom2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorCalib at offset 75
    if data.len() >= 390 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_canon_colordata2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorTempUnknown7 at offset 103

    // WB_RGGBLevelsUnknown8 at offset 104
    if data.len() >= 216 {
        if let Ok(values) = read_int16s_array(&data[208..216], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown8 at offset 108

    // WB_RGGBLevelsUnknown9 at offset 109
    if data.len() >= 226 {
        if let Ok(values) = read_int16s_array(&data[218..226], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown9 at offset 113

    // WB_RGGBLevelsUnknown10 at offset 114
    if data.len() >= 236 {
        if let Ok(values) = read_int16s_array(&data[228..236], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown10 at offset 118

    // WB_RGGBLevelsUnknown11 at offset 119
    if data.len() >= 246 {
        if let Ok(values) = read_int16s_array(&data[238..246], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 123

    // WB_RGGBLevelsUnknown12 at offset 124
    if data.len() >= 256 {
        if let Ok(values) = read_int16s_array(&data[248..256], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown12 at offset 128

    // WB_RGGBLevelsUnknown13 at offset 129
    if data.len() >= 266 {
        if let Ok(values) = read_int16s_array(&data[258..266], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown13 at offset 133

    // WB_RGGBLevelsUnknown14 at offset 134
    if data.len() >= 276 {
        if let Ok(values) = read_int16s_array(&data[268..276], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown14 at offset 138

    // WB_RGGBLevelsUnknown15 at offset 139
    if data.len() >= 286 {
        if let Ok(values) = read_int16s_array(&data[278..286], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown15 at offset 143

    // WB_RGGBLevelsPC1 at offset 144
    if data.len() >= 296 {
        if let Ok(values) = read_int16s_array(&data[288..296], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsPC1".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsPC2 at offset 149
    if data.len() >= 306 {
        if let Ok(values) = read_int16s_array(&data[298..306], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsPC2".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsPC3 at offset 154
    if data.len() >= 316 {
        if let Ok(values) = read_int16s_array(&data[308..316], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsPC3".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsUnknown16 at offset 159
    if data.len() >= 326 {
        if let Ok(values) = read_int16s_array(&data[318..326], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown16".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown16 at offset 163

    // ColorCalib at offset 164
    if data.len() >= 568 {
        // TODO: Handle format undef
    }

    // WB_RGGBLevelsAuto at offset 24
    if data.len() >= 56 {
        if let Ok(values) = read_int16s_array(&data[48..56], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsUnknown at offset 29
    if data.len() >= 66 {
        if let Ok(values) = read_int16s_array(&data[58..66], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown at offset 33

    // WB_RGGBLevelsAsShot at offset 34
    if data.len() >= 76 {
        if let Ok(values) = read_int16s_array(&data[68..76], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsDaylight at offset 39
    if data.len() >= 86 {
        if let Ok(values) = read_int16s_array(&data[78..86], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 44
    if data.len() >= 96 {
        if let Ok(values) = read_int16s_array(&data[88..96], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 49
    if data.len() >= 106 {
        if let Ok(values) = read_int16s_array(&data[98..106], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 54
    if data.len() >= 116 {
        if let Ok(values) = read_int16s_array(&data[108..116], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 59
    if data.len() >= 126 {
        if let Ok(values) = read_int16s_array(&data[118..126], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // RawMeasuredRGGB at offset 618
    if data.len() >= 1252 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsKelvin at offset 64
    if data.len() >= 136 {
        if let Ok(values) = read_int16s_array(&data[128..136], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 69
    if data.len() >= 146 {
        if let Ok(values) = read_int16s_array(&data[138..146], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown2 at offset 74
    if data.len() >= 156 {
        if let Ok(values) = read_int16s_array(&data[148..156], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown2 at offset 78

    // WB_RGGBLevelsUnknown3 at offset 79
    if data.len() >= 166 {
        if let Ok(values) = read_int16s_array(&data[158..166], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown3 at offset 83

    // WB_RGGBLevelsUnknown4 at offset 84
    if data.len() >= 176 {
        if let Ok(values) = read_int16s_array(&data[168..176], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown4 at offset 88

    // WB_RGGBLevelsUnknown5 at offset 89
    if data.len() >= 186 {
        if let Ok(values) = read_int16s_array(&data[178..186], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown5 at offset 93

    // WB_RGGBLevelsUnknown6 at offset 94
    if data.len() >= 196 {
        if let Ok(values) = read_int16s_array(&data[188..196], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown6 at offset 98

    // WB_RGGBLevelsUnknown7 at offset 99
    if data.len() >= 206 {
        if let Ok(values) = read_int16s_array(&data[198..206], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_colordata3(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorDataVersion at offset 0

    // WB_RGGBLevelsKelvin at offset 103
    if data.len() >= 214 {
        if let Ok(values) = read_int16s_array(&data[206..214], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 108
    if data.len() >= 224 {
        if let Ok(values) = read_int16s_array(&data[216..224], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsPC1 at offset 113
    if data.len() >= 234 {
        if let Ok(values) = read_int16s_array(&data[226..234], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsPC1".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsPC2 at offset 118
    if data.len() >= 244 {
        if let Ok(values) = read_int16s_array(&data[236..244], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsPC2".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsPC3 at offset 123
    if data.len() >= 254 {
        if let Ok(values) = read_int16s_array(&data[246..254], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsPC3".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsCustom at offset 128
    if data.len() >= 264 {
        if let Ok(values) = read_int16s_array(&data[256..264], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCustom".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorCalib at offset 133
    if data.len() >= 506 {
        // TODO: Handle format undef
    }

    // PerChannelBlackLevel at offset 196
    if data.len() >= 400 {
        if let Ok(values) = read_int16u_array(&data[392..400], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FlashOutput at offset 584

    // FlashBatteryLevel at offset 585

    // ColorTempFlashData at offset 586

    // WB_RGGBLevelsAsShot at offset 63
    if data.len() >= 134 {
        if let Ok(values) = read_int16s_array(&data[126..134], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // MeasuredRGGBData at offset 647
    if data.len() >= 1310 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsAuto at offset 68
    if data.len() >= 144 {
        if let Ok(values) = read_int16s_array(&data[136..144], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsMeasured at offset 73
    if data.len() >= 154 {
        if let Ok(values) = read_int16s_array(&data[146..154], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsMeasured".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsDaylight at offset 78
    if data.len() >= 164 {
        if let Ok(values) = read_int16s_array(&data[156..164], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 83
    if data.len() >= 174 {
        if let Ok(values) = read_int16s_array(&data[166..174], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 88
    if data.len() >= 184 {
        if let Ok(values) = read_int16s_array(&data[176..184], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 93
    if data.len() >= 194 {
        if let Ok(values) = read_int16s_array(&data[186..194], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 98
    if data.len() >= 204 {
        if let Ok(values) = read_int16s_array(&data[196..204], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_colordata4(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorDataVersion at offset 0

    // ColorCalib at offset 168
    if data.len() >= 576 {
        // TODO: Handle format undef
    }

    // AverageBlackLevel at offset 231
    if data.len() >= 470 {
        if let Ok(values) = read_int16u_array(&data[462..470], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("AverageBlackLevel".to_string(), TagValue::String(value_str)));
        }
    }

    // ColorCoefs at offset 63
    if data.len() >= 546 {
        // TODO: Handle format undef
    }

    // RawMeasuredRGGB at offset 640
    if data.len() >= 1296 {
        // TODO: Handle format int32u
    }

    // PerChannelBlackLevel at offset 692
    if data.len() >= 1392 {
        if let Ok(values) = read_int16u_array(&data[1384..1392], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // NormalWhiteLevel at offset 696
    if data.len() >= 1394 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 697
    if data.len() >= 1396 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 698
    if data.len() >= 1398 {
        // TODO: Handle format int16u
    }

    // PerChannelBlackLevel at offset 715
    if data.len() >= 1438 {
        if let Ok(values) = read_int16u_array(&data[1430..1438], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // SpecularWhiteLevel at offset 720
    if data.len() >= 1442 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 721
    if data.len() >= 1444 {
        // TODO: Handle format int16u
    }

    // NormalWhiteLevel at offset 723
    if data.len() >= 1448 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 724
    if data.len() >= 1450 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 725
    if data.len() >= 1452 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_canon_colordata5(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorDataVersion at offset 0

    // NormalWhiteLevel at offset 1385
    if data.len() >= 2772 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 1386
    if data.len() >= 2774 {
        // TODO: Handle format int16u
    }

    // ColorCalib2 at offset 186
    if data.len() >= 672 {
        // TODO: Handle format undef
    }

    // ColorCalib2 at offset 255
    if data.len() >= 810 {
        // TODO: Handle format undef
    }

    // PerChannelBlackLevel at offset 264
    if data.len() >= 536 {
        if let Ok(values) = read_int16s_array(&data[528..536], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // PerChannelBlackLevel at offset 333
    if data.len() >= 674 {
        if let Ok(values) = read_int16s_array(&data[666..674], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // SpecularWhiteLevel at offset 662
    if data.len() >= 1326 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_canon_colordata6(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorDataVersion at offset 0

    // ColorTempUnknown5 at offset 102

    // WB_RGGBLevelsDaylight at offset 103
    if data.len() >= 214 {
        if let Ok(values) = read_int16s_array(&data[206..214], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 108
    if data.len() >= 224 {
        if let Ok(values) = read_int16s_array(&data[216..224], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 113
    if data.len() >= 234 {
        if let Ok(values) = read_int16s_array(&data[226..234], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 118
    if data.len() >= 244 {
        if let Ok(values) = read_int16s_array(&data[236..244], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 123
    if data.len() >= 254 {
        if let Ok(values) = read_int16s_array(&data[246..254], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsKelvin at offset 128
    if data.len() >= 264 {
        if let Ok(values) = read_int16s_array(&data[256..264], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 133
    if data.len() >= 274 {
        if let Ok(values) = read_int16s_array(&data[266..274], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown6 at offset 138
    if data.len() >= 284 {
        if let Ok(values) = read_int16s_array(&data[276..284], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown6 at offset 142

    // WB_RGGBLevelsUnknown7 at offset 143
    if data.len() >= 294 {
        if let Ok(values) = read_int16s_array(&data[286..294], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown7 at offset 147

    // WB_RGGBLevelsUnknown8 at offset 148
    if data.len() >= 304 {
        if let Ok(values) = read_int16s_array(&data[296..304], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown8 at offset 152

    // WB_RGGBLevelsUnknown9 at offset 153
    if data.len() >= 314 {
        if let Ok(values) = read_int16s_array(&data[306..314], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown9 at offset 157

    // WB_RGGBLevelsUnknown10 at offset 158
    if data.len() >= 324 {
        if let Ok(values) = read_int16s_array(&data[316..324], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown10 at offset 162

    // WB_RGGBLevelsUnknown11 at offset 163
    if data.len() >= 334 {
        if let Ok(values) = read_int16s_array(&data[326..334], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 167

    // WB_RGGBLevelsUnknown12 at offset 168
    if data.len() >= 344 {
        if let Ok(values) = read_int16s_array(&data[336..344], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown12 at offset 172

    // WB_RGGBLevelsUnknown13 at offset 173
    if data.len() >= 354 {
        if let Ok(values) = read_int16s_array(&data[346..354], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown13 at offset 177

    // WB_RGGBLevelsUnknown14 at offset 178
    if data.len() >= 364 {
        if let Ok(values) = read_int16s_array(&data[356..364], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown14 at offset 182

    // WB_RGGBLevelsUnknown15 at offset 183
    if data.len() >= 374 {
        if let Ok(values) = read_int16s_array(&data[366..374], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown15 at offset 187

    // ColorCalib at offset 188
    if data.len() >= 616 {
        // TODO: Handle format undef
    }

    // AverageBlackLevel at offset 251
    if data.len() >= 510 {
        if let Ok(values) = read_int16u_array(&data[502..510], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("AverageBlackLevel".to_string(), TagValue::String(value_str)));
        }
    }

    // RawMeasuredRGGB at offset 404
    if data.len() >= 824 {
        // TODO: Handle format int32u
    }

    // PerChannelBlackLevel at offset 479
    if data.len() >= 966 {
        if let Ok(values) = read_int16u_array(&data[958..966], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // NormalWhiteLevel at offset 483
    if data.len() >= 968 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 484
    if data.len() >= 970 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 485
    if data.len() >= 972 {
        // TODO: Handle format int16u
    }

    // WB_RGGBLevelsAsShot at offset 63
    if data.len() >= 134 {
        if let Ok(values) = read_int16s_array(&data[126..134], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsAuto at offset 68
    if data.len() >= 144 {
        if let Ok(values) = read_int16s_array(&data[136..144], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsMeasured at offset 73
    if data.len() >= 154 {
        if let Ok(values) = read_int16s_array(&data[146..154], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsMeasured".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown at offset 78
    if data.len() >= 164 {
        if let Ok(values) = read_int16s_array(&data[156..164], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown at offset 82

    // WB_RGGBLevelsUnknown2 at offset 83
    if data.len() >= 174 {
        if let Ok(values) = read_int16s_array(&data[166..174], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown2 at offset 87

    // WB_RGGBLevelsUnknown3 at offset 88
    if data.len() >= 184 {
        if let Ok(values) = read_int16s_array(&data[176..184], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown3 at offset 92

    // WB_RGGBLevelsUnknown4 at offset 93
    if data.len() >= 194 {
        if let Ok(values) = read_int16s_array(&data[186..194], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown4 at offset 97

    // WB_RGGBLevelsUnknown5 at offset 98
    if data.len() >= 204 {
        if let Ok(values) = read_int16s_array(&data[196..204], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_colordata7(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorDataVersion at offset 0

    // ColorTempUnknown5 at offset 102

    // WB_RGGBLevelsUnknown6 at offset 103
    if data.len() >= 214 {
        if let Ok(values) = read_int16s_array(&data[206..214], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown6 at offset 107

    // WB_RGGBLevelsUnknown7 at offset 108
    if data.len() >= 224 {
        if let Ok(values) = read_int16s_array(&data[216..224], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown7 at offset 112

    // WB_RGGBLevelsUnknown8 at offset 113
    if data.len() >= 234 {
        if let Ok(values) = read_int16s_array(&data[226..234], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown8 at offset 117

    // WB_RGGBLevelsUnknown9 at offset 118
    if data.len() >= 244 {
        if let Ok(values) = read_int16s_array(&data[236..244], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown9 at offset 122

    // WB_RGGBLevelsUnknown10 at offset 123
    if data.len() >= 254 {
        if let Ok(values) = read_int16s_array(&data[246..254], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown10 at offset 127

    // WB_RGGBLevelsDaylight at offset 128
    if data.len() >= 264 {
        if let Ok(values) = read_int16s_array(&data[256..264], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 133
    if data.len() >= 274 {
        if let Ok(values) = read_int16s_array(&data[266..274], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 138
    if data.len() >= 284 {
        if let Ok(values) = read_int16s_array(&data[276..284], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 143
    if data.len() >= 294 {
        if let Ok(values) = read_int16s_array(&data[286..294], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 148
    if data.len() >= 304 {
        if let Ok(values) = read_int16s_array(&data[296..304], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsKelvin at offset 153
    if data.len() >= 314 {
        if let Ok(values) = read_int16s_array(&data[306..314], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 158
    if data.len() >= 324 {
        if let Ok(values) = read_int16s_array(&data[316..324], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown11 at offset 163
    if data.len() >= 334 {
        if let Ok(values) = read_int16s_array(&data[326..334], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 167

    // WB_RGGBLevelsUnknown12 at offset 168
    if data.len() >= 344 {
        if let Ok(values) = read_int16s_array(&data[336..344], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown12 at offset 172

    // WB_RGGBLevelsUnknown13 at offset 173
    if data.len() >= 354 {
        if let Ok(values) = read_int16s_array(&data[346..354], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown13 at offset 177

    // WB_RGGBLevelsUnknown14 at offset 178
    if data.len() >= 364 {
        if let Ok(values) = read_int16s_array(&data[356..364], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown14 at offset 182

    // WB_RGGBLevelsUnknown15 at offset 183
    if data.len() >= 374 {
        if let Ok(values) = read_int16s_array(&data[366..374], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown15 at offset 187

    // WB_RGGBLevelsUnknown16 at offset 188
    if data.len() >= 384 {
        if let Ok(values) = read_int16s_array(&data[376..384], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown16".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown16 at offset 192

    // WB_RGGBLevelsUnknown17 at offset 193
    if data.len() >= 394 {
        if let Ok(values) = read_int16s_array(&data[386..394], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown17".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown17 at offset 197

    // WB_RGGBLevelsUnknown18 at offset 198
    if data.len() >= 404 {
        if let Ok(values) = read_int16s_array(&data[396..404], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown18".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown18 at offset 202

    // WB_RGGBLevelsUnknown19 at offset 203
    if data.len() >= 414 {
        if let Ok(values) = read_int16s_array(&data[406..414], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown19".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown19 at offset 207

    // WB_RGGBLevelsUnknown20 at offset 208
    if data.len() >= 424 {
        if let Ok(values) = read_int16s_array(&data[416..424], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown20".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown20 at offset 212

    // ColorCalib at offset 213
    if data.len() >= 666 {
        // TODO: Handle format undef
    }

    // AverageBlackLevel at offset 276
    if data.len() >= 560 {
        if let Ok(values) = read_int16u_array(&data[552..560], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("AverageBlackLevel".to_string(), TagValue::String(value_str)));
        }
    }

    // RawMeasuredRGGB at offset 429
    if data.len() >= 874 {
        // TODO: Handle format int32u
    }

    // PerChannelBlackLevel at offset 504
    if data.len() >= 1016 {
        if let Ok(values) = read_int16u_array(&data[1008..1016], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // NormalWhiteLevel at offset 508
    if data.len() >= 1018 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 509
    if data.len() >= 1020 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 510
    if data.len() >= 1022 {
        // TODO: Handle format int16u
    }

    // RawMeasuredRGGB at offset 619
    if data.len() >= 1254 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsAsShot at offset 63
    if data.len() >= 134 {
        if let Ok(values) = read_int16s_array(&data[126..134], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsAuto at offset 68
    if data.len() >= 144 {
        if let Ok(values) = read_int16s_array(&data[136..144], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // PerChannelBlackLevel at offset 728
    if data.len() >= 1464 {
        if let Ok(values) = read_int16u_array(&data[1456..1464], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsMeasured at offset 73
    if data.len() >= 154 {
        if let Ok(values) = read_int16s_array(&data[146..154], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsMeasured".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // NormalWhiteLevel at offset 732
    if data.len() >= 1466 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 733
    if data.len() >= 1468 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 734
    if data.len() >= 1470 {
        // TODO: Handle format int16u
    }

    // WB_RGGBLevelsUnknown at offset 78
    if data.len() >= 164 {
        if let Ok(values) = read_int16s_array(&data[156..164], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown at offset 82

    // WB_RGGBLevelsUnknown2 at offset 83
    if data.len() >= 174 {
        if let Ok(values) = read_int16s_array(&data[166..174], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown2 at offset 87

    // WB_RGGBLevelsUnknown3 at offset 88
    if data.len() >= 184 {
        if let Ok(values) = read_int16s_array(&data[176..184], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown3 at offset 92

    // WB_RGGBLevelsUnknown4 at offset 93
    if data.len() >= 194 {
        if let Ok(values) = read_int16s_array(&data[186..194], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown4 at offset 97

    // WB_RGGBLevelsUnknown5 at offset 98
    if data.len() >= 204 {
        if let Ok(values) = read_int16s_array(&data[196..204], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_colordata8(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorDataVersion at offset 0

    // ColorTempUnknown5 at offset 102

    // WB_RGGBLevelsUnknown6 at offset 103
    if data.len() >= 214 {
        if let Ok(values) = read_int16s_array(&data[206..214], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown6 at offset 107

    // WB_RGGBLevelsUnknown7 at offset 108
    if data.len() >= 224 {
        if let Ok(values) = read_int16s_array(&data[216..224], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown7 at offset 112

    // WB_RGGBLevelsUnknown8 at offset 113
    if data.len() >= 234 {
        if let Ok(values) = read_int16s_array(&data[226..234], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown8 at offset 117

    // WB_RGGBLevelsUnknown9 at offset 118
    if data.len() >= 244 {
        if let Ok(values) = read_int16s_array(&data[236..244], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown9 at offset 122

    // WB_RGGBLevelsUnknown10 at offset 123
    if data.len() >= 254 {
        if let Ok(values) = read_int16s_array(&data[246..254], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown10 at offset 127

    // WB_RGGBLevelsUnknown11 at offset 128
    if data.len() >= 264 {
        if let Ok(values) = read_int16s_array(&data[256..264], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 132

    // WB_RGGBLevelsDaylight at offset 133
    if data.len() >= 274 {
        if let Ok(values) = read_int16s_array(&data[266..274], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 138
    if data.len() >= 284 {
        if let Ok(values) = read_int16s_array(&data[276..284], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 143
    if data.len() >= 294 {
        if let Ok(values) = read_int16s_array(&data[286..294], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 148
    if data.len() >= 304 {
        if let Ok(values) = read_int16s_array(&data[296..304], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 153
    if data.len() >= 314 {
        if let Ok(values) = read_int16s_array(&data[306..314], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsKelvin at offset 158
    if data.len() >= 324 {
        if let Ok(values) = read_int16s_array(&data[316..324], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 163
    if data.len() >= 334 {
        if let Ok(values) = read_int16s_array(&data[326..334], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown12 at offset 168
    if data.len() >= 344 {
        if let Ok(values) = read_int16s_array(&data[336..344], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown12 at offset 172

    // WB_RGGBLevelsUnknown13 at offset 173
    if data.len() >= 354 {
        if let Ok(values) = read_int16s_array(&data[346..354], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown13 at offset 177

    // WB_RGGBLevelsUnknown14 at offset 178
    if data.len() >= 364 {
        if let Ok(values) = read_int16s_array(&data[356..364], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown14 at offset 182

    // WB_RGGBLevelsUnknown15 at offset 183
    if data.len() >= 374 {
        if let Ok(values) = read_int16s_array(&data[366..374], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown15 at offset 187

    // WB_RGGBLevelsUnknown16 at offset 188
    if data.len() >= 384 {
        if let Ok(values) = read_int16s_array(&data[376..384], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown16".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown16 at offset 192

    // WB_RGGBLevelsUnknown17 at offset 193
    if data.len() >= 394 {
        if let Ok(values) = read_int16s_array(&data[386..394], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown17".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown17 at offset 197

    // WB_RGGBLevelsUnknown18 at offset 198
    if data.len() >= 404 {
        if let Ok(values) = read_int16s_array(&data[396..404], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown18".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown18 at offset 202

    // WB_RGGBLevelsUnknown19 at offset 203
    if data.len() >= 414 {
        if let Ok(values) = read_int16s_array(&data[406..414], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown19".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown19 at offset 207

    // WB_RGGBLevelsUnknown20 at offset 208
    if data.len() >= 424 {
        if let Ok(values) = read_int16s_array(&data[416..424], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown20".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown20 at offset 212

    // WB_RGGBLevelsUnknown21 at offset 213
    if data.len() >= 434 {
        if let Ok(values) = read_int16s_array(&data[426..434], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown21".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown21 at offset 217

    // WB_RGGBLevelsUnknown22 at offset 218
    if data.len() >= 444 {
        if let Ok(values) = read_int16s_array(&data[436..444], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown22".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown22 at offset 222

    // WB_RGGBLevelsUnknown23 at offset 223
    if data.len() >= 454 {
        if let Ok(values) = read_int16s_array(&data[446..454], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown23".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown23 at offset 227

    // WB_RGGBLevelsUnknown24 at offset 228
    if data.len() >= 464 {
        if let Ok(values) = read_int16s_array(&data[456..464], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown24".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown24 at offset 232

    // WB_RGGBLevelsUnknown25 at offset 233
    if data.len() >= 474 {
        if let Ok(values) = read_int16s_array(&data[466..474], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown25".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown25 at offset 237

    // WB_RGGBLevelsUnknown26 at offset 238
    if data.len() >= 484 {
        if let Ok(values) = read_int16s_array(&data[476..484], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown26".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown26 at offset 242

    // WB_RGGBLevelsUnknown27 at offset 243
    if data.len() >= 494 {
        if let Ok(values) = read_int16s_array(&data[486..494], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown27".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown27 at offset 247

    // WB_RGGBLevelsUnknown28 at offset 248
    if data.len() >= 504 {
        if let Ok(values) = read_int16s_array(&data[496..504], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown28".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown28 at offset 252

    // WB_RGGBLevelsUnknown29 at offset 253
    if data.len() >= 514 {
        if let Ok(values) = read_int16s_array(&data[506..514], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown29".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown29 at offset 257

    // WB_RGGBLevelsUnknown30 at offset 258
    if data.len() >= 524 {
        if let Ok(values) = read_int16s_array(&data[516..524], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown30".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown30 at offset 262

    // ColorCalib at offset 263
    if data.len() >= 766 {
        // TODO: Handle format undef
    }

    // AverageBlackLevel at offset 326
    if data.len() >= 660 {
        if let Ok(values) = read_int16u_array(&data[652..660], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("AverageBlackLevel".to_string(), TagValue::String(value_str)));
        }
    }

    // PerChannelBlackLevel at offset 556
    if data.len() >= 1120 {
        if let Ok(values) = read_int16u_array(&data[1112..1120], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // NormalWhiteLevel at offset 560
    if data.len() >= 1122 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 561
    if data.len() >= 1124 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 562
    if data.len() >= 1126 {
        // TODO: Handle format int16u
    }

    // WB_RGGBLevelsAsShot at offset 63
    if data.len() >= 134 {
        if let Ok(values) = read_int16s_array(&data[126..134], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsAuto at offset 68
    if data.len() >= 144 {
        if let Ok(values) = read_int16s_array(&data[136..144], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsMeasured at offset 73
    if data.len() >= 154 {
        if let Ok(values) = read_int16s_array(&data[146..154], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsMeasured".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // PerChannelBlackLevel at offset 778
    if data.len() >= 1564 {
        if let Ok(values) = read_int16u_array(&data[1556..1564], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown at offset 78
    if data.len() >= 164 {
        if let Ok(values) = read_int16s_array(&data[156..164], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // NormalWhiteLevel at offset 782
    if data.len() >= 1566 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 783
    if data.len() >= 1568 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 784
    if data.len() >= 1570 {
        // TODO: Handle format int16u
    }

    // ColorTempUnknown at offset 82

    // WB_RGGBLevelsUnknown2 at offset 83
    if data.len() >= 174 {
        if let Ok(values) = read_int16s_array(&data[166..174], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown2 at offset 87

    // WB_RGGBLevelsUnknown3 at offset 88
    if data.len() >= 184 {
        if let Ok(values) = read_int16s_array(&data[176..184], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown3 at offset 92

    // WB_RGGBLevelsUnknown4 at offset 93
    if data.len() >= 194 {
        if let Ok(values) = read_int16s_array(&data[186..194], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown4 at offset 97

    // WB_RGGBLevelsUnknown5 at offset 98
    if data.len() >= 204 {
        if let Ok(values) = read_int16s_array(&data[196..204], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_colordata9(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorDataVersion at offset 0

    // ColorTempUnknown3 at offset 100

    // WB_RGGBLevelsUnknown4 at offset 101
    if data.len() >= 210 {
        if let Ok(values) = read_int16s_array(&data[202..210], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown4 at offset 105

    // WB_RGGBLevelsUnknown5 at offset 106
    if data.len() >= 220 {
        if let Ok(values) = read_int16s_array(&data[212..220], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown5 at offset 110

    // WB_RGGBLevelsUnknown6 at offset 111
    if data.len() >= 230 {
        if let Ok(values) = read_int16s_array(&data[222..230], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown6 at offset 115

    // WB_RGGBLevelsUnknown7 at offset 116
    if data.len() >= 240 {
        if let Ok(values) = read_int16s_array(&data[232..240], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown7 at offset 120

    // WB_RGGBLevelsUnknown8 at offset 121
    if data.len() >= 250 {
        if let Ok(values) = read_int16s_array(&data[242..250], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown8 at offset 125

    // WB_RGGBLevelsUnknown9 at offset 126
    if data.len() >= 260 {
        if let Ok(values) = read_int16s_array(&data[252..260], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown9 at offset 130

    // WB_RGGBLevelsUnknown10 at offset 131
    if data.len() >= 270 {
        if let Ok(values) = read_int16s_array(&data[262..270], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown10 at offset 135

    // WB_RGGBLevelsDaylight at offset 136
    if data.len() >= 280 {
        if let Ok(values) = read_int16s_array(&data[272..280], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 141
    if data.len() >= 290 {
        if let Ok(values) = read_int16s_array(&data[282..290], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 146
    if data.len() >= 300 {
        if let Ok(values) = read_int16s_array(&data[292..300], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 151
    if data.len() >= 310 {
        if let Ok(values) = read_int16s_array(&data[302..310], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 156
    if data.len() >= 320 {
        if let Ok(values) = read_int16s_array(&data[312..320], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsKelvin at offset 161
    if data.len() >= 330 {
        if let Ok(values) = read_int16s_array(&data[322..330], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 166
    if data.len() >= 340 {
        if let Ok(values) = read_int16s_array(&data[332..340], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown11 at offset 171
    if data.len() >= 350 {
        if let Ok(values) = read_int16s_array(&data[342..350], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 175

    // WB_RGGBLevelsUnknown12 at offset 176
    if data.len() >= 360 {
        if let Ok(values) = read_int16s_array(&data[352..360], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown12 at offset 180

    // WB_RGGBLevelsUnknown13 at offset 181
    if data.len() >= 370 {
        if let Ok(values) = read_int16s_array(&data[362..370], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown13 at offset 185

    // WB_RGGBLevelsUnknown14 at offset 186
    if data.len() >= 380 {
        if let Ok(values) = read_int16s_array(&data[372..380], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown14 at offset 190

    // WB_RGGBLevelsUnknown15 at offset 191
    if data.len() >= 390 {
        if let Ok(values) = read_int16s_array(&data[382..390], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown15 at offset 195

    // WB_RGGBLevelsUnknown16 at offset 196
    if data.len() >= 400 {
        if let Ok(values) = read_int16s_array(&data[392..400], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown16".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown16 at offset 200

    // WB_RGGBLevelsUnknown17 at offset 201
    if data.len() >= 410 {
        if let Ok(values) = read_int16s_array(&data[402..410], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown17".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown17 at offset 205

    // WB_RGGBLevelsUnknown18 at offset 206
    if data.len() >= 420 {
        if let Ok(values) = read_int16s_array(&data[412..420], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown18".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown18 at offset 210

    // WB_RGGBLevelsUnknown19 at offset 211
    if data.len() >= 430 {
        if let Ok(values) = read_int16s_array(&data[422..430], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown19".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown19 at offset 215

    // WB_RGGBLevelsUnknown20 at offset 216
    if data.len() >= 440 {
        if let Ok(values) = read_int16s_array(&data[432..440], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown20".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown20 at offset 220

    // WB_RGGBLevelsUnknown21 at offset 221
    if data.len() >= 450 {
        if let Ok(values) = read_int16s_array(&data[442..450], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown21".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown21 at offset 225

    // WB_RGGBLevelsUnknown22 at offset 226
    if data.len() >= 460 {
        if let Ok(values) = read_int16s_array(&data[452..460], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown22".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown22 at offset 230

    // WB_RGGBLevelsUnknown23 at offset 231
    if data.len() >= 470 {
        if let Ok(values) = read_int16s_array(&data[462..470], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown23".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown23 at offset 235

    // WB_RGGBLevelsUnknown24 at offset 236
    if data.len() >= 480 {
        if let Ok(values) = read_int16s_array(&data[472..480], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown24".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown24 at offset 240

    // WB_RGGBLevelsUnknown25 at offset 241
    if data.len() >= 490 {
        if let Ok(values) = read_int16s_array(&data[482..490], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown25".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown25 at offset 245

    // WB_RGGBLevelsUnknown26 at offset 246
    if data.len() >= 500 {
        if let Ok(values) = read_int16s_array(&data[492..500], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown26".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown26 at offset 250

    // WB_RGGBLevelsUnknown27 at offset 251
    if data.len() >= 510 {
        if let Ok(values) = read_int16s_array(&data[502..510], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown27".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown27 at offset 255

    // WB_RGGBLevelsUnknown28 at offset 256
    if data.len() >= 520 {
        if let Ok(values) = read_int16s_array(&data[512..520], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown28".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown28 at offset 260

    // WB_RGGBLevelsUnknown29 at offset 261
    if data.len() >= 530 {
        if let Ok(values) = read_int16s_array(&data[522..530], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown29".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown29 at offset 265

    // ColorCalib at offset 266
    if data.len() >= 772 {
        // TODO: Handle format undef
    }

    // PerChannelBlackLevel at offset 329
    if data.len() >= 666 {
        if let Ok(values) = read_int16u_array(&data[658..666], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsAsShot at offset 71
    if data.len() >= 150 {
        if let Ok(values) = read_int16s_array(&data[142..150], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsAuto at offset 76
    if data.len() >= 160 {
        if let Ok(values) = read_int16s_array(&data[152..160], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // NormalWhiteLevel at offset 796
    if data.len() >= 1594 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 797
    if data.len() >= 1596 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 798
    if data.len() >= 1598 {
        // TODO: Handle format int16u
    }

    // WB_RGGBLevelsMeasured at offset 81
    if data.len() >= 170 {
        if let Ok(values) = read_int16s_array(&data[162..170], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsMeasured".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown at offset 86
    if data.len() >= 180 {
        if let Ok(values) = read_int16s_array(&data[172..180], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown at offset 90

    // WB_RGGBLevelsUnknown2 at offset 91
    if data.len() >= 190 {
        if let Ok(values) = read_int16s_array(&data[182..190], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown2 at offset 95

    // WB_RGGBLevelsUnknown3 at offset 96
    if data.len() >= 200 {
        if let Ok(values) = read_int16s_array(&data[192..200], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_colordata10(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorDataVersion at offset 0

    // WB_RGGBLevelsUnknown at offset 100
    if data.len() >= 208 {
        if let Ok(values) = read_int16s_array(&data[200..208], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown at offset 104

    // WB_RGGBLevelsUnknown2 at offset 105
    if data.len() >= 218 {
        if let Ok(values) = read_int16s_array(&data[210..218], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown2 at offset 109

    // WB_RGGBLevelsUnknown3 at offset 110
    if data.len() >= 228 {
        if let Ok(values) = read_int16s_array(&data[220..228], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown3 at offset 114

    // WB_RGGBLevelsUnknown4 at offset 115
    if data.len() >= 238 {
        if let Ok(values) = read_int16s_array(&data[230..238], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown4 at offset 119

    // WB_RGGBLevelsUnknown5 at offset 120
    if data.len() >= 248 {
        if let Ok(values) = read_int16s_array(&data[240..248], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown5 at offset 124

    // WB_RGGBLevelsUnknown6 at offset 125
    if data.len() >= 258 {
        if let Ok(values) = read_int16s_array(&data[250..258], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown6 at offset 129

    // WB_RGGBLevelsUnknown7 at offset 130
    if data.len() >= 268 {
        if let Ok(values) = read_int16s_array(&data[260..268], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown7 at offset 134

    // WB_RGGBLevelsUnknown8 at offset 135
    if data.len() >= 278 {
        if let Ok(values) = read_int16s_array(&data[270..278], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown8 at offset 139

    // WB_RGGBLevelsUnknown9 at offset 140
    if data.len() >= 288 {
        if let Ok(values) = read_int16s_array(&data[280..288], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown9 at offset 144

    // WB_RGGBLevelsUnknown10 at offset 145
    if data.len() >= 298 {
        if let Ok(values) = read_int16s_array(&data[290..298], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown10 at offset 149

    // WB_RGGBLevelsDaylight at offset 150
    if data.len() >= 308 {
        if let Ok(values) = read_int16s_array(&data[300..308], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 155
    if data.len() >= 318 {
        if let Ok(values) = read_int16s_array(&data[310..318], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 160
    if data.len() >= 328 {
        if let Ok(values) = read_int16s_array(&data[320..328], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 165
    if data.len() >= 338 {
        if let Ok(values) = read_int16s_array(&data[330..338], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 170
    if data.len() >= 348 {
        if let Ok(values) = read_int16s_array(&data[340..348], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsKelvin at offset 175
    if data.len() >= 358 {
        if let Ok(values) = read_int16s_array(&data[350..358], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 180
    if data.len() >= 368 {
        if let Ok(values) = read_int16s_array(&data[360..368], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown11 at offset 185
    if data.len() >= 378 {
        if let Ok(values) = read_int16s_array(&data[370..378], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 189

    // WB_RGGBLevelsUnknown12 at offset 190
    if data.len() >= 388 {
        if let Ok(values) = read_int16s_array(&data[380..388], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown12 at offset 194

    // WB_RGGBLevelsUnknown13 at offset 195
    if data.len() >= 398 {
        if let Ok(values) = read_int16s_array(&data[390..398], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown13 at offset 199

    // WB_RGGBLevelsUnknown14 at offset 200
    if data.len() >= 408 {
        if let Ok(values) = read_int16s_array(&data[400..408], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown14 at offset 204

    // WB_RGGBLevelsUnknown15 at offset 205
    if data.len() >= 418 {
        if let Ok(values) = read_int16s_array(&data[410..418], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown15 at offset 209

    // WB_RGGBLevelsUnknown16 at offset 210
    if data.len() >= 428 {
        if let Ok(values) = read_int16s_array(&data[420..428], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown16".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown16 at offset 214

    // WB_RGGBLevelsUnknown17 at offset 215
    if data.len() >= 438 {
        if let Ok(values) = read_int16s_array(&data[430..438], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown17".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown17 at offset 219

    // WB_RGGBLevelsUnknown18 at offset 220
    if data.len() >= 448 {
        if let Ok(values) = read_int16s_array(&data[440..448], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown18".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown18 at offset 224

    // WB_RGGBLevelsUnknown19 at offset 225
    if data.len() >= 458 {
        if let Ok(values) = read_int16s_array(&data[450..458], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown19".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown19 at offset 229

    // WB_RGGBLevelsUnknown20 at offset 230
    if data.len() >= 468 {
        if let Ok(values) = read_int16s_array(&data[460..468], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown20".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown20 at offset 234

    // WB_RGGBLevelsUnknown21 at offset 235
    if data.len() >= 478 {
        if let Ok(values) = read_int16s_array(&data[470..478], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown21".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown21 at offset 239

    // WB_RGGBLevelsUnknown22 at offset 240
    if data.len() >= 488 {
        if let Ok(values) = read_int16s_array(&data[480..488], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown22".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown22 at offset 244

    // WB_RGGBLevelsUnknown23 at offset 245
    if data.len() >= 498 {
        if let Ok(values) = read_int16s_array(&data[490..498], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown23".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown23 at offset 249

    // WB_RGGBLevelsUnknown24 at offset 250
    if data.len() >= 508 {
        if let Ok(values) = read_int16s_array(&data[500..508], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown24".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown24 at offset 254

    // WB_RGGBLevelsUnknown25 at offset 255
    if data.len() >= 518 {
        if let Ok(values) = read_int16s_array(&data[510..518], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown25".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown25 at offset 259

    // WB_RGGBLevelsUnknown26 at offset 260
    if data.len() >= 528 {
        if let Ok(values) = read_int16s_array(&data[520..528], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown26".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown26 at offset 264

    // WB_RGGBLevelsUnknown27 at offset 265
    if data.len() >= 538 {
        if let Ok(values) = read_int16s_array(&data[530..538], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown27".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown27 at offset 269

    // WB_RGGBLevelsUnknown28 at offset 270
    if data.len() >= 548 {
        if let Ok(values) = read_int16s_array(&data[540..548], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown28".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown28 at offset 274

    // WB_RGGBLevelsUnknown29 at offset 275
    if data.len() >= 558 {
        if let Ok(values) = read_int16s_array(&data[550..558], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown29".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown29 at offset 279

    // ColorCalib at offset 280
    if data.len() >= 800 {
        // TODO: Handle format undef
    }

    // PerChannelBlackLevel at offset 343
    if data.len() >= 694 {
        if let Ok(values) = read_int16u_array(&data[686..694], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // NormalWhiteLevel at offset 810
    if data.len() >= 1622 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 811
    if data.len() >= 1624 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 812
    if data.len() >= 1626 {
        // TODO: Handle format int16u
    }

    // WB_RGGBLevelsAsShot at offset 85
    if data.len() >= 178 {
        if let Ok(values) = read_int16s_array(&data[170..178], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsAuto at offset 90
    if data.len() >= 188 {
        if let Ok(values) = read_int16s_array(&data[180..188], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsMeasured at offset 95
    if data.len() >= 198 {
        if let Ok(values) = read_int16s_array(&data[190..198], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsMeasured".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_canon_colordata11(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorDataVersion at offset 0

    // WB_RGGBLevelsAsShot at offset 105
    if data.len() >= 218 {
        if let Ok(values) = read_int16s_array(&data[210..218], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsAuto at offset 110
    if data.len() >= 228 {
        if let Ok(values) = read_int16s_array(&data[220..228], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RGGBLevelsMeasured at offset 115
    if data.len() >= 238 {
        if let Ok(values) = read_int16s_array(&data[230..238], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsMeasured".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown at offset 120
    if data.len() >= 248 {
        if let Ok(values) = read_int16s_array(&data[240..248], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown at offset 124

    // WB_RGGBLevelsUnknown2 at offset 125
    if data.len() >= 258 {
        if let Ok(values) = read_int16s_array(&data[250..258], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown2 at offset 129

    // WB_RGGBLevelsUnknown3 at offset 130
    if data.len() >= 268 {
        if let Ok(values) = read_int16s_array(&data[260..268], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown3 at offset 134

    // WB_RGGBLevelsUnknown4 at offset 135
    if data.len() >= 278 {
        if let Ok(values) = read_int16s_array(&data[270..278], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown4 at offset 139

    // WB_RGGBLevelsUnknown5 at offset 140
    if data.len() >= 288 {
        if let Ok(values) = read_int16s_array(&data[280..288], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown5 at offset 144

    // WB_RGGBLevelsUnknown6 at offset 145
    if data.len() >= 298 {
        if let Ok(values) = read_int16s_array(&data[290..298], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown6 at offset 149

    // WB_RGGBLevelsUnknown7 at offset 150
    if data.len() >= 308 {
        if let Ok(values) = read_int16s_array(&data[300..308], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown7 at offset 154

    // WB_RGGBLevelsUnknown8 at offset 155
    if data.len() >= 318 {
        if let Ok(values) = read_int16s_array(&data[310..318], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown8 at offset 159

    // WB_RGGBLevelsUnknown9 at offset 160
    if data.len() >= 328 {
        if let Ok(values) = read_int16s_array(&data[320..328], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown9 at offset 164

    // WB_RGGBLevelsUnknown10 at offset 165
    if data.len() >= 338 {
        if let Ok(values) = read_int16s_array(&data[330..338], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown10 at offset 169

    // WB_RGGBLevelsUnknown11 at offset 170
    if data.len() >= 348 {
        if let Ok(values) = read_int16s_array(&data[340..348], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 174

    // WB_RGGBLevelsUnknown11 at offset 175
    if data.len() >= 358 {
        if let Ok(values) = read_int16s_array(&data[350..358], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 179

    // WB_RGGBLevelsUnknown12 at offset 180
    if data.len() >= 368 {
        if let Ok(values) = read_int16s_array(&data[360..368], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown12 at offset 184

    // WB_RGGBLevelsUnknown13 at offset 185
    if data.len() >= 378 {
        if let Ok(values) = read_int16s_array(&data[370..378], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown13 at offset 189

    // WB_RGGBLevelsUnknown14 at offset 190
    if data.len() >= 388 {
        if let Ok(values) = read_int16s_array(&data[380..388], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown14 at offset 194

    // WB_RGGBLevelsUnknown15 at offset 195
    if data.len() >= 398 {
        if let Ok(values) = read_int16s_array(&data[390..398], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown15 at offset 199

    // WB_RGGBLevelsUnknown16 at offset 200
    if data.len() >= 408 {
        if let Ok(values) = read_int16s_array(&data[400..408], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown16".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown16 at offset 204

    // WB_RGGBLevelsDaylight at offset 205
    if data.len() >= 418 {
        if let Ok(values) = read_int16s_array(&data[410..418], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 210
    if data.len() >= 428 {
        if let Ok(values) = read_int16s_array(&data[420..428], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 215
    if data.len() >= 438 {
        if let Ok(values) = read_int16s_array(&data[430..438], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 220
    if data.len() >= 448 {
        if let Ok(values) = read_int16s_array(&data[440..448], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 225
    if data.len() >= 458 {
        if let Ok(values) = read_int16s_array(&data[450..458], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsKelvin at offset 230
    if data.len() >= 468 {
        if let Ok(values) = read_int16s_array(&data[460..468], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsKelvin".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 235
    if data.len() >= 478 {
        if let Ok(values) = read_int16s_array(&data[470..478], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown17 at offset 240
    if data.len() >= 488 {
        if let Ok(values) = read_int16s_array(&data[480..488], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown17".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown17 at offset 244

    // WB_RGGBLevelsUnknown18 at offset 245
    if data.len() >= 498 {
        if let Ok(values) = read_int16s_array(&data[490..498], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown18".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown18 at offset 249

    // WB_RGGBLevelsUnknown19 at offset 250
    if data.len() >= 508 {
        if let Ok(values) = read_int16s_array(&data[500..508], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown19".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown19 at offset 254

    // WB_RGGBLevelsUnknown20 at offset 255
    if data.len() >= 518 {
        if let Ok(values) = read_int16s_array(&data[510..518], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown20".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown20 at offset 259

    // WB_RGGBLevelsUnknown21 at offset 260
    if data.len() >= 528 {
        if let Ok(values) = read_int16s_array(&data[520..528], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown21".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown21 at offset 264

    // WB_RGGBLevelsUnknown22 at offset 265
    if data.len() >= 538 {
        if let Ok(values) = read_int16s_array(&data[530..538], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown22".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown22 at offset 269

    // WB_RGGBLevelsUnknown23 at offset 270
    if data.len() >= 548 {
        if let Ok(values) = read_int16s_array(&data[540..548], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown23".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown23 at offset 274

    // WB_RGGBLevelsUnknown24 at offset 275
    if data.len() >= 558 {
        if let Ok(values) = read_int16s_array(&data[550..558], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown24".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown24 at offset 279

    // WB_RGGBLevelsUnknown25 at offset 280
    if data.len() >= 568 {
        if let Ok(values) = read_int16s_array(&data[560..568], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown25".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown25 at offset 284

    // WB_RGGBLevelsUnknown26 at offset 285
    if data.len() >= 578 {
        if let Ok(values) = read_int16s_array(&data[570..578], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown26".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown26 at offset 289

    // WB_RGGBLevelsUnknown27 at offset 290
    if data.len() >= 588 {
        if let Ok(values) = read_int16s_array(&data[580..588], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown27".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown27 at offset 294

    // ColorCalib at offset 300
    if data.len() >= 840 {
        // TODO: Handle format undef
    }

    // PerChannelBlackLevel at offset 363
    if data.len() >= 734 {
        if let Ok(values) = read_int16u_array(&data[726..734], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // NormalWhiteLevel at offset 640
    if data.len() >= 1282 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 641
    if data.len() >= 1284 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 642
    if data.len() >= 1286 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_canon_colordata12(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorDataVersion at offset 0

    // WB_RGGBLevelsAsShot at offset 105
    if data.len() >= 218 {
        if let Ok(values) = read_int16s_array(&data[210..218], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsAsShot".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsDaylight at offset 110
    if data.len() >= 228 {
        if let Ok(values) = read_int16s_array(&data[220..228], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsShade at offset 115
    if data.len() >= 238 {
        if let Ok(values) = read_int16s_array(&data[230..238], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsShade".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsCloudy at offset 120
    if data.len() >= 248 {
        if let Ok(values) = read_int16s_array(&data[240..248], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsCloudy".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsTungsten at offset 125
    if data.len() >= 258 {
        if let Ok(values) = read_int16s_array(&data[250..258], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsTungsten".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFluorescent at offset 130
    if data.len() >= 268 {
        if let Ok(values) = read_int16s_array(&data[260..268], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsFlash at offset 135
    if data.len() >= 278 {
        if let Ok(values) = read_int16s_array(&data[270..278], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsFlash".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RGGBLevelsUnknown2 at offset 140
    if data.len() >= 288 {
        if let Ok(values) = read_int16s_array(&data[280..288], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown2 at offset 144

    // WB_RGGBLevelsUnknown3 at offset 145
    if data.len() >= 298 {
        if let Ok(values) = read_int16s_array(&data[290..298], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown3 at offset 149

    // WB_RGGBLevelsUnknown4 at offset 150
    if data.len() >= 308 {
        if let Ok(values) = read_int16s_array(&data[300..308], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown4 at offset 154

    // WB_RGGBLevelsUnknown5 at offset 155
    if data.len() >= 318 {
        if let Ok(values) = read_int16s_array(&data[310..318], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown5 at offset 159

    // WB_RGGBLevelsUnknown6 at offset 160
    if data.len() >= 328 {
        if let Ok(values) = read_int16s_array(&data[320..328], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown6 at offset 164

    // WB_RGGBLevelsUnknown7 at offset 165
    if data.len() >= 338 {
        if let Ok(values) = read_int16s_array(&data[330..338], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown7 at offset 169

    // WB_RGGBLevelsUnknown8 at offset 170
    if data.len() >= 348 {
        if let Ok(values) = read_int16s_array(&data[340..348], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown8 at offset 174

    // WB_RGGBLevelsUnknown9 at offset 175
    if data.len() >= 358 {
        if let Ok(values) = read_int16s_array(&data[350..358], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown9 at offset 179

    // WB_RGGBLevelsUnknown10 at offset 180
    if data.len() >= 368 {
        if let Ok(values) = read_int16s_array(&data[360..368], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown10 at offset 184

    // WB_RGGBLevelsUnknown11 at offset 185
    if data.len() >= 378 {
        if let Ok(values) = read_int16s_array(&data[370..378], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown11 at offset 189

    // WB_RGGBLevelsUnknown12 at offset 190
    if data.len() >= 388 {
        if let Ok(values) = read_int16s_array(&data[380..388], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown12 at offset 194

    // WB_RGGBLevelsUnknown13 at offset 195
    if data.len() >= 398 {
        if let Ok(values) = read_int16s_array(&data[390..398], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown13 at offset 199

    // WB_RGGBLevelsUnknown14 at offset 200
    if data.len() >= 408 {
        if let Ok(values) = read_int16s_array(&data[400..408], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown14 at offset 204

    // WB_RGGBLevelsUnknown15 at offset 205
    if data.len() >= 418 {
        if let Ok(values) = read_int16s_array(&data[410..418], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown15 at offset 209

    // WB_RGGBLevelsUnknown16 at offset 210
    if data.len() >= 428 {
        if let Ok(values) = read_int16s_array(&data[420..428], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown16".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown16 at offset 214

    // WB_RGGBLevelsUnknown17 at offset 215
    if data.len() >= 438 {
        if let Ok(values) = read_int16s_array(&data[430..438], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown17".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown17 at offset 219

    // WB_RGGBLevelsUnknown18 at offset 220
    if data.len() >= 448 {
        if let Ok(values) = read_int16s_array(&data[440..448], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown18".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown18 at offset 224

    // WB_RGGBLevelsUnknown19 at offset 225
    if data.len() >= 458 {
        if let Ok(values) = read_int16s_array(&data[450..458], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown19".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown19 at offset 229

    // WB_RGGBLevelsUnknown20 at offset 230
    if data.len() >= 468 {
        if let Ok(values) = read_int16s_array(&data[460..468], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown20".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown20 at offset 234

    // WB_RGGBLevelsUnknown21 at offset 235
    if data.len() >= 478 {
        if let Ok(values) = read_int16s_array(&data[470..478], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown21".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown21 at offset 239

    // WB_RGGBLevelsUnknown22 at offset 240
    if data.len() >= 488 {
        if let Ok(values) = read_int16s_array(&data[480..488], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown22".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown22 at offset 244

    // WB_RGGBLevelsUnknown23 at offset 245
    if data.len() >= 498 {
        if let Ok(values) = read_int16s_array(&data[490..498], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown23".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown23 at offset 249

    // WB_RGGBLevelsUnknown24 at offset 250
    if data.len() >= 508 {
        if let Ok(values) = read_int16s_array(&data[500..508], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown24".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown24 at offset 254

    // WB_RGGBLevelsUnknown25 at offset 255
    if data.len() >= 518 {
        if let Ok(values) = read_int16s_array(&data[510..518], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown25".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown25 at offset 259

    // WB_RGGBLevelsUnknown26 at offset 260
    if data.len() >= 528 {
        if let Ok(values) = read_int16s_array(&data[520..528], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown26".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown26 at offset 264

    // WB_RGGBLevelsUnknown27 at offset 265
    if data.len() >= 538 {
        if let Ok(values) = read_int16s_array(&data[530..538], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown27".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown27 at offset 269

    // WB_RGGBLevelsUnknown28 at offset 270
    if data.len() >= 548 {
        if let Ok(values) = read_int16s_array(&data[540..548], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown28".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown28 at offset 274

    // WB_RGGBLevelsUnknown29 at offset 275
    if data.len() >= 558 {
        if let Ok(values) = read_int16s_array(&data[550..558], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown29".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown29 at offset 279

    // WB_RGGBLevelsUnknown30 at offset 280
    if data.len() >= 568 {
        if let Ok(values) = read_int16s_array(&data[560..568], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown30".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown30 at offset 284

    // WB_RGGBLevelsUnknown31 at offset 285
    if data.len() >= 578 {
        if let Ok(values) = read_int16s_array(&data[570..578], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown31".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown31 at offset 289

    // WB_RGGBLevelsUnknown32 at offset 290
    if data.len() >= 588 {
        if let Ok(values) = read_int16s_array(&data[580..588], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown32".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown32 at offset 294

    // WB_RGGBLevelsUnknown33 at offset 295
    if data.len() >= 598 {
        if let Ok(values) = read_int16s_array(&data[590..598], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RGGBLevelsUnknown33".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ColorTempUnknown33 at offset 299

    // ColorCalib at offset 320
    if data.len() >= 880 {
        // TODO: Handle format undef
    }

    // PerChannelBlackLevel at offset 383
    if data.len() >= 774 {
        if let Ok(values) = read_int16u_array(&data[766..774], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PerChannelBlackLevel".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // NormalWhiteLevel at offset 660
    if data.len() >= 1322 {
        // TODO: Handle format int16u
    }

    // SpecularWhiteLevel at offset 661
    if data.len() >= 1324 {
        // TODO: Handle format int16u
    }

    // LinearityUpperMargin at offset 662
    if data.len() >= 1326 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_canon_colordataunknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_canon_colorinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Saturation at offset 1

    // ColorTone at offset 2

    // ColorSpace at offset 3

    Ok(tags)
}

fn process_canon_afmicroadj(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFMicroAdjMode at offset 1

    // AFMicroAdjValue at offset 2
    if data.len() >= 6 {
        // TODO: Handle format rational64s
    }

    Ok(tags)
}

fn process_canon_vignettingcorr(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // VignettingCorrVersion at offset 0
    // VignettingCorrVersion uses negative offset -2 (from end of data)
    if data.len() as i32 + -2 < 0 {
        // Skipping VignettingCorrVersion - negative offset beyond data start
        // (This is normal for some tables)
    } else {
        let vignettingcorrversion_offset = (data.len() as i32 + -2) as usize;
        if vignettingcorrversion_offset < data.len() {
            // TODO: Handle format int8u
        }
    }

    // OriginalImageWidth at offset 11

    // PeripheralLighting at offset 2

    // DistortionCorrection at offset 3

    // ChromaticAberrationCorr at offset 4

    // ChromaticAberrationCorr at offset 5

    Ok(tags)
}

fn process_canon_vignettingcorrunknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // VignettingCorrVersion at offset 0
    // VignettingCorrVersion uses negative offset -2 (from end of data)
    if data.len() as i32 + -2 < 0 {
        // Skipping VignettingCorrVersion - negative offset beyond data start
        // (This is normal for some tables)
    } else {
        let vignettingcorrversion_offset = (data.len() as i32 + -2) as usize;
        if vignettingcorrversion_offset < data.len() {
            // TODO: Handle format int8u
        }
    }

    Ok(tags)
}

fn process_canon_vignettingcorr2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PeripheralLightingSetting at offset 5

    // ChromaticAberrationSetting at offset 6

    // DistortionCorrectionSetting at offset 7

    // DigitalLensOptimizerSetting at offset 9

    Ok(tags)
}

fn process_canon_lightingopt(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PeripheralIlluminationCorr at offset 1

    // DigitalLensOptimizer at offset 10

    // DualPixelRaw at offset 11

    // AutoLightingOptimizer at offset 2

    // HighlightTonePriority at offset 3

    // LongExposureNoiseReduction at offset 4

    // HighISONoiseReduction at offset 5

    Ok(tags)
}

fn process_canon_lensinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensSerialNumber at offset 0
    if data.len() >= 10 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_canon_ambience(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AmbienceSelection at offset 1

    Ok(tags)
}

fn process_canon_multiexp(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MultiExposure at offset 1

    // MultiExposureControl at offset 2

    Ok(tags)
}

fn process_canon_filterinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MiniatureFilter at offset 1025

    // MiniatureFilterOrientation at offset 1026

    // FisheyeFilter at offset 1281

    // PaintingFilter at offset 1537

    // WatercolorFilter at offset 1793

    // GrainyBWFilter at offset 257

    // SoftFocusFilter at offset 513

    // ToyCameraFilter at offset 769

    Ok(tags)
}

fn process_canon_hdrinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // HDR at offset 1

    // HDREffect at offset 2

    Ok(tags)
}

fn process_canon_loginfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorMatrix at offset 10

    // CanonLogVersion at offset 11

    // CompressionFormat at offset 4

    // Sharpness at offset 6

    // Saturation at offset 7

    // ColorTone at offset 8

    // ColorSpace2 at offset 9

    Ok(tags)
}

fn process_canon_afconfig(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFConfigTool at offset 1

    // AutoAFPointSelEOSiTRAF at offset 10

    // LensDriveWhenAFImpossible at offset 11

    // SelectAFAreaSelectionMode at offset 12

    // AFAreaSelectionMethod at offset 13

    // OrientationLinkedAF at offset 14

    // ManualAFPointSelPattern at offset 15

    // AFPointDisplayDuringFocus at offset 16

    // VFDisplayIllumination at offset 17

    // AFStatusViewfinder at offset 18

    // InitialAFPointInServo at offset 19

    // SubjectToDetect at offset 20

    // EyeDetection at offset 24

    // AFAccelDecelTracking at offset 3

    // AIServoFirstImage at offset 5

    // AIServoSecondImage at offset 6

    // AFAssistBeam at offset 8

    // OneShotAFRelease at offset 9

    Ok(tags)
}

fn process_canon_rawburstinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_canon_levelinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // RollAngle at offset 4

    // PitchAngle at offset 5

    // FocalLength at offset 7

    // MinFocalLength2 at offset 8

    // MaxFocalLength2 at offset 9

    Ok(tags)
}

pub fn process_tag_0x1_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x1_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_camerasettings(data, byte_order)
}

pub fn process_tag_0x2_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_focallength(data, byte_order)
}

pub fn process_tag_0x4_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_shotinfo(data, byte_order)
}

pub fn process_tag_0x5_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x5_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_panorama(data, byte_order)
}

pub fn process_tag_0xa_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xa_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_unknownd30(data, byte_order)
}

pub fn process_tag_0xd_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xd_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0xf_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xf_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x11_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x11_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_movieinfo(data, byte_order)
}

pub fn process_tag_0x12_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x12_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x1d_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x1d_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_mycolors(data, byte_order)
}

pub fn process_tag_0x24_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x24_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_facedetect1(data, byte_order)
}

pub fn process_tag_0x25_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x25_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_facedetect2(data, byte_order)
}

pub fn process_tag_0x26_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x26_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x27_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x27_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x29_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x29_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_wbinfo(data, byte_order)
}

pub fn process_tag_0x2f_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2f_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_facedetect3(data, byte_order)
}

pub fn process_tag_0x35_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x35_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_timeinfo(data, byte_order)
}

pub fn process_tag_0x3c_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x3c_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x3f_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x3f_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcoefs(data, byte_order)
}

pub fn process_tag_0x47_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x47_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x4b_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4b_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0x85_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x85_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0x90_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x90_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::CanonCustom::Functions1D
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x91_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x91_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::CanonCustom::PersonalFuncs
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x92_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x92_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::CanonCustom::PersonalFuncValues
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x93_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x93_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_fileinfo(data, byte_order)
}

pub fn process_tag_0x96_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x96_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x98_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x98_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_cropinfo(data, byte_order)
}

pub fn process_tag_0x99_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x99_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::CanonCustom::Functions2
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x9a_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9a_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_aspectinfo(data, byte_order)
}

pub fn process_tag_0xa0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xa0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_processing(data, byte_order)
}

pub fn process_tag_0xa4_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xa4_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0xa8_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xa8_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0xa9_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xa9_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorbalance(data, byte_order)
}

pub fn process_tag_0xaa_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xaa_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_measuredcolor(data, byte_order)
}

pub fn process_tag_0xb0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xb0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_flags(data, byte_order)
}

pub fn process_tag_0xb1_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xb1_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_modifiedinfo(data, byte_order)
}

pub fn process_tag_0xb6_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xb6_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_previewimageinfo(data, byte_order)
}

pub fn process_tag_0xba_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xba_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0xbc_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xbc_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0xd5_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xd5_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0xe0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_sensorinfo(data, byte_order)
}

pub fn process_tag_0xff_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xff_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x107_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x107_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0x10a_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x10a_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0x118_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x118_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0x12c_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x12c_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0x140_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x140_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorcalib(data, byte_order)
}

pub fn process_tag_0x4001_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4001_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    match count {
        582 => {
            debug!("Matched count 582 for variant canon_colordata1");
            process_canon_colordata1(data, byte_order)
        }
        653 => {
            debug!("Matched count 653 for variant canon_colordata2");
            process_canon_colordata2(data, byte_order)
        }
        796 => {
            debug!("Matched count 796 for variant canon_colordata3");
            process_canon_colordata3(data, byte_order)
        }
        692 => {
            debug!("Matched count 692 for variant canon_colordata4");
            process_canon_colordata4(data, byte_order)
        }
        674 => {
            debug!("Matched count 674 for variant canon_colordata4");
            process_canon_colordata4(data, byte_order)
        }
        702 => {
            debug!("Matched count 702 for variant canon_colordata4");
            process_canon_colordata4(data, byte_order)
        }
        1227 => {
            debug!("Matched count 1227 for variant canon_colordata4");
            process_canon_colordata4(data, byte_order)
        }
        1250 => {
            debug!("Matched count 1250 for variant canon_colordata4");
            process_canon_colordata4(data, byte_order)
        }
        1251 => {
            debug!("Matched count 1251 for variant canon_colordata4");
            process_canon_colordata4(data, byte_order)
        }
        1337 => {
            debug!("Matched count 1337 for variant canon_colordata4");
            process_canon_colordata4(data, byte_order)
        }
        1338 => {
            debug!("Matched count 1338 for variant canon_colordata4");
            process_canon_colordata4(data, byte_order)
        }
        1346 => {
            debug!("Matched count 1346 for variant canon_colordata4");
            process_canon_colordata4(data, byte_order)
        }
        5120 => {
            debug!("Matched count 5120 for variant canon_colordata5");
            process_canon_colordata5(data, byte_order)
        }
        1273 => {
            debug!("Matched count 1273 for variant canon_colordata6");
            process_canon_colordata6(data, byte_order)
        }
        1275 => {
            debug!("Matched count 1275 for variant canon_colordata6");
            process_canon_colordata6(data, byte_order)
        }
        1312 => {
            debug!("Matched count 1312 for variant canon_colordata7");
            process_canon_colordata7(data, byte_order)
        }
        1313 => {
            debug!("Matched count 1313 for variant canon_colordata7");
            process_canon_colordata7(data, byte_order)
        }
        1316 => {
            debug!("Matched count 1316 for variant canon_colordata7");
            process_canon_colordata7(data, byte_order)
        }
        1506 => {
            debug!("Matched count 1506 for variant canon_colordata7");
            process_canon_colordata7(data, byte_order)
        }
        1560 => {
            debug!("Matched count 1560 for variant canon_colordata8");
            process_canon_colordata8(data, byte_order)
        }
        1592 => {
            debug!("Matched count 1592 for variant canon_colordata8");
            process_canon_colordata8(data, byte_order)
        }
        1353 => {
            debug!("Matched count 1353 for variant canon_colordata8");
            process_canon_colordata8(data, byte_order)
        }
        1602 => {
            debug!("Matched count 1602 for variant canon_colordata8");
            process_canon_colordata8(data, byte_order)
        }
        1816 => {
            debug!("Matched count 1816 for variant canon_colordata9");
            process_canon_colordata9(data, byte_order)
        }
        1820 => {
            debug!("Matched count 1820 for variant canon_colordata9");
            process_canon_colordata9(data, byte_order)
        }
        1824 => {
            debug!("Matched count 1824 for variant canon_colordata9");
            process_canon_colordata9(data, byte_order)
        }
        2024 => {
            debug!("Matched count 2024 for variant canon_colordata10");
            process_canon_colordata10(data, byte_order)
        }
        3656 => {
            debug!("Matched count 3656 for variant canon_colordata10");
            process_canon_colordata10(data, byte_order)
        }
        3973 => {
            debug!("Matched count 3973 for variant canon_colordata11");
            process_canon_colordata11(data, byte_order)
        }
        3778 => {
            debug!("Matched count 3778 for variant canon_colordata11");
            process_canon_colordata11(data, byte_order)
        }
        4528 => {
            debug!("Matched count 4528 for variant canon_colordata12");
            process_canon_colordata12(data, byte_order)
        }
        _ => Ok(vec![]), // No matching variant
    }
}

pub fn process_tag_0x4003_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4003_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_colorinfo(data, byte_order)
}

pub fn process_tag_0x4013_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4013_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_afmicroadj(data, byte_order)
}

pub fn process_tag_0x4015_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4015_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x4016_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4016_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_vignettingcorr2(data, byte_order)
}

pub fn process_tag_0x4018_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4018_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_lightingopt(data, byte_order)
}

pub fn process_tag_0x4019_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4019_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_lensinfo(data, byte_order)
}

pub fn process_tag_0x4020_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4020_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x4021_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4021_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_multiexp(data, byte_order)
}

pub fn process_tag_0x4024_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4024_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_filterinfo(data, byte_order)
}

pub fn process_tag_0x4025_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4025_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_hdrinfo(data, byte_order)
}

pub fn process_tag_0x4026_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4026_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_loginfo(data, byte_order)
}

pub fn process_tag_0x4028_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4028_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_afconfig(data, byte_order)
}

pub fn process_tag_0x403f_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x403f_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_rawburstinfo(data, byte_order)
}

pub fn process_tag_0x4059_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4059_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_canon_levelinfo(data, byte_order)
}

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    match tag_id {
        3 => crate::implementations::print_conv::decimal_2_print_conv(value),
        4 => crate::implementations::print_conv::exposuretime_print_conv(value),
        5 => crate::implementations::print_conv::exposuretime_print_conv(value),
        6 => crate::implementations::print_conv::print_fraction(value),
        15 => crate::implementations::print_conv::print_fraction(value),
        17 => crate::implementations::print_conv::print_fraction(value),
        22 => crate::implementations::print_conv::exposuretime_print_conv(value),
        _ => {
            // Fall back to shared handling
            if let Some(tag_kit) = CANON_PM_TAG_KITS.get(&tag_id) {
                crate::implementations::generic::apply_fallback_print_conv(
                    tag_id,
                    value,
                    crate::to_print_conv_ref!(&tag_kit.print_conv),
                )
            } else {
                value.clone()
            }
        }
    }
}

/// Apply ValueConv for a tag from this module
pub fn apply_value_conv(
    tag_id: u32,
    value: &TagValue,
    _errors: &mut Vec<String>,
) -> Result<TagValue> {
    Ok(value.clone())
}

/// Check if a tag has subdirectory processing
pub fn has_subdirectory(tag_id: u32) -> bool {
    if let Some(tag_kit) = CANON_PM_TAG_KITS.get(&tag_id) {
        tag_kit.subdirectory.is_some()
    } else {
        false
    }
}

/// Process subdirectory tags and return multiple extracted tags
pub fn process_subdirectory(
    tag_id: u32,
    value: &TagValue,
    byte_order: ByteOrder,
) -> Result<HashMap<String, TagValue>> {
    use tracing::debug;
    let mut result = HashMap::new();

    debug!("process_subdirectory called for tag_id: 0x{:04x}", tag_id);

    if let Some(tag_kit) = CANON_PM_TAG_KITS.get(&tag_id) {
        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {
            debug!("Found subdirectory processor for tag_id: 0x{:04x}", tag_id);
            let bytes = match value {
                TagValue::U16Array(arr) => {
                    debug!("Converting U16Array with {} elements to bytes", arr.len());
                    // Convert U16 array to bytes based on byte order
                    let mut bytes = Vec::with_capacity(arr.len() * 2);
                    for val in arr {
                        match byte_order {
                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),
                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),
                        }
                    }
                    bytes
                }
                TagValue::U8Array(arr) => arr.clone(),
                _ => return Ok(result), // Not array data
            };

            debug!("Calling processor with {} bytes", bytes.len());
            // Process subdirectory and collect all extracted tags
            match processor(&bytes, byte_order) {
                Ok(extracted_tags) => {
                    debug!("Processor returned {} tags", extracted_tags.len());
                    for (name, value) in extracted_tags {
                        result.insert(name, value);
                    }
                }
                Err(e) => {
                    debug!("Processor error: {:?}", e);
                }
            }
        } else {
            debug!(
                "No subdirectory processor found for tag_id: 0x{:04x}",
                tag_id
            );
        }
    } else {
        debug!("Tag not found in TAG_KITS: 0x{:04x}", tag_id);
    }

    Ok(result)
}
