//! Modular tag kits with embedded PrintConv for Nikon_pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: Nikon.pm table: Main
//!
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub mod color;
pub mod core;
pub mod datetime;
pub mod document;
pub mod interop;
pub mod other;
pub mod thumbnail;

use crate::expressions::ExpressionEvaluator;
use crate::tiff_types::ByteOrder;
use crate::types::{Result, TagValue};
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
    pub subdirectory: Option<SubDirectoryType>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// Type alias for subdirectory processor function
pub type SubDirectoryProcessor = fn(&[u8], ByteOrder) -> Result<Vec<(String, TagValue)>>;

#[derive(Debug, Clone)]
pub enum SubDirectoryType {
    Binary { processor: SubDirectoryProcessor },
}

/// All tag kits for Nikon_pm
pub static NIKON_PM_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    // color tags
    for (id, tag_def) in color::get_color_tags() {
        map.insert(id, tag_def);
    }

    // core tags
    for (id, tag_def) in core::get_core_tags() {
        map.insert(id, tag_def);
    }

    // datetime tags
    for (id, tag_def) in datetime::get_datetime_tags() {
        map.insert(id, tag_def);
    }

    // document tags
    for (id, tag_def) in document::get_document_tags() {
        map.insert(id, tag_def);
    }

    // interop tags
    for (id, tag_def) in interop::get_interop_tags() {
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        map.insert(id, tag_def);
    }

    // thumbnail tags
    for (id, tag_def) in thumbnail::get_thumbnail_tags() {
        map.insert(id, tag_def);
    }

    map
});

// Helper functions for reading binary data
fn model_matches(model: &str, pattern: &str) -> bool {
    // ExifTool regexes are already in a compatible format
    // Just need to ensure proper escaping was preserved

    match regex::Regex::new(pattern) {
        Ok(re) => re.is_match(model),
        Err(e) => {
            tracing::warn!("Failed to compile model regex '{}': {}", pattern, e);
            false
        }
    }
}

fn format_matches(format: &str, pattern: &str) -> bool {
    if let Ok(re) = regex::Regex::new(pattern) {
        re.is_match(format)
    } else {
        tracing::warn!("Failed to compile format regex: {}", pattern);
        false
    }
}

fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16u array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {
    if data.len() < 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s".to_string(),
        ));
    }
    Ok(match byte_order {
        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),
        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),
    })
}

// Subdirectory processing functions
fn process_nikon_menusettingsz8(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MultipleExposureMode at offset 152

    // MultiExposureShots at offset 154

    // IntervalDurationHours at offset 184
    if data.len() >= 372 {
        // TODO: Handle format int32u
    }

    // IntervalDurationMinutes at offset 188
    if data.len() >= 380 {
        // TODO: Handle format int32u
    }

    // IntervalDurationSeconds at offset 192
    if data.len() >= 388 {
        // TODO: Handle format int32u
    }

    // Intervals at offset 200
    if data.len() >= 404 {
        // TODO: Handle format int32u
    }

    // ShotsPerInterval at offset 204
    if data.len() >= 412 {
        // TODO: Handle format int32u
    }

    // IntervalExposureSmoothing at offset 208
    if data.len() >= 417 {
        // TODO: Handle format int8u
    }

    // IntervalPriority at offset 210
    if data.len() >= 421 {
        // TODO: Handle format int8u
    }

    // FocusShiftNumberShots at offset 244

    // FocusShiftStepWidth at offset 248

    // FocusShiftInterval at offset 252

    // FocusShiftExposureLock at offset 256

    // PhotoShootingMenuBank at offset 286

    // ExtendedMenuBanks at offset 288

    // PhotoShootingMenuBankImageArea at offset 324

    // AutoISO at offset 338

    // ISOAutoHiLimit at offset 340
    if data.len() >= 682 {
        // TODO: Handle format int16u
    }

    // ISOAutoFlashLimit at offset 342
    if data.len() >= 686 {
        // TODO: Handle format int16u
    }

    // ISOAutoShutterTime at offset 350
    if data.len() >= 702 {
        if let Ok(value) = read_int16s(&data[700..702], byte_order) {
            tags.push(("ISOAutoShutterTime".to_string(), TagValue::I16(value)));
        }
    }

    // MovieVignetteControl at offset 432

    // DiffractionCompensation at offset 434

    // FlickerReductionShooting at offset 436

    // FlashControlMode at offset 440

    // AFAreaMode at offset 548

    // VRMode at offset 550

    // BracketSet at offset 554

    // BracketProgram at offset 556

    // BracketIncrement at offset 558

    // HDR at offset 570

    // SecondarySlotFunction at offset 576

    // HDRLevel at offset 582

    // Slot2JpgSize at offset 586

    // DXCropAlert at offset 592

    // SubjectDetection at offset 594

    // DynamicAFAreaSize at offset 596

    // ToneMap at offset 618

    // PortraitImpressionBalance at offset 622

    // HighFrequencyFlickerReduction at offset 636

    // HighFrameRate at offset 72

    // MovieImageArea at offset 730

    // MovieType at offset 740

    // MovieISOAutoHiLimit at offset 742
    if data.len() >= 1486 {
        // TODO: Handle format int16u
    }

    // MovieISOAutoControlManualMode at offset 744

    // MovieISOAutoManualMode at offset 746
    if data.len() >= 1494 {
        // TODO: Handle format int16u
    }

    // MovieActiveD-Lighting at offset 820

    // MovieHighISONoiseReduction at offset 822

    // MovieFlickerReduction at offset 828

    // MovieMeteringMode at offset 830

    // MovieFocusMode at offset 832

    // MovieAFAreaMode at offset 834

    // MovieVRMode at offset 836

    // MovieElectronicVR at offset 840

    // MovieSoundRecording at offset 842

    // MicrophoneSensitivity at offset 844

    // MicrophoneAttenuator at offset 846

    // MicrophoneFrequencyResponse at offset 848

    // WindNoiseReduction at offset 850

    // MovieFrameSize at offset 882

    // MovieFrameRate at offset 884

    // MicrophoneJackPower at offset 886

    // MovieDXCropAlert at offset 887

    // MovieSubjectDetection at offset 888

    // MovieHighResZoom at offset 896

    Ok(tags)
}

fn process_nikon_avitags(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ExposureCompensation at offset 10
    if data.len() >= 22 {
        // TODO: Handle format rational64s
    }

    // MaxApertureValue at offset 11
    if data.len() >= 24 {
        // TODO: Handle format rational64u
    }

    // MeteringMode at offset 12
    if data.len() >= 26 {
        // TODO: Handle format int16u
    }

    // Nikon_AVITags_0x000d at offset 13
    if data.len() >= 28 {
        // TODO: Handle format int16u
    }

    // Nikon_AVITags_0x000e at offset 14
    if data.len() >= 30 {
        // TODO: Handle format int16u
    }

    // FocalLength at offset 15
    if data.len() >= 32 {
        // TODO: Handle format rational64u
    }

    // XResolution at offset 16
    if data.len() >= 34 {
        // TODO: Handle format rational64u
    }

    // YResolution at offset 17
    if data.len() >= 36 {
        // TODO: Handle format rational64u
    }

    // ResolutionUnit at offset 18
    if data.len() >= 38 {
        // TODO: Handle format int16u
    }

    // DateTimeOriginal at offset 19

    // CreateDate at offset 20

    // Nikon_AVITags_0x0015 at offset 21
    if data.len() >= 44 {
        // TODO: Handle format int16u
    }

    // Duration at offset 22
    if data.len() >= 46 {
        // TODO: Handle format rational64u
    }

    // Nikon_AVITags_0x0017 at offset 23
    if data.len() >= 48 {
        // TODO: Handle format int16u
    }

    // Nikon_AVITags_0x0019 at offset 25
    if data.len() >= 54 {
        // TODO: Handle format int32s
    }

    // DigitalZoom at offset 27
    if data.len() >= 56 {
        // TODO: Handle format rational64u
    }

    // Nikon_AVITags_0x001c at offset 28
    if data.len() >= 58 {
        // TODO: Handle format rational64u
    }

    // Sharpness at offset 30

    // WhiteBalance at offset 31

    // NoiseReduction at offset 32

    // Nikon_AVITags_0x801a at offset 32794
    if data.len() >= 65592 {
        // TODO: Handle format int32s
    }

    // Software at offset 5
    if data.len() >= 12 {
        // TODO: Handle format undef
    }

    // Orientation at offset 7
    if data.len() >= 16 {
        // TODO: Handle format int16u
    }

    // ExposureTime at offset 8
    if data.len() >= 18 {
        // TODO: Handle format rational64u
    }

    // FNumber at offset 9
    if data.len() >= 20 {
        // TODO: Handle format rational64u
    }

    Ok(tags)
}

fn process_nikon_avivers(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MakerNoteVersion at offset 2
    if data.len() >= 5 {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_nikon_colorbalancea(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_RBLevels at offset 624
    if data.len() >= 1252 {
        if let Ok(values) = read_int16u_array(&data[1248..1252], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RBLevelsAuto at offset 626
    if data.len() >= 1256 {
        if let Ok(values) = read_int16u_array(&data[1252..1256], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevelsAuto".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RBLevelsDaylight at offset 628
    if data.len() >= 1284 {
        if let Ok(values) = read_int16u_array(&data[1256..1284], byte_order, 14) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RBLevelsDaylight".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RBLevelsIncandescent at offset 642
    if data.len() >= 1312 {
        if let Ok(values) = read_int16u_array(&data[1284..1312], byte_order, 14) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RBLevelsIncandescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RBLevelsFluorescent at offset 656
    if data.len() >= 1324 {
        if let Ok(values) = read_int16u_array(&data[1312..1324], byte_order, 6) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "WB_RBLevelsFluorescent".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // WB_RBLevelsCloudy at offset 662
    if data.len() >= 1352 {
        if let Ok(values) = read_int16u_array(&data[1324..1352], byte_order, 14) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevelsCloudy".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RBLevelsFlash at offset 676
    if data.len() >= 1380 {
        if let Ok(values) = read_int16u_array(&data[1352..1380], byte_order, 14) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevelsFlash".to_string(), TagValue::String(value_str)));
        }
    }

    // WB_RBLevelsShade at offset 690
    if data.len() >= 1408 {
        if let Ok(values) = read_int16u_array(&data[1380..1408], byte_order, 14) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBLevelsShade".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_nikon_colorbalanceb(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorBalanceVersion at offset 4
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // WB_RGGBLevels at offset 5096
    if data.len() >= 10208 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsDaylight at offset 5112
    if data.len() >= 10240 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsCloudy at offset 5128
    if data.len() >= 10272 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsTungsten at offset 5160
    if data.len() >= 10336 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsFluorescentW at offset 5176
    if data.len() >= 10368 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsFlash at offset 5192
    if data.len() >= 10400 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsCustom at offset 5224
    if data.len() >= 10464 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsAuto at offset 5240
    if data.len() >= 10496 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_colorbalancec(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_RGGBLevelsShade at offset 116
    if data.len() >= 248 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsTungsten at offset 136
    if data.len() >= 288 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsFluorescentW at offset 156
    if data.len() >= 328 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsFluorescentN at offset 176
    if data.len() >= 368 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsFluorescentD at offset 196
    if data.len() >= 408 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsHTMercury at offset 216
    if data.len() >= 448 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsCustom at offset 256
    if data.len() >= 528 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsAuto at offset 276
    if data.len() >= 568 {
        // TODO: Handle format int32u
    }

    // BlackLevel at offset 32
    if data.len() >= 66 {
        // TODO: Handle format int16u
    }

    // ColorBalanceVersion at offset 4
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // WB_RGGBLevels at offset 56
    if data.len() >= 128 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsDaylight at offset 76
    if data.len() >= 168 {
        // TODO: Handle format int32u
    }

    // WB_RGGBLevelsCloudy at offset 96
    if data.len() >= 208 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_vrinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // VRInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // VibrationReduction at offset 4

    // VRType at offset 8

    Ok(tags)
}

fn process_nikon_facedetect(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FaceDetectFrameSize at offset 1
    if data.len() >= 6 {
        if let Ok(values) = read_int16u_array(&data[2..6], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FaceDetectFrameSize".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // Face3Position at offset 12
    if data.len() >= 32 {
        if let Ok(values) = read_int16u_array(&data[24..32], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face3Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face4Position at offset 16
    if data.len() >= 40 {
        if let Ok(values) = read_int16u_array(&data[32..40], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face4Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face5Position at offset 20
    if data.len() >= 48 {
        if let Ok(values) = read_int16u_array(&data[40..48], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face5Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face6Position at offset 24
    if data.len() >= 56 {
        if let Ok(values) = read_int16u_array(&data[48..56], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face6Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face7Position at offset 28
    if data.len() >= 64 {
        if let Ok(values) = read_int16u_array(&data[56..64], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face7Position".to_string(), TagValue::String(value_str)));
        }
    }

    // FacesDetected at offset 3

    // Face8Position at offset 32
    if data.len() >= 72 {
        if let Ok(values) = read_int16u_array(&data[64..72], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face8Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face9Position at offset 36
    if data.len() >= 80 {
        if let Ok(values) = read_int16u_array(&data[72..80], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face9Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face1Position at offset 4
    if data.len() >= 16 {
        if let Ok(values) = read_int16u_array(&data[8..16], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face1Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face10Position at offset 40
    if data.len() >= 88 {
        if let Ok(values) = read_int16u_array(&data[80..88], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face10Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face11Position at offset 44
    if data.len() >= 96 {
        if let Ok(values) = read_int16u_array(&data[88..96], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face11Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face12Position at offset 48
    if data.len() >= 104 {
        if let Ok(values) = read_int16u_array(&data[96..104], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face12Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face2Position at offset 8
    if data.len() >= 24 {
        if let Ok(values) = read_int16u_array(&data[16..24], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face2Position".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_nikon_picturecontrol(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PictureControlVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // PictureControlBase at offset 24
    if data.len() >= 88 {
        // TODO: Handle format string
    }

    // PictureControlName at offset 4
    if data.len() >= 48 {
        // TODO: Handle format string
    }

    // PictureControlAdjust at offset 48

    // PictureControlQuickAdjust at offset 49

    // Sharpness at offset 50

    // Contrast at offset 51

    // Brightness at offset 52

    // Saturation at offset 53

    // HueAdjustment at offset 54

    // FilterEffect at offset 55

    // ToningEffect at offset 56

    // ToningSaturation at offset 57

    Ok(tags)
}

fn process_nikon_picturecontrol2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PictureControlVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // PictureControlBase at offset 24
    if data.len() >= 88 {
        // TODO: Handle format string
    }

    // PictureControlName at offset 4
    if data.len() >= 48 {
        // TODO: Handle format string
    }

    // PictureControlAdjust at offset 48

    // PictureControlQuickAdjust at offset 49

    // Sharpness at offset 51

    // Clarity at offset 53

    // Contrast at offset 55

    // Brightness at offset 57

    // Saturation at offset 59

    // Hue at offset 61

    // FilterEffect at offset 63

    // ToningEffect at offset 64

    // ToningSaturation at offset 65

    Ok(tags)
}

fn process_nikon_picturecontrol3(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PictureControlVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // PictureControlBase at offset 28
    if data.len() >= 96 {
        // TODO: Handle format string
    }

    // PictureControlAdjust at offset 54

    // PictureControlQuickAdjust at offset 55

    // Sharpness at offset 57

    // MidRangeSharpness at offset 59

    // Clarity at offset 61

    // Contrast at offset 63

    // Brightness at offset 65

    // Saturation at offset 67

    // Hue at offset 69

    // FilterEffect at offset 71

    // ToningEffect at offset 72

    // ToningSaturation at offset 73

    // PictureControlName at offset 8
    if data.len() >= 56 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_picturecontrolunknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PictureControlVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_worldtime(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TimeZone at offset 0
    if data.len() >= 2 {
        if let Ok(value) = read_int16s(&data[0..2], byte_order) {
            tags.push(("TimeZone".to_string(), TagValue::I16(value)));
        }
    }

    // DaylightSavings at offset 2

    // DateDisplayFormat at offset 3

    Ok(tags)
}

fn process_nikon_isoinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ISO at offset 0

    // ISOExpansion2 at offset 10
    if data.len() >= 22 {
        // TODO: Handle format int16u
    }

    // ISOExpansion at offset 4
    if data.len() >= 10 {
        // TODO: Handle format int16u
    }

    // ISO2 at offset 6

    Ok(tags)
}

fn process_nikon_distortinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // DistortionVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // AutoDistortionControl at offset 4

    Ok(tags)
}

fn process_nikon_unknowninfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // UnknownInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_unknowninfo2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // UnknownInfo2Version at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_hdrinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // HDRInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // HDR at offset 4

    // HDRLevel at offset 5

    // HDRSmoothing at offset 6

    // HDRLevel2 at offset 7

    Ok(tags)
}

fn process_nikon_hdrinfo2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // HDRInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // HDR at offset 4

    // HDRLevel at offset 5

    Ok(tags)
}

fn process_nikon_locationinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LocationInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // TextEncoding at offset 4

    // CountryCode at offset 5
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // Location at offset 9
    if data.len() >= 158 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_makernotes0x51(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersion51 at offset 0
    if data.len() >= 16 {
        // TODO: Handle format string
    }

    // NEFCompression at offset 10
    if data.len() >= 22 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_nikon_makernotes0x56(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FirmwareVersion56 at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // PixelShiftID at offset 12

    // BurstGroupID at offset 4
    if data.len() >= 10 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_nikon_afinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFAreaMode at offset 0

    // AFPoint at offset 1

    // AFPointsInFocus at offset 2
    if data.len() >= 6 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_nikon_shotinfod40(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // ShutterCount at offset 582
    if data.len() >= 1168 {
        // TODO: Handle format int32u
    }

    // VibrationReduction at offset 586.1

    // CustomSettingsD40 at offset 729
    if data.len() >= 1482 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod80(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // ShutterCount at offset 586
    if data.len() >= 1176 {
        // TODO: Handle format int32u
    }

    // Rotation at offset 590.1

    // VibrationReduction at offset 590.2

    // FlashFired at offset 590.3

    // NikonImageSize at offset 708

    // ImageQuality at offset 708.1

    // CustomSettingsD80 at offset 748
    if data.len() >= 1530 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod90(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ISO2 at offset 693

    // ShutterCount at offset 725
    if data.len() >= 1454 {
        // TODO: Handle format int32u
    }

    // CustomSettingsD90 at offset 884
    if data.len() >= 1840 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod3a(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // ISO2 at offset 598

    // ShutterCount at offset 630
    if data.len() >= 1264 {
        // TODO: Handle format int32u
    }

    // NikonImageSize at offset 723.1

    // ImageQuality at offset 723.2

    // CustomSettingsD3 at offset 769
    if data.len() >= 1586 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod3b(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // ImageArea at offset 16

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ISO2 at offset 605

    // ShutterCount at offset 637
    if data.len() >= 1278 {
        // TODO: Handle format int32u
    }

    // ShutterCount at offset 639
    if data.len() >= 1282 {
        // TODO: Handle format int32u
    }

    // PreFlashReturnStrength at offset 650

    // NikonImageSize at offset 732.1

    // ImageQuality at offset 732.2

    // CustomSettingsD3 at offset 778
    if data.len() >= 1604 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod3x(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ISO2 at offset 605

    // ShutterCount at offset 640
    if data.len() >= 1284 {
        // TODO: Handle format int32u
    }

    // CustomSettingsD3X at offset 779
    if data.len() >= 1606 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod3s(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // ImageArea at offset 16

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ISO2 at offset 545

    // ShutterCount at offset 578
    if data.len() >= 1160 {
        // TODO: Handle format int32u
    }

    // JPGCompression at offset 671.1

    // CustomSettingsD3S at offset 718
    if data.len() >= 1490 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod300a(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // ISO2 at offset 604

    // ShutterCount at offset 633
    if data.len() >= 1270 {
        // TODO: Handle format int32u
    }

    // AFFineTuneAdj at offset 721
    if data.len() >= 1444 {
        // TODO: Handle format int16u
    }

    // CustomSettingsD300 at offset 790
    if data.len() >= 1628 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod300b(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ISO2 at offset 613

    // ShutterCount at offset 644
    if data.len() >= 1292 {
        // TODO: Handle format int32u
    }

    // CustomSettingsD300 at offset 802
    if data.len() >= 1652 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod300s(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ISO2 at offset 613

    // ShutterCount at offset 646
    if data.len() >= 1296 {
        // TODO: Handle format int32u
    }

    // CustomSettingsD300S at offset 804
    if data.len() >= 1656 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod700(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ISO2 at offset 613

    // ShutterCount at offset 647
    if data.len() >= 1298 {
        // TODO: Handle format int32u
    }

    // CustomSettingsD700 at offset 804
    if data.len() >= 1704 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod780(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // OrientOffset at offset 156
    if data.len() >= 316 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_shotinfod7500(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // OrientOffset at offset 160
    if data.len() >= 324 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_shotinfod800(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // RepeatingFlashOutputExternal at offset 1216

    // RepeatingFlashRateExternal at offset 1218

    // RepeatingFlashCountExternal at offset 1219

    // FlashExposureComp2 at offset 1234
    if data.len() >= 2469 {
        // TODO: Handle format int8s
    }

    // RepeatingFlashRateBuilt-in at offset 1242

    // RepeatingFlashCountBuilt-in at offset 1243

    // ShutterCount at offset 1531
    if data.len() >= 3066 {
        // TODO: Handle format int32u
    }

    // CustomSettingsD800 at offset 1772
    if data.len() >= 3640 {
        // TODO: Handle format undef
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_shotinfod810(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // OrientationOffset at offset 132
    if data.len() >= 268 {
        // TODO: Handle format int32u
    }

    // SettingsOffset at offset 16
    if data.len() >= 36 {
        // TODO: Handle format int32u
    }

    // BracketingOffset at offset 36
    if data.len() >= 76 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ISOAutoOffset at offset 56
    if data.len() >= 116 {
        // TODO: Handle format int32u
    }

    // CustomSettingsOffset at offset 64
    if data.len() >= 132 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_shotinfod850(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // MenuSettingsOffset at offset 16
    if data.len() >= 36 {
        // TODO: Handle format int32u
    }

    // OrientationOffset at offset 160
    if data.len() >= 324 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // MoreSettingsOffset at offset 76
    if data.len() >= 156 {
        // TODO: Handle format int32u
    }

    // CustomSettingsOffset at offset 88
    if data.len() >= 180 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_shotinfod5000(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ISO2 at offset 693

    // ShutterCount at offset 726
    if data.len() >= 1456 {
        // TODO: Handle format int32u
    }

    // CustomSettingsD5000 at offset 888
    if data.len() >= 1844 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod5100(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // CustomSettingsD5100 at offset 1031
    if data.len() >= 2130 {
        // TODO: Handle format undef
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ShutterCount at offset 801
    if data.len() >= 1606 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_shotinfod5200(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // ShutterCount at offset 3032
    if data.len() >= 6068 {
        // TODO: Handle format int32u
    }

    // CustomSettingsD5200 at offset 3285
    if data.len() >= 6638 {
        // TODO: Handle format undef
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_shotinfod7000(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // CustomSettingsD7000 at offset 1028
    if data.len() >= 2152 {
        // TODO: Handle format undef
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // ShutterCount at offset 800
    if data.len() >= 1604 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_shotinfod4(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // CustomSettingsD4 at offset 1873
    if data.len() >= 3858 {
        // TODO: Handle format undef
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_shotinfod4s(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // OrientationInfo at offset 13579
    if data.len() >= 27182 {
        // TODO: Handle format undef
    }

    // Rotation at offset 13971

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // SecondarySlotFunction at offset 464

    // AEBracketingSteps at offset 5964

    // WBBracketingSteps at offset 5965

    // ReleaseMode at offset 6221

    // CustomSettingsD4S at offset 6301
    if data.len() >= 12714 {
        // TODO: Handle format undef
    }

    // MultiSelectorLiveViewMode at offset 6338

    // ISOAutoShutterTime at offset 6378

    // ISOAutoHiLimit at offset 6379

    // CustomSettingsD4S at offset 6461
    if data.len() >= 13034 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_shotinfod500(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // RotationInfoOffset at offset 16
    if data.len() >= 36 {
        // TODO: Handle format int32u
    }

    // OrientationOffset at offset 160
    if data.len() >= 324 {
        // TODO: Handle format int32u
    }

    // OtherOffset at offset 168
    if data.len() >= 340 {
        // TODO: Handle format int32u
    }

    // JPGInfoOffset at offset 20
    if data.len() >= 44 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // BracketingOffset at offset 44
    if data.len() >= 92 {
        // TODO: Handle format int32u
    }

    // ShootingMenuOffset at offset 80
    if data.len() >= 164 {
        // TODO: Handle format int32u
    }

    // CustomSettingsOffset at offset 88
    if data.len() >= 180 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_shotinfod6(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // OrientationOffset at offset 156
    if data.len() >= 316 {
        // TODO: Handle format int32u
    }

    // IntervalOffset at offset 164
    if data.len() >= 332 {
        // TODO: Handle format int32u
    }

    // NumberOffsets at offset 36
    if data.len() >= 76 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion at offset 4
    if data.len() >= 24 {
        // TODO: Handle format string
    }

    // SequenceOffset at offset 48
    if data.len() >= 100 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_shotinfod610(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // CustomSettingsD610 at offset 1999
    if data.len() >= 4094 {
        // TODO: Handle format undef
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_shotinfoz6iii(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // OrientationOffset at offset 136
    if data.len() >= 276 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion2 at offset 14
    if data.len() >= 44 {
        // TODO: Handle format string
    }

    // MenuOffset at offset 144
    if data.len() >= 292 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion3 at offset 24
    if data.len() >= 64 {
        // TODO: Handle format string
    }

    // NumberOffsets at offset 36
    if data.len() >= 76 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion at offset 4
    if data.len() >= 24 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_shotinfoz7ii(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // OrientationOffset at offset 136
    if data.len() >= 276 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion2 at offset 14
    if data.len() >= 44 {
        // TODO: Handle format string
    }

    // OrientationOffset at offset 152
    if data.len() >= 308 {
        // TODO: Handle format int32u
    }

    // MenuOffset at offset 160
    if data.len() >= 324 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion3 at offset 24
    if data.len() >= 64 {
        // TODO: Handle format string
    }

    // NumberOffsets at offset 36
    if data.len() >= 76 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion at offset 4
    if data.len() >= 24 {
        // TODO: Handle format string
    }

    // IntervalOffset at offset 48
    if data.len() >= 100 {
        // TODO: Handle format int32u
    }

    // PortraitOffset at offset 56
    if data.len() >= 116 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_shotinfoz8(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // AutoCaptureOffset at offset 128
    if data.len() >= 260 {
        // TODO: Handle format int32u
    }

    // OrientOffset at offset 132
    if data.len() >= 268 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion2 at offset 14
    if data.len() >= 44 {
        // TODO: Handle format string
    }

    // MenuOffset at offset 140
    if data.len() >= 284 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion3 at offset 24
    if data.len() >= 64 {
        // TODO: Handle format string
    }

    // NumberOffsets at offset 36
    if data.len() >= 76 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion at offset 4
    if data.len() >= 24 {
        // TODO: Handle format string
    }

    // SequenceOffset at offset 48
    if data.len() >= 100 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_shotinfoz9(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // AutoCaptureOffset at offset 128
    if data.len() >= 260 {
        // TODO: Handle format int32u
    }

    // OrientOffset at offset 132
    if data.len() >= 268 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion2 at offset 14
    if data.len() >= 44 {
        // TODO: Handle format string
    }

    // MenuOffset at offset 140
    if data.len() >= 284 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion3 at offset 24
    if data.len() >= 64 {
        // TODO: Handle format string
    }

    // NumberOffsets at offset 36
    if data.len() >= 76 {
        // TODO: Handle format int32u
    }

    // FirmwareVersion at offset 4
    if data.len() >= 24 {
        // TODO: Handle format string
    }

    // SequenceOffset at offset 48
    if data.len() >= 100 {
        // TODO: Handle format int32u
    }

    // Offset13 at offset 88
    if data.len() >= 180 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_shotinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // VR_0x66 at offset 102
    if data.len() >= 205 {
        // TODO: Handle format int8u
    }

    // ShutterCount at offset 106
    if data.len() >= 216 {
        // TODO: Handle format int32u
    }

    // DeletedImageCount at offset 110
    if data.len() >= 224 {
        // TODO: Handle format int32u
    }

    // VibrationReduction at offset 117
    if data.len() >= 235 {
        // TODO: Handle format int8u
    }

    // VibrationReduction at offset 130
    if data.len() >= 261 {
        // TODO: Handle format int8u
    }

    // DistortionControl at offset 16

    // ShutterCount at offset 343
    if data.len() >= 690 {
        // TODO: Handle format undef
    }

    // FirmwareVersion at offset 4
    if data.len() >= 18 {
        // TODO: Handle format string
    }

    // VibrationReduction at offset 430
    if data.len() >= 861 {
        // TODO: Handle format int8u
    }

    // ShutterCount at offset 589
    if data.len() >= 1182 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_nikon_colorbalance1(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_RBGGLevels at offset 0
    if data.len() >= 8 {
        if let Ok(values) = read_int16u_array(&data[0..8], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RBGGLevels".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_nikon_colorbalance2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_RGGBLevels at offset 0
    if data.len() >= 8 {
        if let Ok(values) = read_int16u_array(&data[0..8], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGGBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_nikon_colorbalance3(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_RGBGLevels at offset 0
    if data.len() >= 8 {
        if let Ok(values) = read_int16u_array(&data[0..8], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBGLevels".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_nikon_colorbalance4(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // WB_GRBGLevels at offset 0
    if data.len() >= 8 {
        if let Ok(values) = read_int16u_array(&data[0..8], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_GRBGLevels".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_nikon_colorbalanceunknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorBalanceVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_colorbalanceunknown2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorBalanceVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_nikon_lensdata00(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensDataVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // MaxApertureAtMinFocal at offset 10

    // MaxApertureAtMaxFocal at offset 11

    // LensIDNumber at offset 6

    // LensFStops at offset 7

    // MinFocalLength at offset 8

    // MaxFocalLength at offset 9

    Ok(tags)
}

fn process_nikon_lensdata01(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensDataVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FocalLength at offset 10

    // LensIDNumber at offset 11

    // LensFStops at offset 12

    // MinFocalLength at offset 13

    // MaxFocalLength at offset 14

    // MaxApertureAtMinFocal at offset 15

    // MaxApertureAtMaxFocal at offset 16

    // EffectiveMaxAperture at offset 18

    // ExitPupilPosition at offset 4

    // AFAperture at offset 5

    // FocusPosition at offset 8

    // FocusDistance at offset 9

    Ok(tags)
}

fn process_nikon_lensdata0204(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensDataVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FocusDistance at offset 10

    // FocalLength at offset 11

    // LensIDNumber at offset 12

    // LensFStops at offset 13

    // MinFocalLength at offset 14

    // MaxFocalLength at offset 15

    // MaxApertureAtMinFocal at offset 16

    // MaxApertureAtMaxFocal at offset 17

    // EffectiveMaxAperture at offset 19

    // ExitPupilPosition at offset 4

    // AFAperture at offset 5

    // FocusPosition at offset 8

    Ok(tags)
}

fn process_nikon_lensdata0400(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensDataVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // LensModel at offset 394
    if data.len() >= 916 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_lensdata0402(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensDataVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // LensModel at offset 395
    if data.len() >= 918 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_lensdata0403(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensDataVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // LensModel at offset 684
    if data.len() >= 1496 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_lensdata0800(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensDataVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FocusDistance at offset 11

    // FocalLength at offset 12

    // LensIDNumber at offset 13

    // LensFStops at offset 14

    // MinFocalLength at offset 15

    // MaxFocalLength at offset 16

    // MaxApertureAtMinFocal at offset 17

    // MaxApertureAtMaxFocal at offset 18

    // MCUVersion at offset 19

    // EffectiveMaxAperture at offset 20

    // OldLensData at offset 3
    if data.len() >= 40 {
        // TODO: Handle format undef
    }

    // ExitPupilPosition at offset 4

    // NewLensData at offset 47
    if data.len() >= 128 {
        // TODO: Handle format undef
    }

    // LensID at offset 48
    if data.len() >= 98 {
        // TODO: Handle format int16u
    }

    // AFAperture at offset 5

    // LensFirmwareVersion at offset 52
    if data.len() >= 106 {
        // TODO: Handle format int16u
    }

    // MaxAperture at offset 54
    if data.len() >= 110 {
        // TODO: Handle format int16u
    }

    // FNumber at offset 56
    if data.len() >= 114 {
        // TODO: Handle format int16u
    }

    // FocalLength at offset 60
    if data.len() >= 122 {
        // TODO: Handle format int16u
    }

    // FocusDistanceRangeWidth at offset 76
    if data.len() >= 153 {
        // TODO: Handle format int8u
    }

    // FocusDistance at offset 78
    if data.len() >= 158 {
        // TODO: Handle format int16u
    }

    // LensDriveEnd at offset 86
    if data.len() >= 173 {
        // TODO: Handle format int8u
    }

    // FocusStepsFromInfinity at offset 88
    if data.len() >= 177 {
        // TODO: Handle format int8u
    }

    // LensPositionAbsolute at offset 90
    if data.len() >= 184 {
        // TODO: Handle format int32s
    }

    // LensMountType at offset 95
    if data.len() >= 191 {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_nikon_lensdataunknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensDataVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_flashinfo0100(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FlashInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FlashFocalLength at offset 11

    // RepeatingFlashRate at offset 12

    // RepeatingFlashCount at offset 13

    // FlashGNDistance at offset 14

    // FlashGroupAControlMode at offset 15

    // FlashGroupBControlMode at offset 16

    // FlashSource at offset 4

    // ExternalFlashFirmware at offset 6
    if data.len() >= 14 {
        // TODO: Handle format int8u
    }

    // ExternalFlashFlags at offset 8

    // FlashCommanderMode at offset 9.1

    // FlashControlMode at offset 9.2

    Ok(tags)
}

fn process_nikon_flashinfo0102(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FlashInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FlashFocalLength at offset 12

    // RepeatingFlashRate at offset 13

    // RepeatingFlashCount at offset 14

    // FlashGNDistance at offset 15

    // FlashGroupAControlMode at offset 16.1

    // FlashGroupBControlMode at offset 17.1

    // FlashGroupCControlMode at offset 17.2

    // FlashSource at offset 4

    // ExternalFlashFirmware at offset 6
    if data.len() >= 14 {
        // TODO: Handle format int8u
    }

    // ExternalFlashFlags at offset 8

    // FlashCommanderMode at offset 9.1

    // FlashControlMode at offset 9.2

    Ok(tags)
}

fn process_nikon_flashinfo0103(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FlashInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FlashFocalLength at offset 12

    // RepeatingFlashRate at offset 13

    // RepeatingFlashCount at offset 14

    // FlashGNDistance at offset 15

    // FlashColorFilter at offset 16

    // FlashGroupAControlMode at offset 17.1

    // FlashGroupBControlMode at offset 18.1

    // FlashGroupCControlMode at offset 18.2

    // ExternalFlashCompensation at offset 27
    if data.len() >= 55 {
        // TODO: Handle format int8s
    }

    // FlashExposureComp3 at offset 29
    if data.len() >= 59 {
        // TODO: Handle format int8s
    }

    // FlashExposureComp4 at offset 39
    if data.len() >= 79 {
        // TODO: Handle format int8s
    }

    // FlashSource at offset 4

    // ExternalFlashFirmware at offset 6
    if data.len() >= 14 {
        // TODO: Handle format int8u
    }

    // ExternalFlashFlags at offset 8

    // FlashCommanderMode at offset 9.1

    // FlashControlMode at offset 9.2

    Ok(tags)
}

fn process_nikon_flashinfo0106(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FlashInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FlashFocalLength at offset 12

    // RepeatingFlashRate at offset 13

    // RepeatingFlashCount at offset 14

    // FlashGNDistance at offset 15

    // FlashColorFilter at offset 16

    // FlashGroupAControlMode at offset 17.1

    // FlashGroupBControlMode at offset 18.1

    // FlashGroupCControlMode at offset 18.2

    // FlashSource at offset 4

    // ExternalFlashFirmware at offset 6
    if data.len() >= 14 {
        // TODO: Handle format int8u
    }

    // ExternalFlashFlags at offset 8

    // FlashCommanderMode at offset 9.1

    // FlashControlMode at offset 9.2

    Ok(tags)
}

fn process_nikon_flashinfo0107(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FlashInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FlashCompensation at offset 10
    if data.len() >= 21 {
        // TODO: Handle format int8s
    }

    // FlashFocalLength at offset 12

    // RepeatingFlashRate at offset 13

    // RepeatingFlashCount at offset 14

    // FlashGNDistance at offset 15

    // FlashGroupAControlMode at offset 17.1

    // FlashGroupBControlMode at offset 18.1

    // FlashGroupCControlMode at offset 18.2

    // FlashSource at offset 4

    // ExternalFlashFirmware at offset 6
    if data.len() >= 14 {
        // TODO: Handle format int8u
    }

    // ExternalFlashZoomOverride at offset 8.1

    // ExternalFlashStatus at offset 8.2

    // ExternalFlashReadyState at offset 9.1

    Ok(tags)
}

fn process_nikon_flashinfo0300(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FlashInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // FlashCompensation at offset 10
    if data.len() >= 21 {
        // TODO: Handle format int8s
    }

    // RepeatingFlashRate at offset 13

    // RepeatingFlashCount at offset 14

    // FlashGNDistance at offset 15

    // FlashColorFilter at offset 16

    // FlashGroupAControlMode at offset 17.1

    // FlashGroupBControlMode at offset 18.1

    // FlashGroupCControlMode at offset 18.2

    // FlashOutput at offset 33

    // FlashIlluminationPattern at offset 37

    // FlashFocalLength at offset 38

    // FlashSource at offset 4

    // ExternalFlashFirmware at offset 6
    if data.len() >= 14 {
        // TODO: Handle format int8u
    }

    // ExternalFlashFlags at offset 8

    // FlashCommanderMode at offset 9.1

    // FlashControlMode at offset 9.2

    Ok(tags)
}

fn process_nikon_flashinfounknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FlashInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_nikon_multiexposure(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MultiExposureVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // MultiExposureMode at offset 1

    // MultiExposureAutoGain at offset 3

    Ok(tags)
}

fn process_nikon_multiexposure2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MultiExposureVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format string
    }

    // MultiExposureMode at offset 1

    // MultiExposureOverlayMode at offset 3

    Ok(tags)
}

fn process_nikon_afinfo2v0100(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFInfo2Version at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // AFImageWidth at offset 16
    if data.len() >= 34 {
        // TODO: Handle format int16u
    }

    // AFImageHeight at offset 18
    if data.len() >= 38 {
        // TODO: Handle format int16u
    }

    // AFAreaXPosition at offset 20
    if data.len() >= 42 {
        // TODO: Handle format int16u
    }

    // AFAreaYPosition at offset 22
    if data.len() >= 46 {
        // TODO: Handle format int16u
    }

    // AFAreaWidth at offset 24
    if data.len() >= 50 {
        // TODO: Handle format int16u
    }

    // AFAreaHeight at offset 26
    if data.len() >= 54 {
        // TODO: Handle format int16u
    }

    // AFDetectionMethod at offset 4

    // FocusPointSchema at offset 6

    Ok(tags)
}

fn process_nikon_afinfo2v0101(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFInfo2Version at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // AFDetectionMethod at offset 4

    // FocusPointSchema at offset 6

    // AFImageWidth at offset 70
    if data.len() >= 142 {
        // TODO: Handle format int16u
    }

    // AFImageHeight at offset 72
    if data.len() >= 146 {
        // TODO: Handle format int16u
    }

    // AFAreaXPosition at offset 74
    if data.len() >= 150 {
        // TODO: Handle format int16u
    }

    // AFAreaYPosition at offset 76
    if data.len() >= 154 {
        // TODO: Handle format int16u
    }

    // AFAreaWidth at offset 78
    if data.len() >= 158 {
        // TODO: Handle format int16u
    }

    // AFAreaHeight at offset 80
    if data.len() >= 162 {
        // TODO: Handle format int16u
    }

    // ContrastDetectAFInFocus at offset 82

    Ok(tags)
}

fn process_nikon_afinfo2v0200(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFInfo2Version at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // AFAreaMode at offset 5

    // PhaseDetectAF at offset 6

    Ok(tags)
}

fn process_nikon_afinfo2v0300(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFInfo2Version at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // AFDetectionMethod at offset 4

    // AFImageWidth at offset 42
    if data.len() >= 86 {
        // TODO: Handle format int16u
    }

    // AFImageHeight at offset 44
    if data.len() >= 90 {
        // TODO: Handle format int16u
    }

    // AFAreaXPosition at offset 46
    if data.len() >= 94 {
        // TODO: Handle format int16u
    }

    // AFAreaYPosition at offset 48
    if data.len() >= 98 {
        // TODO: Handle format int16u
    }

    // AFAreaWidth at offset 50
    if data.len() >= 102 {
        // TODO: Handle format int16u
    }

    // AFAreaHeight at offset 52
    if data.len() >= 106 {
        // TODO: Handle format int16u
    }

    // FocusPointSchema at offset 6

    // AFCoordinatesAvailable at offset 7

    Ok(tags)
}

fn process_nikon_afinfo2v0400(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFInfo2Version at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // AFDetectionMethod at offset 4

    // AFAreaMode at offset 5

    // AFImageWidth at offset 62
    if data.len() >= 126 {
        // TODO: Handle format int16u
    }

    // AFImageHeight at offset 64
    if data.len() >= 130 {
        // TODO: Handle format int16u
    }

    // AFAreaXPosition at offset 66
    if data.len() >= 134 {
        // TODO: Handle format int16u
    }

    // AFAreaYPosition at offset 68
    if data.len() >= 138 {
        // TODO: Handle format int16u
    }

    // AFCoordinatesAvailable at offset 7

    // AFAreaWidth at offset 70
    if data.len() >= 142 {
        // TODO: Handle format int16u
    }

    // AFAreaHeight at offset 72
    if data.len() >= 146 {
        // TODO: Handle format int16u
    }

    // FocusResult at offset 74

    Ok(tags)
}

fn process_nikon_fileinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FileInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // DirectoryNumber at offset 3

    // FileNumber at offset 4

    Ok(tags)
}

fn process_nikon_aftune(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFFineTune at offset 0

    // AFFineTuneIndex at offset 1

    // AFFineTuneAdj at offset 2
    if data.len() >= 5 {
        // TODO: Handle format int8s
    }

    // AFFineTuneAdjTele at offset 3
    if data.len() >= 7 {
        // TODO: Handle format int8s
    }

    Ok(tags)
}

fn process_nikon_retouchinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // RetouchInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // RetouchNEFProcessing at offset 5

    Ok(tags)
}

fn process_nikon_barometerinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // BarometerInfoVersion at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // Altitude at offset 6
    if data.len() >= 16 {
        // TODO: Handle format int32s
    }

    Ok(tags)
}

fn process_nikon_captureoffsets(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_nikon_captureoutput(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

// Stub functions for tables not extracted by tag kit
fn process_nikon_previewifd(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_nikon_scan(data: &[u8], _byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

pub fn process_tag_0x0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x11_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x11_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_previewifd(data, byte_order)
}

pub fn process_tag_0x14_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x14_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x1f_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x1f_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_vrinfo(data, byte_order)
}

pub fn process_tag_0x21_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x21_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_facedetect(data, byte_order)
}

pub fn process_tag_0x23_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x23_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x24_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x24_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_worldtime(data, byte_order)
}

pub fn process_tag_0x25_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x25_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_isoinfo(data, byte_order)
}

pub fn process_tag_0x2b_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2b_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_distortinfo(data, byte_order)
}

pub fn process_tag_0x2c_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2c_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_unknowninfo(data, byte_order)
}

pub fn process_tag_0x32_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x32_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_unknowninfo2(data, byte_order)
}

pub fn process_tag_0x35_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x35_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x39_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x39_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_locationinfo(data, byte_order)
}

pub fn process_tag_0x4e_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4e_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::NikonSettings::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x51_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x51_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_makernotes0x51(data, byte_order)
}

pub fn process_tag_0x56_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x56_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_makernotes0x56(data, byte_order)
}

pub fn process_tag_0x88_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x88_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x91_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x91_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    match count {
        // Runtime condition not yet supported: $$valPt =~ /^0209/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD40
        // Runtime condition not yet supported: $$valPt =~ /^0208/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD80
        // Runtime condition not yet supported: $$valPt =~ /^0213/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD90
        5399 => {
            debug!("Matched count 5399 for variant nikon_shotinfod3a");
            process_nikon_shotinfod3a(data, byte_order)
        }
        5408 => {
            debug!("Matched count 5408 for variant nikon_shotinfod3b");
            process_nikon_shotinfod3b(data, byte_order)
        }
        5409 => {
            debug!("Matched count 5409 for variant nikon_shotinfod3x");
            process_nikon_shotinfod3x(data, byte_order)
        }
        5356 => {
            debug!("Matched count 5356 for variant nikon_shotinfod3s");
            process_nikon_shotinfod3s(data, byte_order)
        }
        5291 => {
            debug!("Matched count 5291 for variant nikon_shotinfod300a");
            process_nikon_shotinfod300a(data, byte_order)
        }
        5303 => {
            debug!("Matched count 5303 for variant nikon_shotinfod300b");
            process_nikon_shotinfod300b(data, byte_order)
        }
        5311 => {
            debug!("Matched count 5311 for variant nikon_shotinfod300s");
            process_nikon_shotinfod300s(data, byte_order)
        }
        5312 => {
            debug!("Matched count 5312 for variant nikon_shotinfod700");
            process_nikon_shotinfod700(data, byte_order)
        }
        // Runtime condition not yet supported: $$valPt =~ /^0245/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD780
        // Runtime condition not yet supported: $$valPt =~ /^0242/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD7500
        // Runtime condition not yet supported: $$valPt =~ /^0222/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD800
        // Runtime condition not yet supported: $$valPt =~ /^0233/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD810
        // Runtime condition not yet supported: $$valPt =~ /^0243/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD850
        6745 => {
            debug!("Matched count 6745 for variant nikon_shotinfod5000");
            process_nikon_shotinfod5000(data, byte_order)
        }
        8902 => {
            debug!("Matched count 8902 for variant nikon_shotinfod5100");
            process_nikon_shotinfod5100(data, byte_order)
        }
        11587 => {
            debug!("Matched count 11587 for variant nikon_shotinfod5200");
            process_nikon_shotinfod5200(data, byte_order)
        }
        // Runtime condition not yet supported: $$valPt =~ /^0220/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD7000
        // Runtime condition not yet supported: $$valPt =~ /^0223/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD4
        // Runtime condition not yet supported: $$valPt =~ /^0231/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD4S
        // Runtime condition not yet supported: $$valPt =~ /^023[89]/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD500
        // Runtime condition not yet supported: $$valPt =~ /^0246/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD6
        // Runtime condition not yet supported: $$valPt =~ /^0232/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoD610
        // Runtime condition not yet supported: $$valPt =~ /^08(09|10|11)/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoZ6III
        // Runtime condition not yet supported: $$valPt =~ /^080[0123478]/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoZ7II
        // Runtime condition not yet supported: $$valPt =~ /^0806/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoZ8
        // Runtime condition not yet supported: $$valPt =~ /^0805/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfoZ9
        // Runtime condition not yet supported: $$valPt =~ /^0[28]/
        // Would dispatch to: Image::ExifTool::Nikon::ShotInfo
        _ => Ok(vec![]), // No matching variant
    }
}

pub fn process_tag_0x97_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x97_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x98_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x98_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0xa8_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xa8_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0xb0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xb0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0xb7_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xb7_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0xb8_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xb8_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0xb9_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xb9_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_aftune(data, byte_order)
}

pub fn process_tag_0xbb_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xbb_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_retouchinfo(data, byte_order)
}

pub fn process_tag_0xbd_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xbd_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_picturecontrol(data, byte_order)
}

pub fn process_tag_0xc3_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc3_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_barometerinfo(data, byte_order)
}

pub fn process_tag_0x31f_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x31f_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::NikonCustom::SettingsZ9
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x34f_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x34f_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x3af_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x3af_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x4e7_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4e7_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::NikonCustom::SettingsZ6III
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xe00_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe00_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::PrintIM::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xe01_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe01_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::NikonCapture::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xe0e_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe0e_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_captureoffsets(data, byte_order)
}

pub fn process_tag_0xe10_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe10_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_scan(data, byte_order)
}

pub fn process_tag_0xe13_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe13_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0xe1d_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe1d_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::ICC_Profile::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xe1e_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe1e_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_nikon_captureoutput(data, byte_order)
}

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    match tag_id {
        1 => crate::implementations::print_conv::complex_expression_print_conv(value),
        2 => crate::implementations::print_conv::complex_expression_print_conv(value),
        13 => crate::implementations::print_conv::print_fraction(value),
        14 => crate::implementations::print_conv::complex_expression_print_conv(value),
        18 => crate::implementations::print_conv::print_fraction(value),
        19 => crate::implementations::print_conv::complex_expression_print_conv(value),
        23 => crate::implementations::print_conv::print_fraction(value),
        24 => crate::implementations::print_conv::decimal_1_print_conv(value),
        25 => crate::implementations::print_conv::complex_expression_print_conv(value),
        28 => crate::implementations::print_conv::print_fraction(value),
        38 => crate::implementations::print_conv::exposuretime_print_conv(value),
        42 => crate::implementations::print_conv::decimal_1_print_conv(value),
        50 => crate::implementations::print_conv::print_fraction(value),
        72 => crate::implementations::print_conv::focallength_print_conv(value),
        131 => crate::implementations::print_conv::complex_expression_print_conv(value),
        137 => crate::implementations::print_conv::complex_expression_print_conv(value),
        154 => crate::implementations::print_conv::complex_expression_print_conv(value),
        182 => crate::implementations::print_conv::complex_expression_print_conv(value),
        338 => crate::implementations::print_conv::complex_expression_print_conv(value),
        354 => crate::implementations::print_conv::complex_expression_print_conv(value),
        358 => crate::implementations::print_conv::complex_expression_print_conv(value),
        426 => crate::implementations::print_conv::complex_expression_print_conv(value),
        434 => crate::implementations::print_conv::complex_expression_print_conv(value),
        446 => crate::implementations::print_conv::complex_expression_print_conv(value),
        454 => crate::implementations::print_conv::complex_expression_print_conv(value),
        734 => crate::implementations::print_conv::complex_expression_print_conv(value),
        750 => crate::implementations::print_conv::complex_expression_print_conv(value),
        754 => crate::implementations::print_conv::complex_expression_print_conv(value),
        2048 => crate::implementations::print_conv::complex_expression_print_conv(value),
        _ => {
            // Fall back to shared handling
            if let Some(tag_kit) = NIKON_PM_TAG_KITS.get(&tag_id) {
                crate::implementations::generic::apply_fallback_print_conv(
                    tag_id,
                    value,
                    crate::to_print_conv_ref!(&tag_kit.print_conv),
                )
            } else {
                value.clone()
            }
        }
    }
}

/// Check if a tag has subdirectory processing
pub fn has_subdirectory(tag_id: u32) -> bool {
    if let Some(tag_kit) = NIKON_PM_TAG_KITS.get(&tag_id) {
        tag_kit.subdirectory.is_some()
    } else {
        false
    }
}

/// Process subdirectory tags and return multiple extracted tags
pub fn process_subdirectory(
    tag_id: u32,
    value: &TagValue,
    byte_order: ByteOrder,
) -> Result<HashMap<String, TagValue>> {
    use tracing::debug;
    let mut result = HashMap::new();

    debug!("process_subdirectory called for tag_id: 0x{:04x}", tag_id);

    if let Some(tag_kit) = NIKON_PM_TAG_KITS.get(&tag_id) {
        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {
            debug!("Found subdirectory processor for tag_id: 0x{:04x}", tag_id);
            let bytes = match value {
                TagValue::U16Array(arr) => {
                    debug!("Converting U16Array with {} elements to bytes", arr.len());
                    // Convert U16 array to bytes based on byte order
                    let mut bytes = Vec::with_capacity(arr.len() * 2);
                    for val in arr {
                        match byte_order {
                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),
                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),
                        }
                    }
                    bytes
                }
                TagValue::U8Array(arr) => arr.clone(),
                _ => return Ok(result), // Not array data
            };

            debug!("Calling processor with {} bytes", bytes.len());
            // Process subdirectory and collect all extracted tags
            match processor(&bytes, byte_order) {
                Ok(extracted_tags) => {
                    debug!("Processor returned {} tags", extracted_tags.len());
                    for (name, value) in extracted_tags {
                        result.insert(name, value);
                    }
                }
                Err(e) => {
                    debug!("Processor error: {:?}", e);
                }
            }
        } else {
            debug!(
                "No subdirectory processor found for tag_id: 0x{:04x}",
                tag_id
            );
        }
    } else {
        debug!("Tag not found in TAG_KITS: 0x{:04x}", tag_id);
    }

    Ok(result)
}
