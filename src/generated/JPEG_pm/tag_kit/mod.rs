//! Modular tag kits with embedded PrintConv for JPEG_pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: JPEG.pm table: AVI1
//!
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub mod datetime;
pub mod interop;
pub mod other;

use crate::expressions::ExpressionEvaluator;
use crate::tiff_types::ByteOrder;
use crate::types::{Result, TagValue};
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
    pub subdirectory: Option<SubDirectoryType>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// Type alias for subdirectory processor function
pub type SubDirectoryProcessor =
    fn(&[u8], ByteOrder, Option<&str>) -> Result<Vec<(String, TagValue)>>;

#[derive(Debug, Clone)]
pub enum SubDirectoryType {
    Binary { processor: SubDirectoryProcessor },
}

/// All tag kits for JPEG_pm
pub static JPEG_PM_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map: HashMap<u32, TagKitDef> = HashMap::new();

    // datetime tags
    for (id, tag_def) in datetime::get_datetime_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // interop tags
    for (id, tag_def) in interop::get_interop_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    map
});

// Helper functions for reading binary data
fn model_matches(model: &str, pattern: &str) -> bool {
    // ExifTool regexes are already in a compatible format
    // Just need to ensure proper escaping was preserved

    match regex::Regex::new(pattern) {
        Ok(re) => re.is_match(model),
        Err(e) => {
            tracing::warn!("Failed to compile model regex '{}': {}", pattern, e);
            false
        }
    }
}

fn format_matches(format: &str, pattern: &str) -> bool {
    if let Ok(re) = regex::Regex::new(pattern) {
        re.is_match(format)
    } else {
        tracing::warn!("Failed to compile format regex: {}", pattern);
        false
    }
}

fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16u array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {
    if data.len() < 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s".to_string(),
        ));
    }
    Ok(match byte_order {
        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),
        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),
    })
}

// Subdirectory processing functions
fn process_jpeg_avi1(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // InterleavedField at offset 0

    Ok(tags)
}

fn process_jpeg_ocad(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // OcadRevision at offset Rev
    if data.len() >= 12 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_jpeg_hdrgaininfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // HDRGainCurve at offset 10

    // HDRGainCurveSize at offset 6
    if data.len() >= 16 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_jpeg_hdr(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TagRatioImage at offset RatioImage

    // Alpha at offset alp

    // Beta at offset bet

    // CorrectionMethod at offset cor

    // Tagln0 at offset ln0

    // Tagln1 at offset ln1

    // Tags2n at offset s2n

    Ok(tags)
}

fn process_jpeg_adobecm(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_jpeg_adobe(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // APP14Flags0 at offset 1

    // APP14Flags1 at offset 2

    // ColorTransform at offset 3
    if data.len() >= 7 {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_jpeg_jps(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // JPSSeparation at offset 10
    if data.len() >= 24 {
        // TODO: Handle format int32u
    }

    // JPSFlags at offset 11

    // JPSType at offset 13

    // JPSComment at offset 16
    if data.len() >= 34 {
        // TODO: Handle format string
    }

    // HdrLength at offset 8
    if data.len() >= 18 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_jpeg_nitf(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // NITFVersion at offset 0
    if data.len() >= 2 {
        // TODO: Handle format int8u
    }

    // JPEGProcess at offset 10

    // StreamColor at offset 12

    // Flags at offset 14
    if data.len() >= 32 {
        // TODO: Handle format int32u
    }

    // ImageFormat at offset 2

    // BlocksPerRow at offset 3
    if data.len() >= 8 {
        // TODO: Handle format int16u
    }

    // BlocksPerColumn at offset 5
    if data.len() >= 12 {
        // TODO: Handle format int16u
    }

    // ImageColor at offset 7

    // ImageClass at offset 9

    Ok(tags)
}

fn process_jpeg_spiff(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SPIFFVersion at offset 0
    if data.len() >= 2 {
        // TODO: Handle format int8u
    }

    // ImageWidth at offset 10
    if data.len() >= 24 {
        // TODO: Handle format int32u
    }

    // ColorSpace at offset 14

    // Compression at offset 16

    // ResolutionUnit at offset 17

    // YResolution at offset 18
    if data.len() >= 40 {
        // TODO: Handle format int32u
    }

    // ProfileID at offset 2

    // XResolution at offset 22
    if data.len() >= 48 {
        // TODO: Handle format int32u
    }

    // ImageHeight at offset 6
    if data.len() >= 16 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

// Functions for tables not extracted by tag kit
fn process_jpeg_eppim(data: &[u8], _byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_jpeg_graphconv(data: &[u8], _byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_jpeg_mediajukebox(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

pub fn process_tag_0x0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $$valPt =~ /^JFIF\\0/
    // Would dispatch to: Image::ExifTool::JFIF::Main
    // Runtime condition not yet supported: $$valPt =~ /^JFXX\\0\\x10/
    // Would dispatch to: Image::ExifTool::JFIF::Extension
    // Runtime condition not yet supported: $$valPt =~ /^(II|MM).{4}HEAPJPGM/s
    // Would dispatch to: Image::ExifTool::CanonRaw::Main
    // Runtime condition not yet supported: $$valPt =~ /^AVI1/
    // Would dispatch to: Image::ExifTool::JPEG::AVI1
    // Runtime condition not yet supported: $$valPt =~ /^Ocad/
    // Would dispatch to: Image::ExifTool::JPEG::Ocad
    // Runtime condition not yet supported: $$valPt =~ /^Exif\\0/
    // Would dispatch to: Image::ExifTool::Exif::Main
    // Runtime condition not yet supported: $$valPt =~ m{^http://ns.adobe.com/xmp/extension/\\0}
    // Would dispatch to: Image::ExifTool::XMP::Main
    // Runtime condition not yet supported: $$valPt =~ /^http/ or $$valPt =~ /<exif:/
    // Would dispatch to: Image::ExifTool::XMP::Main
    // Runtime condition not yet supported: $$valPt =~ /^QVCI\\0/
    // Would dispatch to: Image::ExifTool::Casio::QVCI
    // Runtime condition not yet supported: $$valPt =~ /^FLIR\\0/
    // Would dispatch to: Image::ExifTool::FLIR::FFF
    // Runtime condition not yet supported: $$valPt =~ /^AROT\\0\\0.{4}/s
    // Would dispatch to: Image::ExifTool::JPEG::HDRGainInfo
    // Runtime condition not yet supported: $$valPt =~ /^HDR_RI /
    // Would dispatch to: Image::ExifTool::JPEG::HDR
    // Runtime condition not yet supported: $$valPt =~ /^JP/
    // Would dispatch to: Image::ExifTool::Jpeg2000::Main
    // Runtime condition not yet supported: $$valPt =~ /(\\[picture info\\]|Type=)/
    // Would dispatch to: Image::ExifTool::APP12::PictureInfo
    // Runtime condition not yet supported: $$valPt =~ /^Ducky/
    // Would dispatch to: Image::ExifTool::APP12::Ducky
    // Runtime condition not yet supported: $$valPt =~ /^(Photoshop 3.0\\0|Adobe_Photoshop2.5)/
    // Would dispatch to: Image::ExifTool::Photoshop::Main
    // Runtime condition not yet supported: $$valPt =~ /^Adobe_CM/
    // Would dispatch to: Image::ExifTool::JPEG::AdobeCM
    // Runtime condition not yet supported: $$valPt =~ /^Adobe/
    // Would dispatch to: Image::ExifTool::JPEG::Adobe
    // Runtime condition not yet supported: $$valPt =~ /^Q\\s*(\\d+)/
    // Would dispatch to: Image::ExifTool::JPEG::GraphConv
    // Runtime condition not yet supported: $$valPt =~ /^ICC_PROFILE\\0/
    // Would dispatch to: Image::ExifTool::ICC_Profile::Main
    // Runtime condition not yet supported: $$valPt =~ /^FPXR\\0/
    // Would dispatch to: Image::ExifTool::FlashPix::Main
    // Runtime condition not yet supported: $$valPt =~ /^MPF\\0/
    // Would dispatch to: Image::ExifTool::MPF::Main
    // Runtime condition not yet supported: $$valPt =~ /^....IJPEG\\0/s
    // Would dispatch to: Image::ExifTool::InfiRay::Version
    // Runtime condition not yet supported: $$valPt =~ /^(Meta|META|Exif)\\0\\0/
    // Would dispatch to: Image::ExifTool::Kodak::Meta
    // Runtime condition not yet supported: $$valPt =~ /^Stim\\0/
    // Would dispatch to: Image::ExifTool::Stim::Main
    // Runtime condition not yet supported: $$valPt =~ /^_JPSJPS_/
    // Would dispatch to: Image::ExifTool::JPEG::JPS
    // Runtime condition not yet supported: $$valPt =~ /^SCALADO\\0/
    // Would dispatch to: Image::ExifTool::Scalado::Main
    // Runtime condition not yet supported: $$valPt =~ /^FPXR\\0/
    // Would dispatch to: Image::ExifTool::FlashPix::Main
    // Runtime condition not yet supported: $$valPt =~ /^Qualcomm Dual Camera Attributes/
    // Would dispatch to: Image::ExifTool::Qualcomm::DualCamera
    // Runtime condition not yet supported: $$self{HasIJPEG}\"
    // Would dispatch to: Image::ExifTool::InfiRay::Factory
    // Runtime condition not yet supported: $$self{Make} eq \"DJI\" and $$valPt =~ /^\\xaa\\x55\\x12\\x06/
    // Would dispatch to: Image::ExifTool::DJI::ThermalParams
    // Runtime condition not yet supported: $$self{Make} eq \"DJI\" and $$valPt =~ /^(.{32})?.{32}\\x2c\\x01\\x20\\0/s
    // Would dispatch to: Image::ExifTool::DJI::ThermalParams2
    // Runtime condition not yet supported: $$self{Make} eq \"DJI\" and $$valPt =~ /^.{32}\\xaa\\x55\\x38\\0/s
    // Would dispatch to: Image::ExifTool::DJI::ThermalParams3
    // Runtime condition not yet supported: $$valPt =~ /^RMETA\\0/
    // Would dispatch to: Image::ExifTool::Ricoh::RMETA
    // Runtime condition not yet supported: $$valPt =~ /ssuniqueid\\0/
    // Would dispatch to: Image::ExifTool::Samsung::APP5
    // Runtime condition not yet supported: $$self{HasIJPEG}
    // Would dispatch to: Image::ExifTool::InfiRay::Picture
    // Runtime condition not yet supported: $$valPt =~ /^EPPIM\\0/
    // Would dispatch to: Image::ExifTool::JPEG::EPPIM
    // Runtime condition not yet supported: $$valPt =~ /^NTIF\\0/
    // Would dispatch to: Image::ExifTool::JPEG::NITF
    // Runtime condition not yet supported: $$valPt =~ /^TDHD\\x01\\0\\0\\0/
    // Would dispatch to: Image::ExifTool::HP::TDHD
    // Runtime condition not yet supported: $$valPt =~ /^GoPro\\0/
    // Would dispatch to: Image::ExifTool::GoPro::GPMF
    // Runtime condition not yet supported: $$self{HasIJPEG}
    // Would dispatch to: Image::ExifTool::InfiRay::MixMode
    // Runtime condition not yet supported: $$valPt =~ /^PENTAX \\0/
    // Would dispatch to: Image::ExifTool::Pentax::Main
    // Runtime condition not yet supported: $$valPt =~ /^HUAWEI\\0\\0/
    // Would dispatch to: Image::ExifTool::Unknown::Main
    // Runtime condition not yet supported: $$valPt =~ /^\\x1aQualcomm Camera Attributes/
    // Would dispatch to: Image::ExifTool::Qualcomm::Main
    // Runtime condition not yet supported: $$self{HasIJPEG}
    // Would dispatch to: Image::ExifTool::InfiRay::OpMode
    // Runtime condition not yet supported: $$valPt =~ /^DJI-DBG\\0/
    // Would dispatch to: Image::ExifTool::DJI::Info
    // Runtime condition not yet supported: $$valPt =~ /^SPIFF\\0/
    // Would dispatch to: Image::ExifTool::JPEG::SPIFF
    // Runtime condition not yet supported: $$self{HasIJPEG}
    // Would dispatch to: Image::ExifTool::InfiRay::Isothermal
    // Runtime condition not yet supported: $$valPt =~ /^SEAL\\0/
    // Would dispatch to: Image::ExifTool::XMP::SEAL
    // Runtime condition not yet supported: $$valPt =~ /^Media Jukebox\\0/
    // Would dispatch to: Image::ExifTool::JPEG::MediaJukebox
    // Runtime condition not yet supported: $$self{HasIJPEG}
    // Would dispatch to: Image::ExifTool::InfiRay::Sensor
    // Runtime condition not yet supported: $$valPt =~ /^SEAL\\0/
    // Would dispatch to: Image::ExifTool::XMP::SEAL
    // Runtime condition not yet supported: $$valPt =~ /AXS(!|\\*).{8}$/s
    // Would dispatch to: Image::ExifTool::AFCP::Main
    // Runtime condition not yet supported: $$valPt =~ /CANON OPTIONAL DATA\\0.{44}$/s
    // Would dispatch to: Image::ExifTool::CanonVRD::Main
    // Runtime condition not yet supported: $$valPt =~ /\\xa1\\xb2\\xc3\\xd4$/
    // Would dispatch to: Image::ExifTool::FotoStation::Main
    // Runtime condition not yet supported: $$valPt =~ /cbipcbbl$/
    // Would dispatch to: Image::ExifTool::PhotoMechanic::Main
    // Runtime condition not yet supported: $$valPt =~ /~\\0\\x04\\0zmie~\\0\\0\\x06.{4}[\\x10\\x18]\\x04$/s or $$valPt =~ /~\\0\\x04\\0zmie~\\0\\0\\x0a.{8}[\\x10\\x18]\\x08$/s
    // Would dispatch to: Image::ExifTool::MIE::Main
    // Runtime condition not yet supported: $$valPt =~ /QDIOBS$/
    // Would dispatch to: Image::ExifTool::Samsung::Trailer
    // Runtime condition not yet supported: $$valPt =~ /^(streamdata|vivo\\{\")/
    // Would dispatch to: Image::ExifTool::Trailer::Vivo
    Ok(vec![])
}

pub fn process_tag_0xc4a5_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc4a5_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::PrintIM::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    if let Some(tag_kit) = JPEG_PM_TAG_KITS.get(&tag_id) {
        crate::implementations::generic::apply_fallback_print_conv(
            tag_id,
            &tag_kit.name,
            "JPEG",
            value,
            crate::to_print_conv_ref!(&tag_kit.print_conv),
        )
    } else {
        value.clone()
    }
}

/// Apply ValueConv for a tag from this module
pub fn apply_value_conv(
    tag_id: u32,
    value: &TagValue,
    _errors: &mut Vec<String>,
) -> Result<TagValue> {
    match tag_id {
        0 => {
            if let Some(tag_kit) = JPEG_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "JPEG",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        2 => {
            if let Some(tag_kit) = JPEG_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "JPEG",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        _ => {
            // Fall back to missing handler for unknown expressions
            if let Some(tag_kit) = JPEG_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "JPEG",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
    }
}

/// Check if a tag has subdirectory processing
pub fn has_subdirectory(tag_id: u32) -> bool {
    if let Some(tag_kit) = JPEG_PM_TAG_KITS.get(&tag_id) {
        tag_kit.subdirectory.is_some()
    } else {
        false
    }
}

/// Process subdirectory tags and return multiple extracted tags
pub fn process_subdirectory(
    tag_id: u32,
    value: &TagValue,
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<HashMap<String, TagValue>> {
    use tracing::debug;
    let mut result = HashMap::new();

    debug!("process_subdirectory called for tag_id: 0x{:04x}", tag_id);

    if let Some(tag_kit) = JPEG_PM_TAG_KITS.get(&tag_id) {
        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {
            debug!("Found subdirectory processor for tag_id: 0x{:04x}", tag_id);
            let bytes = match value {
                TagValue::U16Array(arr) => {
                    debug!("Converting U16Array with {} elements to bytes", arr.len());
                    // Convert U16 array to bytes based on byte order
                    let mut bytes = Vec::with_capacity(arr.len() * 2);
                    for val in arr {
                        match byte_order {
                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),
                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),
                        }
                    }
                    bytes
                }
                TagValue::U8Array(arr) => arr.clone(),
                _ => return Ok(result), // Not array data
            };

            debug!("Calling processor with {} bytes", bytes.len());
            // Process subdirectory and collect all extracted tags
            match processor(&bytes, byte_order, model) {
                Ok(extracted_tags) => {
                    debug!("Processor returned {} tags", extracted_tags.len());
                    for (name, value) in extracted_tags {
                        result.insert(name, value);
                    }
                }
                Err(e) => {
                    debug!("Processor error: {:?}", e);
                }
            }
        } else {
            debug!(
                "No subdirectory processor found for tag_id: 0x{:04x}",
                tag_id
            );
        }
    } else {
        debug!("Tag not found in TAG_KITS: 0x{:04x}", tag_id);
    }

    Ok(result)
}
