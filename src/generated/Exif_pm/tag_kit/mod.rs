//! Modular tag kits with embedded PrintConv for Exif_pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: Exif.pm table: Composite
//!
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub mod camera;
pub mod color;
pub mod core;
pub mod datetime;
pub mod document;
pub mod exif_specific;
pub mod gps;
pub mod interop;
pub mod other;
pub mod thumbnail;
pub mod windows_xp;

use crate::expressions::ExpressionEvaluator;
use crate::tiff_types::ByteOrder;
use crate::types::{Result, TagValue};
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
    pub subdirectory: Option<SubDirectoryType>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// Type alias for subdirectory processor function
pub type SubDirectoryProcessor =
    fn(&[u8], ByteOrder, Option<&str>) -> Result<Vec<(String, TagValue)>>;

#[derive(Debug, Clone)]
pub enum SubDirectoryType {
    Binary { processor: SubDirectoryProcessor },
}

/// All tag kits for Exif_pm
pub static EXIF_PM_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map: HashMap<u32, TagKitDef> = HashMap::new();

    // camera tags
    for (id, tag_def) in camera::get_camera_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // color tags
    for (id, tag_def) in color::get_color_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // core tags
    for (id, tag_def) in core::get_core_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // datetime tags
    for (id, tag_def) in datetime::get_datetime_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // document tags
    for (id, tag_def) in document::get_document_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // exif_specific tags
    for (id, tag_def) in exif_specific::get_exif_specific_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // gps tags
    for (id, tag_def) in gps::get_gps_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // interop tags
    for (id, tag_def) in interop::get_interop_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // thumbnail tags
    for (id, tag_def) in thumbnail::get_thumbnail_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // windows_xp tags
    for (id, tag_def) in windows_xp::get_windows_xp_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    map
});

// Helper functions for reading binary data
fn model_matches(model: &str, pattern: &str) -> bool {
    // ExifTool regexes are already in a compatible format
    // Just need to ensure proper escaping was preserved

    match regex::Regex::new(pattern) {
        Ok(re) => re.is_match(model),
        Err(e) => {
            tracing::warn!("Failed to compile model regex '{}': {}", pattern, e);
            false
        }
    }
}

fn format_matches(format: &str, pattern: &str) -> bool {
    if let Ok(re) = regex::Regex::new(pattern) {
        re.is_match(format)
    } else {
        tracing::warn!("Failed to compile format regex: {}", pattern);
        false
    }
}

fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16u array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {
    if data.len() < 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s".to_string(),
        ));
    }
    Ok(match byte_order {
        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),
        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),
    })
}

// Subdirectory processing functions

// Functions for tables not extracted by tag kit
fn process_exif_main(data: &[u8], _byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

pub fn process_tag_0x14a_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x14a_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $$self{DIR_NAME} ne 'IFD0' or $$self{FILE_TYPE} ne 'TIFF' or $$self{Make} !~ /^SONY/ or not $$self{SubfileType} or $$self{SubfileType} != 1 or not $$self{Compression} or $$self{Compression} != 6 or not require Image::ExifTool::Sony or Image::ExifTool::Sony::SetARW($self, $valPt)
    // Would dispatch to: Unknown
    Ok(vec![])
}

pub fn process_tag_0x190_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x190_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Reference to Unknown table
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x2bc_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2bc_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::XMP::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x4748_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4748_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::Microsoft::Stitch
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x8290_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x8290_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::Kodak::IFD
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x83bb_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x83bb_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::IPTC::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x8568_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x8568_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::IPTC::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x8606_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x8606_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::Leaf::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x8649_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x8649_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::Photoshop::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x8769_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x8769_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Reference to Unknown table
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x8773_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x8773_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::ICC_Profile::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x8825_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x8825_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::GPS::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x888a_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x888a_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::Leaf::SubIFD
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x927c_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x927c_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module model condition: $$self{Make}=~/^EASTMAN KODAK/ and ($$self{Model}=~/CX(4200|4230|4300|4310|6200|6230)/ or # try to pick up similar models we haven't tested yet $$valPt=~/^\\0(\\x1a\\x18|\\x3a\\x08|\\x59\\xf8|\\x14\\x80)\\0/)
    // Would dispatch to: Image::ExifTool::Kodak::Type5
    // Cross-module model condition: $$self{Make}=~/^EASTMAN KODAK/ and $$self{Model}=~/DX3215/
    // Would dispatch to: Image::ExifTool::Kodak::Type6
    // Cross-module model condition: $$self{Make}=~/^EASTMAN KODAK/ and $$self{Model}=~/DX3700/
    // Would dispatch to: Image::ExifTool::Kodak::Type6
    // Cross-module model condition: $$self{Model}=~/(Kodak|PixPro)/i and $$valPt =~ /^II\\x2a\\0\\x08\\0\\0\\0.\\0\\0\\0/s
    // Would dispatch to: Image::ExifTool::Kodak::Type11
    // Cross-module model condition: $$self{Model}=~/(Kodak|PixPro)/i and $$valPt =~ /^MM\\0\\x2a\\0\\0\\0\\x08\\0\\0\\0./s
    // Would dispatch to: Image::ExifTool::Kodak::Type11
    // Cross-module model condition: $$valPt=~/^AOC\\0/ and $$self{Model} !~ /^PENTAX Optio ?[34]30RS\\s*$/
    // Would dispatch to: Image::ExifTool::Pentax::Main
    // Cross-module model condition: $$self{Make}=~/^SANYO/ and $$self{Model}!~/^(C4|J\\d|S\\d)\\b/
    // Would dispatch to: Image::ExifTool::Sanyo::Main
    // Cross-module model condition: $$self{Make}=~/^SANYO/ and $$self{Model}=~/^C4\\b/
    // Would dispatch to: Image::ExifTool::Sanyo::Main
    // Cross-module model condition: ($$self{Make}=~/^SONY/ or ($$self{Make}=~/^HASSELBLAD/ and $$self{Model}=~/^(HV|Stellar|Lusso|Lunar)/)) and $$valPt!~/^\\x01\\x00/
    // Would dispatch to: Image::ExifTool::Sony::Main
    // Runtime condition not yet supported: $$valPt =~ /^Apple iOS\\0/
    // Would dispatch to: Image::ExifTool::Apple::Main
    // Runtime condition not yet supported: $$valPt=~/^Nikon\\x00\\x02/
    // Would dispatch to: Image::ExifTool::Nikon::Main
    // Runtime condition not yet supported: $$self{Make} =~ /^Canon/
    // Would dispatch to: Image::ExifTool::Canon::Main
    // Runtime condition not yet supported: $$self{Make}=~/^CASIO/ and $$valPt!~/^(QVC|DCI)\\0/
    // Would dispatch to: Image::ExifTool::Casio::Main
    // Runtime condition not yet supported: $$valPt =~ /^(QVC|DCI)\\0/
    // Would dispatch to: Image::ExifTool::Casio::Type2
    // Runtime condition not yet supported: $$valPt =~ /^\\[ae_dbg_info:/
    // Would dispatch to: Image::ExifTool::DJI::Info
    // Runtime condition not yet supported: $$self{Make} eq \"DJI\" and $$valPt !~ /^(...\\@AMBA|DJI)/s
    // Would dispatch to: Image::ExifTool::DJI::Main
    // Runtime condition not yet supported: $$self{Make} =~ /^FLIR Systems/
    // Would dispatch to: Image::ExifTool::FLIR::Main
    // Runtime condition not yet supported: $$valPt =~ /^(FUJIFILM|GENERALE)/
    // Would dispatch to: Image::ExifTool::FujiFilm::Main
    // Runtime condition not yet supported: $$valPt =~ /^GE(\\0\\0|NIC\\0)/
    // Would dispatch to: Image::ExifTool::GE::Main
    // Runtime condition not yet supported: $$valPt =~ /^GE\\x0c\\0\\0\\0\\x16\\0\\0\\0/
    // Would dispatch to: Image::ExifTool::FujiFilm::Main
    // Runtime condition not yet supported: $$self{Make} eq \"Hasselblad\"
    // Would dispatch to: Image::ExifTool::Unknown::Main
    // Runtime condition not yet supported: $$valPt =~ /^(Hewlett-Packard|Vivitar)/
    // Would dispatch to: Image::ExifTool::HP::Main
    // Runtime condition not yet supported: $$valPt =~ /^610[\\0-\\4]/
    // Would dispatch to: Image::ExifTool::HP::Type2
    // Runtime condition not yet supported: $$valPt =~ /^IIII[\\x04|\\x05]\\0/
    // Would dispatch to: Image::ExifTool::HP::Type4
    // Runtime condition not yet supported: $$valPt =~ /^IIII\\x06\\0/
    // Would dispatch to: Image::ExifTool::HP::Type6
    // Runtime condition not yet supported: $$valPt =~ /^ISLMAKERNOTE000\\0/
    // Would dispatch to: Image::ExifTool::Unknown::Main
    // Runtime condition not yet supported: $$valPt=~/^JVC /
    // Would dispatch to: Image::ExifTool::JVC::Main
    // Runtime condition not yet supported: $$self{Make}=~/^(JVC|Victor)/ and $$valPt=~/^VER:/
    // Would dispatch to: Image::ExifTool::JVC::Text
    // Runtime condition not yet supported: $$self{Make}=~/^EASTMAN KODAK/ and $$valPt=~/^KDK INFO/
    // Would dispatch to: Image::ExifTool::Kodak::Main
    // Runtime condition not yet supported: $$self{Make}=~/^EASTMAN KODAK/ and $$valPt=~/^KDK/
    // Would dispatch to: Image::ExifTool::Kodak::Main
    // Runtime condition not yet supported: $$valPt =~ /^.{8}Eastman Kodak/s or $$valPt =~ /^\\x01\\0[\\0\\x01]\\0\\0\\0\\x04\\0[a-zA-Z]{4}/
    // Would dispatch to: Image::ExifTool::Kodak::Type2
    // Runtime condition not yet supported: $$self{Make} =~ /^EASTMAN KODAK/ and $$valPt =~ /^(?!MM|II).{12}\\x07/s and $$valPt !~ /^(MM|II|AOC)/
    // Would dispatch to: Image::ExifTool::Kodak::Type3
    // Runtime condition not yet supported: $$self{Make} =~ /^Eastman Kodak/ and $$valPt =~ /^.{41}JPG/s and $$valPt !~ /^(MM|II|AOC)/
    // Would dispatch to: Image::ExifTool::Kodak::Type4
    // Runtime condition not yet supported: $$self{Make}=~/Kodak/i and $$valPt =~ /^[CK][A-Z\\d]{3} ?[A-Z\\d]{1,2}\\d{2}[A-Z\\d]\\d{4}[ \\0]/
    // Would dispatch to: Image::ExifTool::Kodak::Type7
    // Runtime condition not yet supported: $$self{Make}=~/Kodak/i and ($$valPt =~ /^\\0[\\x02-\\x7f]..\\0[\\x01-\\x0c]\\0\\0/s or $$valPt =~ /^[\\x02-\\x7f]\\0..[\\x01-\\x0c]\\0..\\0\\0/s)
    // Would dispatch to: Image::ExifTool::Kodak::Type8
    // Runtime condition not yet supported: $$self{Make}=~/Kodak/i and $$valPt =~ /^MM\\0\\x2a\\0\\0\\0\\x08\\0.\\0\\0/
    // Would dispatch to: Image::ExifTool::Kodak::Type8
    // Runtime condition not yet supported: $$self{Make}=~/Kodak/i and $$valPt =~ /^(MM\\0\\x2a\\0\\0\\0\\x08|II\\x2a\\0\\x08\\0\\0\\0)/
    // Would dispatch to: Image::ExifTool::Kodak::Type8
    // Runtime condition not yet supported: $$valPt =~ m{^IIII[\\x02\\x03]\\0.{14}\\d{4}/\\d{2}/\\d{2} }s
    // Would dispatch to: Image::ExifTool::Kodak::Type9
    // Runtime condition not yet supported: $$self{Make}=~/Kodak/i and $$valPt =~ /^(MM\\0[\\x02-\\x7f]|II[\\x02-\\x7f]\\0)/
    // Would dispatch to: Image::ExifTool::Kodak::Type10
    // Runtime condition not yet supported: $$self{Make}=~/Kodak/i and $$valPt!~/^AOC\\0/
    // Would dispatch to: Image::ExifTool::Kodak::Unknown
    // Runtime condition not yet supported: $$valPt =~ /^KYOCERA/
    // Would dispatch to: Image::ExifTool::Unknown::Main
    // Runtime condition not yet supported: $$self{Make}=~/^(Konica Minolta|Minolta)/i and $$valPt !~ /^(MINOL|CAMER|MLY0|KC|\\+M\\+M|\\xd7)/
    // Would dispatch to: Image::ExifTool::Minolta::Main
    // Runtime condition not yet supported: $$valPt =~ /^(MINOL|CAMER)\\0/ and $$self{OlympusCAMER} = 1
    // Would dispatch to: Image::ExifTool::Olympus::Main
    // Runtime condition not yet supported: $$valPt=~/^MOT\\0/
    // Would dispatch to: Image::ExifTool::Motorola::Main
    // Runtime condition not yet supported: $$valPt=~/^Nikon\\x00\\x01/
    // Would dispatch to: Image::ExifTool::Nikon::Type2
    // Runtime condition not yet supported: $$self{Make}=~/^NIKON/i
    // Would dispatch to: Image::ExifTool::Nikon::Main
    // Runtime condition not yet supported: $$self{Make} eq \"Nintendo\"
    // Would dispatch to: Image::ExifTool::Nintendo::Main
    // Runtime condition not yet supported: $$valPt =~ /^(OLYMP|EPSON)\\0/
    // Would dispatch to: Image::ExifTool::Olympus::Main
    // Runtime condition not yet supported: $$valPt =~ /^OLYMPUS\\0/
    // Would dispatch to: Image::ExifTool::Olympus::Main
    // Runtime condition not yet supported: $$valPt =~ /^OM SYSTEM\\0/
    // Would dispatch to: Image::ExifTool::Olympus::Main
    // Runtime condition not yet supported: $$self{Make} eq \"LEICA\"
    // Would dispatch to: Image::ExifTool::Panasonic::Main
    // Runtime condition not yet supported: $$self{Make} =~ /^Leica Camera AG/ and $$valPt =~ /^LEICA\\0\\0\\0/
    // Would dispatch to: Image::ExifTool::Panasonic::Leica2
    // Runtime condition not yet supported: $$self{Make} =~ /^Leica Camera AG/ and $$valPt !~ /^LEICA/ and $$self{Model} ne \"S2\" and $$self{Model} ne \"LEICA M (Typ 240)\"
    // Would dispatch to: Image::ExifTool::Panasonic::Leica3
    // Runtime condition not yet supported: $$self{Make} =~ /^Leica Camera AG/ and $$valPt =~ /^LEICA0/
    // Would dispatch to: Image::ExifTool::Panasonic::Leica4
    // Runtime condition not yet supported: $$valPt =~ /^LEICA\\0[\\x01\\x04\\x05\\x06\\x07\\x10\\x1a]\\0/
    // Would dispatch to: Image::ExifTool::Panasonic::Leica5
    // Runtime condition not yet supported: ($$self{Make} eq 'Leica Camera AG' and ($$self{Model} eq 'S2' or $$self{Model} eq 'LEICA M (Typ 240)' or $$self{Model} eq 'LEICA S (Typ 006)'))
    // Would dispatch to: Image::ExifTool::Panasonic::Leica6
    // Runtime condition not yet supported: $$valPt =~ /^LEICA\\0\\x02\\xff/
    // Would dispatch to: Image::ExifTool::Panasonic::Leica6
    // Runtime condition not yet supported: $$valPt =~ /^LEICA\\0[\\x08\\x09\\x0a]\\0/
    // Would dispatch to: Image::ExifTool::Panasonic::Leica5
    // Runtime condition not yet supported: $$self{Make} =~ /^Leica Camera AG/ and $$valPt =~ /^LEICA\\0\\x02\\0/
    // Would dispatch to: Image::ExifTool::Panasonic::Leica9
    // Runtime condition not yet supported: $$valPt =~ /^LEICA CAMERA AG\\0/
    // Would dispatch to: Image::ExifTool::Panasonic::Main
    // Runtime condition not yet supported: $$valPt=~/^Panasonic/ and $$self{Model} ne \"DC-FT7\"
    // Would dispatch to: Image::ExifTool::Panasonic::Main
    // Runtime condition not yet supported: $$self{Make}=~/^Panasonic/ and $$valPt=~/^MKE/
    // Would dispatch to: Image::ExifTool::Panasonic::Type2
    // Runtime condition not yet supported: $$valPt=~/^Panasonic/
    // Would dispatch to: Image::ExifTool::Panasonic::Main
    // Runtime condition not yet supported: $$self{Make}=~/^Asahi/ and $$valPt!~/^AOC\\0/
    // Would dispatch to: Image::ExifTool::Pentax::Type2
    // Runtime condition not yet supported: $$self{Make}=~/^Asahi/
    // Would dispatch to: Image::ExifTool::Casio::Type2
    // Runtime condition not yet supported: $$self{Make}=~/^PENTAX/ and $$valPt=~/^\\d{3}/
    // Would dispatch to: Image::ExifTool::Pentax::Type4
    // Runtime condition not yet supported: $$valPt=~/^PENTAX \\0/
    // Would dispatch to: Image::ExifTool::Pentax::Main
    // Runtime condition not yet supported: $$valPt=~/^S1\\0{6}\\x0c\\0{3}/
    // Would dispatch to: Image::ExifTool::Pentax::S1
    // Runtime condition not yet supported: return undef unless $$valPt =~ /^(IIII.waR|MMMMRaw.)/s; $self->OverrideFileType($$self{TIFF_TYPE} = 'IIQ') if $count > 1000000; return 1;
    // Would dispatch to: Image::ExifTool::PhaseOne::Main
    // Runtime condition not yet supported: $$valPt =~ /^\\x01\\xf1([\\x02\\x03]\\x00)?/ and ($1 or $$self{Make} eq \"RECONYX\")
    // Would dispatch to: Image::ExifTool::Reconyx::Main
    // Runtime condition not yet supported: $$valPt =~ /^RECONYXUF\\0/
    // Would dispatch to: Image::ExifTool::Reconyx::Type2
    // Runtime condition not yet supported: $$valPt =~ /^RECONYXH2\\0/
    // Would dispatch to: Image::ExifTool::Reconyx::Type3
    // Runtime condition not yet supported: $$valPt=~/^RICOH\\0(II|MM)/
    // Would dispatch to: Image::ExifTool::Pentax::Main
    // Runtime condition not yet supported: $$self{Make} =~ /^(PENTAX )?RICOH/ and $$valPt =~ /^(Ricoh| |MM\\0\\x2a|II\\x2a\\0)/i and $$valPt !~ /^(MM\\0\\x2a\\0\\0\\0\\x08\\0.\\0\\0|II\\x2a\\0\\x08\\0\\0\\0.\\0\\0\\0)/s and $$self{Model} ne 'RICOH WG-M1'
    // Would dispatch to: Image::ExifTool::Ricoh::Main
    // Runtime condition not yet supported: $$self{Make} =~ /^(PENTAX )?RICOH/ and ($$self{Model} eq 'RICOH WG-M1' or $$valPt =~ /^(MM\\0\\x2a\\0\\0\\0\\x08\\0.\\0\\0|II\\x2a\\0\\x08\\0\\0\\0.\\0\\0\\0)/s)
    // Would dispatch to: Image::ExifTool::Ricoh::Type2
    // Runtime condition not yet supported: $$self{Make}=~/^RICOH/
    // Would dispatch to: Image::ExifTool::Ricoh::Text
    // Runtime condition not yet supported: $$valPt =~ /^STMN\\d{3}/
    // Would dispatch to: Image::ExifTool::Samsung::Main
    // Runtime condition not yet supported: uc $$self{Make} eq 'SAMSUNG' and ($$self{TIFF_TYPE} eq 'SRW' or $$valPt=~/^(\\0.\\0\\x01\\0\\x07\\0{3}\\x04|.\\0\\x01\\0\\x07\\0\\x04\\0{3})0100/s)
    // Would dispatch to: Image::ExifTool::Samsung::Type2
    // Runtime condition not yet supported: $$self{Make}=~/^SANYO/
    // Would dispatch to: Image::ExifTool::Sanyo::Main
    // Runtime condition not yet supported: return undef unless $$self{Make}=~/^(SIGMA|FOVEON)/i; # save version number in \"MakerNoteSigmaVer\" member variable $$self{MakerNoteSigmaVer} = $$valPt=~/^SIGMA\\0\\0\\0.(.)/s ? ord($1) : -1; return 1;
    // Would dispatch to: Image::ExifTool::Sigma::Main
    // Runtime condition not yet supported: $$valPt=~/^(SONY (DSC|CAM|MOBILE)|\\0\\0SONY PIC\\0|VHAB \\0)/
    // Would dispatch to: Image::ExifTool::Sony::Main
    // Runtime condition not yet supported: $$valPt=~/^SONY PI\\0/ and $$self{OlympusCAMER}=1
    // Would dispatch to: Image::ExifTool::Olympus::Main
    // Runtime condition not yet supported: $$valPt=~/^(PREMI)\\0/ and $$self{OlympusCAMER}=1
    // Would dispatch to: Image::ExifTool::Olympus::Main
    // Runtime condition not yet supported: $$valPt=~/^SONY PIC\\0/
    // Would dispatch to: Image::ExifTool::Sony::PIC
    // Runtime condition not yet supported: $$valPt =~ /^SEMC MS\\0/
    // Would dispatch to: Image::ExifTool::Sony::Ericsson
    // Runtime condition not yet supported: $$self{Make}=~/^SONY/
    // Would dispatch to: Image::ExifTool::Sony::SRF
    Ok(vec![])
}

pub fn process_tag_0x935c_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x935c_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::Photoshop::DocumentData
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x9999_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9999_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::JSON::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xa005_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xa005_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Reference to Unknown table
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xc4a5_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc4a5_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::PrintIM::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xc519_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc519_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::PLIST::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xc51b_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc51b_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_exif_main(data, byte_order)
}

pub fn process_tag_0xc634_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc634_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module model condition: $$valPt =~ /^(PENTAX |SAMSUNG)\\0/ and $$self{Model} =~ /\\b(K(-[57mrx]|(10|20|100|110|200)D|2000)|GX(10|20))\\b/
    // Would dispatch to: Image::ExifTool::Pentax::Main
    // Runtime condition not yet supported: $$self{TIFF_TYPE} =~ /^(ARW|SR2)$/
    // Would dispatch to: Image::ExifTool::Sony::SR2Private
    // Runtime condition not yet supported: $$valPt =~ /^Adobe\\0/
    // Would dispatch to: Image::ExifTool::DNG::AdobeData
    // Runtime condition not yet supported: $$valPt =~ /^(PENTAX |SAMSUNG)\\0/
    // Would dispatch to: Image::ExifTool::Pentax::Main
    // Runtime condition not yet supported: $$valPt =~ /^RICOH\\0(II|MM)/
    // Would dispatch to: Image::ExifTool::Pentax::Main
    // Runtime condition not yet supported: $$valPt =~ /^\\[ae_dbg_info:/
    // Would dispatch to: Image::ExifTool::DJI::Info
    Ok(vec![])
}

pub fn process_tag_0xc68c_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc68c_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::DNG::OriginalRaw
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xc68f_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc68f_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::ICC_Profile::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xc691_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc691_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::ICC_Profile::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xc6f5_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc6f5_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Reference to Unknown table
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xc7d5_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xc7d5_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Runtime condition not yet supported: $$valPt =~ /^Nikon\\0/
    // Would dispatch to: Image::ExifTool::Nikon::NEFInfo
    Ok(vec![])
}

pub fn process_tag_0xcd41_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xcd41_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::Jpeg2000::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xcd44_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xcd44_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::DNG::ImageSeq
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xcd47_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xcd47_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::DNG::ProfileDynamicRange
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xcea1_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xcea1_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::XMP::SEAL
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0xfe00_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<Vec<(String, TagValue)>> {
    use crate::expressions::ExpressionEvaluator;
    use crate::processor_registry::ProcessorContext;
    use tracing::debug;
    let count = data.len() / 2;
    debug!(
        "process_tag_0xfe00_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::Kodak::KDC_IFD
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    match tag_id {
        0 => crate::implementations::print_conv::fnumber_print_conv(value),
        2 => crate::implementations::print_conv::interopversion_print_conv(value),
        33434 => crate::implementations::print_conv::exposuretime_print_conv(value),
        33437 => crate::implementations::print_conv::fnumber_print_conv(value),
        37121 => crate::implementations::print_conv::componentsconfiguration_print_conv(value),
        37377 => crate::implementations::print_conv::exposuretime_print_conv(value),
        37380 => crate::implementations::print_conv::print_fraction(value),
        37385 => crate::implementations::print_conv::flash_print_conv(value),
        41728 => crate::implementations::print_conv::filesource_print_conv(value),
        42034 => crate::implementations::print_conv::lensinfo_print_conv(value),
        _ => {
            // Fall back to shared handling
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                crate::implementations::generic::apply_fallback_print_conv(
                    tag_id,
                    &tag_kit.name,
                    "EXIF",
                    value,
                    crate::to_print_conv_ref!(&tag_kit.print_conv),
                )
            } else {
                value.clone()
            }
        }
    }
}

/// Apply ValueConv for a tag from this module
pub fn apply_value_conv(
    tag_id: u32,
    value: &TagValue,
    _errors: &mut Vec<String>,
) -> Result<TagValue> {
    match tag_id {
        0 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        273 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        279 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        288 => crate::implementations::value_conv::reference_long_string_value_conv(value),
        289 => crate::implementations::value_conv::reference_long_string_value_conv(value),
        324 => crate::implementations::value_conv::reference_long_string_value_conv(value),
        325 => crate::implementations::value_conv::reference_long_string_value_conv(value),
        18247 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        37377 => crate::implementations::value_conv::apex_shutter_speed_value_conv(value),
        37378 => crate::implementations::value_conv::apex_aperture_value_conv(value),
        37381 => crate::implementations::value_conv::apex_aperture_value_conv(value),
        37500 => crate::implementations::value_conv::reference_very_long_string_value_conv(value),
        37520 => crate::implementations::value_conv::trim_whitespace_value_conv(value),
        37521 => crate::implementations::value_conv::trim_whitespace_value_conv(value),
        37522 => crate::implementations::value_conv::trim_whitespace_value_conv(value),
        40091 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        40092 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        40093 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        40094 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        40095 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        48129 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50709 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50715 => crate::implementations::value_conv::reference_very_long_string_value_conv(value),
        50716 => crate::implementations::value_conv::reference_very_long_string_value_conv(value),
        50781 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50827 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50898 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50899 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50931 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50932 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50934 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50936 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50938 => crate::implementations::value_conv::reference_very_long_string_value_conv(value),
        50939 => crate::implementations::value_conv::reference_very_long_string_value_conv(value),
        50940 => crate::implementations::value_conv::reference_very_long_string_value_conv(value),
        50942 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50966 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50967 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50968 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50969 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50971 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50972 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50973 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        50982 => crate::implementations::value_conv::reference_very_long_string_value_conv(value),
        51043 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        51111 => {
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        52537 => crate::implementations::value_conv::reference_very_long_string_value_conv(value),
        65000 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65001 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65002 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65100 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65101 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65102 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65105 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65106 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65107 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65108 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65109 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65110 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65111 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        65112 => crate::implementations::value_conv::remove_prefix_colon_value_conv(value),
        _ => {
            // Fall back to missing handler for unknown expressions
            if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "EXIF",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
    }
}

/// Check if a tag has subdirectory processing
pub fn has_subdirectory(tag_id: u32) -> bool {
    if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
        tag_kit.subdirectory.is_some()
    } else {
        false
    }
}

/// Process subdirectory tags and return multiple extracted tags
pub fn process_subdirectory(
    tag_id: u32,
    value: &TagValue,
    byte_order: ByteOrder,
    model: Option<&str>,
) -> Result<HashMap<String, TagValue>> {
    use tracing::debug;
    let mut result = HashMap::new();

    debug!("process_subdirectory called for tag_id: 0x{:04x}", tag_id);

    if let Some(tag_kit) = EXIF_PM_TAG_KITS.get(&tag_id) {
        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {
            debug!("Found subdirectory processor for tag_id: 0x{:04x}", tag_id);
            let bytes = match value {
                TagValue::U16Array(arr) => {
                    debug!("Converting U16Array with {} elements to bytes", arr.len());
                    // Convert U16 array to bytes based on byte order
                    let mut bytes = Vec::with_capacity(arr.len() * 2);
                    for val in arr {
                        match byte_order {
                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),
                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),
                        }
                    }
                    bytes
                }
                TagValue::U8Array(arr) => arr.clone(),
                _ => return Ok(result), // Not array data
            };

            debug!("Calling processor with {} bytes", bytes.len());
            // Process subdirectory and collect all extracted tags
            match processor(&bytes, byte_order, model) {
                Ok(extracted_tags) => {
                    debug!("Processor returned {} tags", extracted_tags.len());
                    for (name, value) in extracted_tags {
                        result.insert(name, value);
                    }
                }
                Err(e) => {
                    debug!("Processor error: {:?}", e);
                }
            }
        } else {
            debug!(
                "No subdirectory processor found for tag_id: 0x{:04x}",
                tag_id
            );
        }
    } else {
        debug!("Tag not found in TAG_KITS: 0x{:04x}", tag_id);
    }

    Ok(result)
}
