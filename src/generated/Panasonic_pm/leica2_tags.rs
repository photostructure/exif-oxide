//! Generated tag table definitions from Panasonic::Leica2
//!
//! This file is auto-generated by codegen/src/strategies/tag_kit.rs. Do not edit manually.

use crate::types::{PrintConv, TagInfo, ValueConv};
use std::collections::HashMap;
use std::sync::LazyLock;

// Generated imports for conversion functions
use crate::generated::functions::hash_a1::ast_value_a15e00efdd4e457;
use crate::generated::functions::hash_ae::ast_print_aec511ac08c0f1fc;
use crate::generated::functions::hash_b4::ast_print_b44b87d319f681cc;
use crate::generated::functions::hash_c8::ast_print_c8bca6375178b51d;
use crate::generated::functions::hash_cc::ast_print_ccb205b5fb8d3f95;

/// Tag definitions for Panasonic::Leica2 table
pub static PANASONIC_LEICA2_TAGS: LazyLock<HashMap<u16, TagInfo>> = LazyLock::new(|| {
    HashMap::from([
        (768, TagInfo {
            name: "Quality",
            format: "unknown",
            print_conv: Some(PrintConv::Simple(std::collections::HashMap::from([("1".to_string(), "Fine"), ("2".to_string(), "Basic"), ]))),
            value_conv: None,
        }),
        (770, TagInfo {
            name: "UserProfile",
            format: "unknown",
            print_conv: Some(PrintConv::Simple(std::collections::HashMap::from([("1".to_string(), "User Profile 1"), ("2".to_string(), "User Profile 2"), ("3".to_string(), "User Profile 3"), ("4".to_string(), "User Profile 0 (Dynamic)"), ]))),
            value_conv: None,
        }),
        (771, TagInfo {
            name: "SerialNumber",
            format: "unknown",
            print_conv: Some(PrintConv::Function(ast_print_ccb205b5fb8d3f95)),
            value_conv: None,
        }),
        (772, TagInfo {
            name: "WhiteBalance",
            format: "unknown",
            print_conv: Some(PrintConv::Simple(std::collections::HashMap::from([("0".to_string(), "Auto or Manual"), ("1".to_string(), "Daylight"), ("10".to_string(), "Cloudy"), ("11".to_string(), "Shade"), ("2".to_string(), "Fluorescent"), ("3".to_string(), "Tungsten"), ("4".to_string(), "Flash"), ("OTHER".to_string(), "[Function: Image::ExifTool::Panasonic::WhiteBalanceConv]"), ]))),
            value_conv: None,
        }),
        (784, TagInfo {
            name: "LensType",
            format: "unknown",
            print_conv: Some(PrintConv::Simple(std::collections::HashMap::from([("0 0".to_string(), "Uncoded lens"), ("1".to_string(), "Elmarit-M 21mm f/2.8"), ("11".to_string(), "Summaron-M 28mm f/5.6"), ("12".to_string(), "Thambar-M 90mm f/2.2"), ("16".to_string(), "Tri-Elmar-M 16-18-21mm f/4 ASPH."), ("16 1".to_string(), "Tri-Elmar-M 16-18-21mm f/4 ASPH. (at 16mm)"), ("16 2".to_string(), "Tri-Elmar-M 16-18-21mm f/4 ASPH. (at 18mm)"), ("16 3".to_string(), "Tri-Elmar-M 16-18-21mm f/4 ASPH. (at 21mm)"), ("23".to_string(), "Summicron-M 50mm f/2 (III)"), ("24".to_string(), "Elmarit-M 21mm f/2.8 ASPH."), ("25".to_string(), "Elmarit-M 24mm f/2.8 ASPH."), ("26".to_string(), "Summicron-M 28mm f/2 ASPH."), ("27".to_string(), "Elmarit-M 28mm f/2.8 (IV)"), ("28".to_string(), "Elmarit-M 28mm f/2.8 ASPH."), ("29".to_string(), "Summilux-M 35mm f/1.4 ASPH."), ("29 0".to_string(), "Summilux-M 35mm f/1.4 ASPHERICAL"), ("3".to_string(), "Elmarit-M 28mm f/2.8 (III)"), ("30".to_string(), "Summicron-M 35mm f/2 ASPH."), ("31".to_string(), "Noctilux-M 50mm f/1"), ("31 0".to_string(), "Noctilux-M 50mm f/1.2"), ("32".to_string(), "Summilux-M 50mm f/1.4 ASPH."), ("33".to_string(), "Summicron-M 50mm f/2 (IV, V)"), ("34".to_string(), "Elmar-M 50mm f/2.8"), ("35".to_string(), "Summilux-M 75mm f/1.4"), ("36".to_string(), "Apo-Summicron-M 75mm f/2 ASPH."), ("37".to_string(), "Apo-Summicron-M 90mm f/2 ASPH."), ("38".to_string(), "Elmarit-M 90mm f/2.8"), ("39".to_string(), "Macro-Elmar-M 90mm f/4"), ("39 0".to_string(), "Tele-Elmar-M 135mm f/4 (II)"), ("4".to_string(), "Tele-Elmarit-M 90mm f/2.8 (II)"), ("40".to_string(), "Macro-Adapter M"), ("41".to_string(), "Apo-Summicron-M 50mm f/2 ASPH."), ("41 3".to_string(), "Apo-Summicron-M 50mm f/2 ASPH."), ("42".to_string(), "Tri-Elmar-M 28-35-50mm f/4 ASPH."), ("42 1".to_string(), "Tri-Elmar-M 28-35-50mm f/4 ASPH. (at 28mm)"), ("42 2".to_string(), "Tri-Elmar-M 28-35-50mm f/4 ASPH. (at 35mm)"), ("42 3".to_string(), "Tri-Elmar-M 28-35-50mm f/4 ASPH. (at 50mm)"), ("43".to_string(), "Summarit-M 35mm f/2.5"), ("44".to_string(), "Summarit-M 50mm f/2.5"), ("45".to_string(), "Summarit-M 75mm f/2.5"), ("46".to_string(), "Summarit-M 90mm f/2.5"), ("47".to_string(), "Summilux-M 21mm f/1.4 ASPH."), ("48".to_string(), "Summilux-M 24mm f/1.4 ASPH."), ("49".to_string(), "Noctilux-M 50mm f/0.95 ASPH."), ("5".to_string(), "Summilux-M 50mm f/1.4 (II)"), ("50".to_string(), "Elmar-M 24mm f/3.8 ASPH."), ("51".to_string(), "Super-Elmar-M 21mm f/3.4 Asph"), ("51 2".to_string(), "Super-Elmar-M 14mm f/3.8 Asph"), ("52".to_string(), "Apo-Telyt-M 18mm f/3.8 ASPH."), ("53".to_string(), "Apo-Telyt-M 135mm f/3.4"), ("53 2".to_string(), "Apo-Telyt-M 135mm f/3.4"), ("53 3".to_string(), "Apo-Summicron-M 50mm f/2 (VI)"), ("58".to_string(), "Noctilux-M 75mm f/1.25 ASPH."), ("6".to_string(), "Summicron-M 35mm f/2 (IV)"), ("6 0".to_string(), "Summilux-M 35mm f/1.4"), ("7".to_string(), "Summicron-M 90mm f/2 (II)"), ("9".to_string(), "Elmarit-M 135mm f/2.8 (I/II)"), ("9 0".to_string(), "Apo-Telyt-M 135mm f/3.4"), ("Notes".to_string(), "\n        the LensType value is obtained by splitting the stored value into 2\n        integers:  The stored value divided by 4, and its lower 2 bits.  The second\n        number is used only if necessary to identify certain manually coded lenses\n        on the M9, or the focal length of some multi-focal lenses.\n    "), ("OTHER".to_string(), "[Function: Image::ExifTool::Panasonic::__ANON__]"), ]))),
            value_conv: Some(ValueConv::Function(ast_value_a15e00efdd4e457)),
        }),
        (785, TagInfo {
            name: "ExternalSensorBrightnessValue",
            format: "rational64s",
            print_conv: Some(PrintConv::Function(ast_print_aec511ac08c0f1fc)),
            value_conv: None,
        }),
        (786, TagInfo {
            name: "MeasuredLV",
            format: "rational64s",
            print_conv: Some(PrintConv::Function(ast_print_aec511ac08c0f1fc)),
            value_conv: None,
        }),
        (787, TagInfo {
            name: "ApproximateFNumber",
            format: "unknown",
            print_conv: Some(PrintConv::Function(ast_print_b44b87d319f681cc)),
            value_conv: None,
        }),
        (800, TagInfo {
            name: "CameraTemperature",
            format: "unknown",
            print_conv: Some(PrintConv::Function(ast_print_c8bca6375178b51d)),
            value_conv: None,
        }),
        (801, TagInfo {
            name: "ColorTemperature",
            format: "unknown",
            print_conv: None,
            value_conv: None,
        }),
        (802, TagInfo {
            name: "WBRedLevel",
            format: "unknown",
            print_conv: None,
            value_conv: None,
        }),
        (803, TagInfo {
            name: "WBGreenLevel",
            format: "unknown",
            print_conv: None,
            value_conv: None,
        }),
        (804, TagInfo {
            name: "WBBlueLevel",
            format: "unknown",
            print_conv: None,
            value_conv: None,
        }),
        (805, TagInfo {
            name: "UV-IRFilterCorrection",
            format: "unknown",
            print_conv: Some(PrintConv::Simple(std::collections::HashMap::from([("0".to_string(), "Not Active"), ("1".to_string(), "Active"), ]))),
            value_conv: None,
        }),
        (816, TagInfo {
            name: "CCDVersion",
            format: "unknown",
            print_conv: None,
            value_conv: None,
        }),
        (817, TagInfo {
            name: "CCDBoardVersion",
            format: "unknown",
            print_conv: None,
            value_conv: None,
        }),
        (818, TagInfo {
            name: "ControllerBoardVersion",
            format: "unknown",
            print_conv: None,
            value_conv: None,
        }),
        (819, TagInfo {
            name: "M16CVersion",
            format: "unknown",
            print_conv: None,
            value_conv: None,
        }),
        (832, TagInfo {
            name: "ImageIDNumber",
            format: "unknown",
            print_conv: None,
            value_conv: None,
        }),
    ])
});

/// Apply ValueConv transformation for tags in this table
pub fn apply_value_conv(
    tag_id: u32,
    value: &crate::types::TagValue,
    _errors: &mut Vec<String>,
) -> Result<crate::types::TagValue, crate::types::ExifError> {
    let tag_id_u16 = tag_id as u16;
    if let Some(tag_def) = PANASONIC_LEICA2_TAGS.get(&tag_id_u16) {
        if let Some(ref value_conv) = tag_def.value_conv {
            match value_conv {
                ValueConv::None => Ok(value.clone()),
                ValueConv::Function(func) => func(value, None),
                ValueConv::Expression(_expr) => {
                    // Runtime expression evaluation removed - all Perl interpretation happens via PPI at build time
                    Err(crate::types::ExifError::NotImplemented("Runtime expression evaluation not supported - should be handled by PPI at build time".to_string()))
                }
                _ => Ok(value.clone()),
            }
        } else {
            Ok(value.clone())
        }
    } else {
        Err(crate::types::ExifError::ParseError(format!(
            "Tag 0x{:04x} not found in table",
            tag_id
        )))
    }
}

/// Apply PrintConv transformation for tags in this table
pub fn apply_print_conv(
    tag_id: u32,
    value: &crate::types::TagValue,
    _errors: &mut Vec<String>,
    _warnings: &mut Vec<String>,
) -> crate::types::TagValue {
    let tag_id_u16 = tag_id as u16;
    if let Some(tag_def) = PANASONIC_LEICA2_TAGS.get(&tag_id_u16) {
        if let Some(ref print_conv) = tag_def.print_conv {
            match print_conv {
                PrintConv::None => value.clone(),
                PrintConv::Function(func) => func(value, None),
                PrintConv::Simple(lookup) => {
                    // Look up value in the hash map
                    // ExifTool uses the stringified value as the key
                    let key = value.to_string();
                    if let Some(display_value) = lookup.get(&key) {
                        crate::types::TagValue::String(display_value.to_string())
                    } else {
                        // Key not found - return original value
                        value.clone()
                    }
                }
                PrintConv::Expression(_expr) => {
                    // Runtime expression evaluation removed - all Perl interpretation happens via PPI at build time
                    value.clone() // Fallback to original value when expression not handled by PPI
                }
                _ => value.clone(),
            }
        } else {
            value.clone()
        }
    } else {
        value.clone()
    }
}
