//! Modular EXIF tag definitions
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.

use std::collections::HashMap;
use std::sync::LazyLock;

pub mod common;
pub use common::{TagDef, TagFormat};

pub mod author;
pub mod camera;
pub mod core;
pub mod special;
pub mod time;

pub use author::AUTHOR_TAGS;
pub use camera::CAMERA_TAGS;
pub use core::CORE_TAGS;
pub use special::SPECIAL_TAGS;
pub use time::TIME_TAGS;

/// Combined tag table from all groups
pub static ALL_TAGS: LazyLock<Vec<&'static TagDef>> = LazyLock::new(|| {
    let mut tags = Vec::new();
    tags.extend(AUTHOR_TAGS.iter());
    tags.extend(CAMERA_TAGS.iter());
    tags.extend(CORE_TAGS.iter());
    tags.extend(SPECIAL_TAGS.iter());
    tags.extend(TIME_TAGS.iter());
    tags
});

/// Unified lookup map from tag ID to tag definition
pub static TAG_LOOKUP: LazyLock<HashMap<u32, &'static TagDef>> = LazyLock::new(|| {
    let mut map = HashMap::new();
    for tag in ALL_TAGS.iter() {
        map.insert(tag.id, *tag);
    }
    map
});

/// Unified lookup map from tag name to tag definition
pub static TAG_NAME_LOOKUP: LazyLock<HashMap<&'static str, &'static TagDef>> = LazyLock::new(|| {
    let mut map = HashMap::new();
    for tag in ALL_TAGS.iter() {
        map.insert(tag.name, *tag);
    }
    map
});

/// Look up a tag definition by its ID
pub fn lookup_tag_by_id(id: u32) -> Option<&'static TagDef> {
    TAG_LOOKUP.get(&id).copied()
}

/// Look up a tag definition by its name
pub fn lookup_tag_by_name(name: &str) -> Option<&'static TagDef> {
    TAG_NAME_LOOKUP.get(name).copied()
}

/// Backward compatibility alias for the combined tag table
pub static TAG_TABLE: LazyLock<Vec<TagDef>> = LazyLock::new(|| {
    ALL_TAGS.iter().map(|tag| (*tag).clone()).collect()
});
