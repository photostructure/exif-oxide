//! Modular tag kits with embedded PrintConv for MIE_pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: MIE.pm table: Main
//!
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub mod datetime;
pub mod gps;
pub mod other;
pub mod thumbnail;

use crate::expressions::ExpressionEvaluator;
use crate::tiff_types::ByteOrder;
use crate::types::{Result, TagValue};
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
    pub subdirectory: Option<SubDirectoryType>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// Type alias for subdirectory processor function
pub type SubDirectoryProcessor = fn(&[u8], ByteOrder) -> Result<Vec<(String, TagValue)>>;

#[derive(Debug, Clone)]
pub enum SubDirectoryType {
    Binary { processor: SubDirectoryProcessor },
}

/// All tag kits for MIE_pm
pub static MIE_PM_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map: HashMap<u32, TagKitDef> = HashMap::new();

    // datetime tags
    for (id, tag_def) in datetime::get_datetime_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // gps tags
    for (id, tag_def) in gps::get_gps_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // thumbnail tags
    for (id, tag_def) in thumbnail::get_thumbnail_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    map
});

// Helper functions for reading binary data
fn model_matches(model: &str, pattern: &str) -> bool {
    // ExifTool regexes are already in a compatible format
    // Just need to ensure proper escaping was preserved

    match regex::Regex::new(pattern) {
        Ok(re) => re.is_match(model),
        Err(e) => {
            tracing::warn!("Failed to compile model regex '{}': {}", pattern, e);
            false
        }
    }
}

fn format_matches(format: &str, pattern: &str) -> bool {
    if let Ok(re) = regex::Regex::new(pattern) {
        re.is_match(format)
    } else {
        tracing::warn!("Failed to compile format regex: {}", pattern);
        false
    }
}

fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16u array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {
    if data.len() < 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s".to_string(),
        ));
    }
    Ok(match byte_order {
        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),
        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),
    })
}

// Subdirectory processing functions
fn process_mie_meta(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TagAudio at offset Audio

    // TagCamera at offset Camera

    // TagDocument at offset Document

    // TagGeo at offset Geo

    // ICC_Profile at offset ICCProfile

    // TagID3 at offset ID3

    // TagImage at offset Image

    // TagMakerNotes at offset MakerNotes

    // TagPreview at offset Preview

    // TagThumbnail at offset Thumbnail

    // TagVideo at offset Video

    Ok(tags)
}

fn process_mie_audio(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // RelatedAudioFileType at offset 0Type

    // RelatedAudioFileName at offset 1Name

    // TagChannels at offset Channels

    // AudioCompression at offset Compression

    // TagDuration at offset Duration

    // TagSampleBits at offset SampleBits

    // TagSampleRate at offset SampleRate

    // RelatedAudioFile at offset data

    Ok(tags)
}

fn process_mie_camera(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TagBrightness at offset Brightness

    // TagColorBalance at offset ColorBalance

    // TagColorTemperature at offset ColorTemperature

    // TagContrast at offset Contrast

    // TagDigitalZoom at offset DigitalZoom

    // ExposureCompensation at offset ExposureComp

    // TagExposureMode at offset ExposureMode

    // TagExposureTime at offset ExposureTime

    // TagFirmwareVersion at offset FirmwareVersion

    // TagFlash at offset Flash

    // TagFocusMode at offset FocusMode

    // TagISOSetting at offset ISOSetting

    // TagImageNumber at offset ImageNumber

    // TagImageQuality at offset ImageQuality

    // TagImageStabilization at offset ImageStabilization

    // TagLens at offset Lens

    // TagMake at offset Make

    // TagMeasuredEV at offset MeasuredEV

    // TagModel at offset Model

    // TagOrientation at offset Orientation

    // TagOwnerName at offset OwnerName

    // TagSaturation at offset Saturation

    // TagSensorSize at offset SensorSize

    // TagSerialNumber at offset SerialNumber

    // TagSharpness at offset Sharpness

    // TagShootingMode at offset ShootingMode

    Ok(tags)
}

fn process_mie_doc(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TagAuthor at offset Author

    // TagComment at offset Comment

    // TagContributors at offset Contributors

    // TagCopyright at offset Copyright

    // TagCreateDate at offset CreateDate

    // Email at offset EMail

    // TagKeywords at offset Keywords

    // TagModifyDate at offset ModifyDate

    // DateTimeOriginal at offset OriginalDate

    // PhoneNumber at offset Phone

    // TagReferences at offset References

    // TagSoftware at offset Software

    // TagTitle at offset Title

    Ok(tags)
}

fn process_mie_geo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TagAddress at offset Address

    // TagCity at offset City

    // TagCountry at offset Country

    // TagPostalCode at offset PostalCode

    // TagState at offset State

    Ok(tags)
}

fn process_mie_image(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FullSizeImageType at offset 0Type

    // FullSizeImageName at offset 1Name

    // BitDepth at offset BitDepth

    // TagColorSpace at offset ColorSpace

    // ComponentsConfiguration at offset Components

    // CompressionRatio at offset Compression

    // TagImageSize at offset ImageSize

    // TagOriginalImageSize at offset OriginalImageSize

    // TagResolution at offset Resolution

    // FullSizeImage at offset data

    Ok(tags)
}

fn process_mie_makernotes(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TagCanon at offset Canon

    // TagCasio at offset Casio

    // TagFujiFilm at offset FujiFilm

    // TagKodak at offset Kodak

    // TagKonicaMinolta at offset KonicaMinolta

    // TagNikon at offset Nikon

    // TagOlympus at offset Olympus

    // TagPanasonic at offset Panasonic

    // TagPentax at offset Pentax

    // TagRicoh at offset Ricoh

    // TagSigma at offset Sigma

    // TagSony at offset Sony

    Ok(tags)
}

fn process_mie_preview(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PreviewImageType at offset 0Type

    // PreviewImageName at offset 1Name

    // PreviewImageSize at offset ImageSize

    // PreviewImage at offset data

    Ok(tags)
}

fn process_mie_thumbnail(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ThumbnailImageType at offset 0Type

    // ThumbnailImageName at offset 1Name

    // ThumbnailImageSize at offset ImageSize

    // ThumbnailImage at offset data

    Ok(tags)
}

fn process_mie_video(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // RelatedVideoFileType at offset 0Type

    // RelatedVideoFileName at offset 1Name

    // TagCodec at offset Codec

    // TagDuration at offset Duration

    // RelatedVideoFile at offset data

    Ok(tags)
}

fn process_mie_flash(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FlashExposureComp at offset ExposureComp

    // FlashFired at offset Fired

    // FlashGuideNumber at offset GuideNumber

    // FlashMake at offset Make

    // FlashMode at offset Mode

    // FlashModel at offset Model

    // FlashSerialNumber at offset SerialNumber

    // FlashType at offset Type

    Ok(tags)
}

fn process_mie_lens(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TagExtender at offset Extender

    // TagFNumber at offset FNumber

    // TagFocalLength at offset FocalLength

    // TagFocusDistance at offset FocusDistance

    // LensMake at offset Make

    // TagMaxAperture at offset MaxAperture

    // TagMaxApertureAtMaxFocal at offset MaxApertureAtMaxFocal

    // TagMaxFocalLength at offset MaxFocalLength

    // TagMinAperture at offset MinAperture

    // TagMinFocalLength at offset MinFocalLength

    // LensModel at offset Model

    // TagOpticalZoom at offset OpticalZoom

    // LensSerialNumber at offset SerialNumber

    Ok(tags)
}

fn process_mie_orient(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TagAzimuth at offset Azimuth

    // TagDeclination at offset Declination

    // TagElevation at offset Elevation

    // TagRightAscension at offset RightAscension

    // TagRotation at offset Rotation

    Ok(tags)
}

fn process_mie_extender(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ExtenderMagnification at offset Magnification

    // ExtenderMake at offset Make

    // ExtenderModel at offset Model

    // ExtenderSerialNumber at offset SerialNumber

    Ok(tags)
}

fn process_mie_canon(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_mie_unknown(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

pub fn process_tag_0x0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    match tag_id {
        0 => crate::implementations::print_conv::componentsconfiguration_print_conv(value),
        _ => {
            // Fall back to shared handling
            if let Some(tag_kit) = MIE_PM_TAG_KITS.get(&tag_id) {
                crate::implementations::generic::apply_fallback_print_conv(
                    tag_id,
                    &tag_kit.name,
                    "MIE",
                    value,
                    crate::to_print_conv_ref!(&tag_kit.print_conv),
                )
            } else {
                value.clone()
            }
        }
    }
}

/// Apply ValueConv for a tag from this module
pub fn apply_value_conv(
    tag_id: u32,
    value: &TagValue,
    _errors: &mut Vec<String>,
) -> Result<TagValue> {
    match tag_id {
        0 => {
            if let Some(tag_kit) = MIE_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "MIE",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
        _ => {
            // Fall back to missing handler for unknown expressions
            if let Some(tag_kit) = MIE_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "MIE",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
    }
}

/// Check if a tag has subdirectory processing
pub fn has_subdirectory(tag_id: u32) -> bool {
    if let Some(tag_kit) = MIE_PM_TAG_KITS.get(&tag_id) {
        tag_kit.subdirectory.is_some()
    } else {
        false
    }
}

/// Process subdirectory tags and return multiple extracted tags
pub fn process_subdirectory(
    tag_id: u32,
    value: &TagValue,
    byte_order: ByteOrder,
) -> Result<HashMap<String, TagValue>> {
    use tracing::debug;
    let mut result = HashMap::new();

    debug!("process_subdirectory called for tag_id: 0x{:04x}", tag_id);

    if let Some(tag_kit) = MIE_PM_TAG_KITS.get(&tag_id) {
        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {
            debug!("Found subdirectory processor for tag_id: 0x{:04x}", tag_id);
            let bytes = match value {
                TagValue::U16Array(arr) => {
                    debug!("Converting U16Array with {} elements to bytes", arr.len());
                    // Convert U16 array to bytes based on byte order
                    let mut bytes = Vec::with_capacity(arr.len() * 2);
                    for val in arr {
                        match byte_order {
                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),
                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),
                        }
                    }
                    bytes
                }
                TagValue::U8Array(arr) => arr.clone(),
                _ => return Ok(result), // Not array data
            };

            debug!("Calling processor with {} bytes", bytes.len());
            // Process subdirectory and collect all extracted tags
            match processor(&bytes, byte_order) {
                Ok(extracted_tags) => {
                    debug!("Processor returned {} tags", extracted_tags.len());
                    for (name, value) in extracted_tags {
                        result.insert(name, value);
                    }
                }
                Err(e) => {
                    debug!("Processor error: {:?}", e);
                }
            }
        } else {
            debug!(
                "No subdirectory processor found for tag_id: 0x{:04x}",
                tag_id
            );
        }
    } else {
        debug!("Tag not found in TAG_KITS: 0x{:04x}", tag_id);
    }

    Ok(result)
}
