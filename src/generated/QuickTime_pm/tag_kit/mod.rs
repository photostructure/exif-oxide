//! Modular tag kits with embedded PrintConv for QuickTime_pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: QuickTime.pm table: Main
//!
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub mod datetime;
pub mod gps;
pub mod interop;
pub mod other;
pub mod thumbnail;

use crate::expressions::ExpressionEvaluator;
use crate::tiff_types::ByteOrder;
use crate::types::{Result, TagValue};
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
    pub subdirectory: Option<SubDirectoryType>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// Type alias for subdirectory processor function
pub type SubDirectoryProcessor = fn(&[u8], ByteOrder) -> Result<Vec<(String, TagValue)>>;

#[derive(Debug, Clone)]
pub enum SubDirectoryType {
    Binary { processor: SubDirectoryProcessor },
}

/// All tag kits for QuickTime_pm
pub static QUICKTIME_PM_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map = HashMap::new();

    // datetime tags
    for (id, tag_def) in datetime::get_datetime_tags() {
        map.insert(id, tag_def);
    }

    // gps tags
    for (id, tag_def) in gps::get_gps_tags() {
        map.insert(id, tag_def);
    }

    // interop tags
    for (id, tag_def) in interop::get_interop_tags() {
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        map.insert(id, tag_def);
    }

    // thumbnail tags
    for (id, tag_def) in thumbnail::get_thumbnail_tags() {
        map.insert(id, tag_def);
    }

    map
});

// Helper functions for reading binary data
fn model_matches(model: &str, pattern: &str) -> bool {
    // ExifTool regexes are already in a compatible format
    // Just need to ensure proper escaping was preserved

    match regex::Regex::new(pattern) {
        Ok(re) => re.is_match(model),
        Err(e) => {
            tracing::warn!("Failed to compile model regex '{}': {}", pattern, e);
            false
        }
    }
}

fn format_matches(format: &str, pattern: &str) -> bool {
    if let Ok(re) = regex::Regex::new(pattern) {
        re.is_match(format)
    } else {
        tracing::warn!("Failed to compile format regex: {}", pattern);
        false
    }
}

fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16u array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {
    if data.len() < 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s".to_string(),
        ));
    }
    Ok(match byte_order {
        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),
        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),
    })
}

// Subdirectory processing functions
fn process_quicktime_htcinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Unknown_slmt at offset slmt
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_quicktime_pittasoft(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AccelData at offset 3gf

    // GPSLog at offset gps

    // OriginalFileName at offset ptnm

    // Tagptrh at offset ptrh

    // StartTime at offset sttm
    if data.len() >= 2 {
        // TODO: Handle format int64u
    }

    // PreviewImage at offset thum

    Ok(tags)
}

fn process_quicktime_filetype(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MajorBrand at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // MinorVersion at offset 1
    if data.len() >= 12 {
        // TODO: Handle format undef
    }

    // CompatibleBrands at offset 2

    Ok(tags)
}

fn process_quicktime_othermeta(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MetaRelation at offset mere

    // Meta at offset meta

    Ok(tags)
}

fn process_quicktime_meta(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // BinaryXML at offset bxml

    // DataInfo at offset dinf

    // Free at offset free

    // Unknown_grpl at offset grpl

    // Handler at offset hdlr

    // MetaImageSize at offset idat
    if data.len() >= 2 {
        // TODO: Handle format int16u
    }

    // ItemLocation at offset iloc

    // ItemList at offset ilst

    // IPMPControl at offset ipmc

    // ItemProtection at offset ipro

    // ItemProperties at offset iprp

    // ItemReference at offset iref

    // XML at offset xml

    Ok(tags)
}

fn process_quicktime_moviefragment(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Meta at offset meta

    // MovieFragmentHeader at offset mfhd

    // TrackFragment at offset traf

    Ok(tags)
}

fn process_quicktime_movie(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CompressedMovie at offset cmov

    // GPSDataList at offset gps

    // HTCTrack at offset htka

    // InitialObjectDescriptor at offset iods

    // OtherMeta at offset meco

    // Meta at offset meta

    // MovieHeader at offset mvhd

    // Track at offset trak

    // UserData at offset udta

    Ok(tags)
}

fn process_quicktime_preview(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PreviewDate at offset 0
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // PreviewAtomType at offset 3
    if data.len() >= 14 {
        // TODO: Handle format string
    }

    Ok(tags)
}

fn process_quicktime_skipinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ThumbnailImage at offset thma

    Ok(tags)
}

fn process_quicktime_profile(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_flip(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SerialNumber at offset 14
    if data.len() >= 88 {
        // TODO: Handle format string
    }

    // PreviewImage at offset 28

    Ok(tags)
}

fn process_quicktime_cmovie(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_track(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Media at offset mdia

    // OtherMeta at offset meco

    // Meta at offset meta

    // TrackAperture at offset tapt

    // TrackHeader at offset tkhd

    // TrackRef at offset tref

    // UserData at offset udta

    Ok(tags)
}

fn process_quicktime_movieheader(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MovieHeaderVersion at offset 0
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // CreateDate at offset 1

    // PreviewTime at offset 18

    // PreviewDuration at offset 19

    // ModifyDate at offset 2

    // PosterTime at offset 20

    // SelectionTime at offset 21

    // SelectionDuration at offset 22

    // CurrentTime at offset 23

    // TimeScale at offset 3

    // Duration at offset 4

    // PreferredRate at offset 5

    // PreferredVolume at offset 6
    if data.len() >= 26 {
        // TODO: Handle format int16u
    }

    // MatrixStructure at offset 9
    if data.len() >= 54 {
        // TODO: Handle format fixed32s
    }

    Ok(tags)
}

fn process_quicktime_userdata(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ContentCreateDate at offset @day

    // Make at offset @mak

    // Model at offset @mod

    // SamsungSec at offset @sec

    // SoftwareVersion at offset @swr

    // GPSCoordinates at offset @xyz

    // PlayAllFrames at offset AllF
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // KodakDcMD at offset DcMD

    // LevelMeter at offset Lvlm
    if data.len() >= 2 {
        // TODO: Handle format rational64s
    }

    // MinoltaMMA0 at offset MMA0

    // MinoltaMMA1 at offset MMA1

    // SerialNumber at offset SNum

    // PlaySelection at offset SelO
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // MicrosoftXtra at offset Xtra

    // CX at offset _cx_
    if data.len() >= 2 {
        // TODO: Handle format rational64s
    }

    // CY at offset _cy_
    if data.len() >= 2 {
        // TODO: Handle format rational64s
    }

    // Yaw at offset _yaw
    if data.len() >= 2 {
        // TODO: Handle format rational64s
    }

    // Unknown_adzc at offset adzc

    // Unknown_adze at offset adze

    // Unknown_adzm at offset adzm

    // Album at offset albm

    // AlbumArtist at offset albr

    // CameraAngle at offset angl
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // ApertureMode at offset apmd
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    // Author at offset auth

    // GlamourSettings at offset btec

    // ChapterList at offset chpl

    // ClipFileName at offset clfn
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // ClipID at offset clid
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // Classification at offset clsf

    // CameraID at offset cmid
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // Model at offset cmnm
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // CollectionName at offset coll

    // Copyright at offset cprt

    // DateTimeOriginal at offset date

    // Description at offset dscp

    // OriginalFileName at offset finm

    // Genre at offset gnre

    // HintTrackInfo at offset hinf

    // HintInfo at offset hnti

    // HTCBinary at offset htcb

    // CameraInfo at offset infi

    // TrackType at offset kgtt

    // Keywords at offset kywd

    // LocationInformation at offset loci

    // LevelMeter at offset lvlm
    if data.len() >= 2 {
        // TODO: Handle format rational64s
    }

    // Make at offset manu

    // PreviewImage at offset mcvr

    // Meta at offset meta

    // Model at offset modl

    // ThumbnailTIFF at offset nail

    // Unknown_nbpl at offset nbpl

    // Performer at offset perf

    // GarminSettings at offset pmcc

    // pose at offset pose

    // Pitch at offset ptch
    if data.len() >= 2 {
        // TODO: Handle format rational64s
    }

    // PrintToVideo at offset ptv

    // Rads at offset rads
    if data.len() >= 2 {
        // TODO: Handle format rational64s
    }

    // ReelName at offset reel
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // Roll at offset roll
    if data.len() >= 2 {
        // TODO: Handle format rational64s
    }

    // Rating at offset rtng

    // Scene at offset scen
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // OlympusPreview at offset scrn

    // ShotName at offset shot
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // SerialNumber at offset slno
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // SamsungSmta at offset smta

    // Audible_tags at offset tags

    // TimeStamp at offset time
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // Title at offset titl

    // TrackName at offset tnam

    // UserRating at offset urat

    // AccelerometerData at offset vrot
    if data.len() >= 2 {
        // TODO: Handle format rational64s
    }

    // Year at offset yrrc

    // Copyright at offset �cpy

    // ContentCreateDate at offset �day

    // UserData_dji at offset �dji
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    // Model at offset �mdl
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // UserData_res at offset �res
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    // UserData_uid at offset �uid
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    // Composer at offset �wrt

    // GPSCoordinates at offset �xyz

    Ok(tags)
}

fn process_quicktime_usermedia(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_media(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Handler at offset hdlr

    // MediaHeader at offset mdhd

    // MediaInfo at offset minf

    Ok(tags)
}

fn process_quicktime_trackaperture(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CleanApertureDimensions at offset clef
    if data.len() >= 2 {
        // TODO: Handle format fixed32u
    }

    // EncodedPixelsDimensions at offset enof
    if data.len() >= 2 {
        // TODO: Handle format fixed32u
    }

    // ProductionApertureDimensions at offset prof
    if data.len() >= 2 {
        // TODO: Handle format fixed32u
    }

    Ok(tags)
}

fn process_quicktime_trackheader(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TrackHeaderVersion at offset 0
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // TrackCreateDate at offset 1

    // MatrixStructure at offset 10
    if data.len() >= 58 {
        // TODO: Handle format fixed32s
    }

    // ImageWidth at offset 19

    // TrackModifyDate at offset 2

    // ImageHeight at offset 20

    // TrackID at offset 3

    // TrackDuration at offset 5

    // ImageSizeLookahead at offset 7
    if data.len() >= 84 {
        // TODO: Handle format int32u
    }

    // TrackLayer at offset 8
    if data.len() >= 34 {
        // TODO: Handle format int16u
    }

    // TrackVolume at offset 9
    if data.len() >= 38 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_quicktime_trackref(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ContentDescribes at offset cdsc
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // ChapterListTrackID at offset chap
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // ClosedCaptionTrack at offset clcp
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // AlternateFormatTrack at offset fall
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // SubtitleTrack at offset folw
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // ForcedSubtitleTrack at offset forc
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // ElementaryStreamTrack at offset mpod
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // TranscriptTrack at offset scpt
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // Non-primarySourceTrack at offset ssrc
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // SyncronizedTrack at offset sync
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // TimecodeTrack at offset tmcd
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_quicktime_handler(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // HandlerVendorID at offset 12
    if data.len() >= 32 {
        // TODO: Handle format undef
    }

    // HandlerDescription at offset 24
    if data.len() >= 50 {
        // TODO: Handle format string
    }

    // HandlerClass at offset 4
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // HandlerType at offset 8
    if data.len() >= 24 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_quicktime_mediaheader(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MediaHeaderVersion at offset 0

    // MediaCreateDate at offset 1

    // MediaModifyDate at offset 2

    // MediaTimeScale at offset 3

    // MediaDuration at offset 4

    // MediaLanguageCode at offset 5
    if data.len() >= 22 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_quicktime_mediainfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // DataInfo at offset dinf

    // GenMediaHeader at offset gmhd

    // Handler at offset hdlr

    // HintHeader at offset hmhd

    // NullMediaHeader at offset nmhd

    // AudioHeader at offset smhd

    // SampleTable at offset stbl

    // VideoHeader at offset vmhd

    Ok(tags)
}

fn process_quicktime_hinttrackinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ImmediateDataBytes at offset dimm
    if data.len() >= 2 {
        // TODO: Handle format int64u
    }

    // LargestPacketDuration at offset dmax
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // MediaTrackBytes at offset dmed
    if data.len() >= 2 {
        // TODO: Handle format int64u
    }

    // RepeatedDataBytes at offset drep
    if data.len() >= 2 {
        // TODO: Handle format int64u
    }

    // MaxDataRate at offset maxr
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // NumPackets at offset npck
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // NumPackets at offset nump
    if data.len() >= 2 {
        // TODO: Handle format int64u
    }

    // PayloadType at offset payt
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    // LargestPacketSize at offset pmax
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // MaxTransmissionTime at offset tmax
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // MinTransmissionTime at offset tmin
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // TotalBytes at offset totl
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // TotalBytesNoRTPHeaders at offset tpaY
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // TotalBytesNoRTPHeaders at offset tpay
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // TotalBytesNoRTPHeaders at offset tpyl
    if data.len() >= 2 {
        // TODO: Handle format int64u
    }

    // TotalBytes at offset trpY
    if data.len() >= 2 {
        // TODO: Handle format int64u
    }

    // TotalBytes at offset trpy
    if data.len() >= 2 {
        // TODO: Handle format int64u
    }

    Ok(tags)
}

fn process_quicktime_hintinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // RealtimeStreamingProtocol at offset rtp

    Ok(tags)
}

fn process_quicktime_htcbinary(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_nextbase(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SecondCam at offset 2nd Cam

    // TagAlerts at offset Alerts

    // TagAlexa at offset Alexa

    // TagAlexa - Paired Device Name at offset Alexa - Paired Device Name

    // TagAlexa - Pairing at offset Alexa - Pairing

    // TagAlexa - Privacy Mode at offset Alexa - Privacy Mode

    // TagAlexa - Wake Word Language at offset Alexa - Wake Word Language

    // TagAudio at offset Audio

    // TagAuto Power Off at offset Auto Power Off

    // TagBattery Status at offset Battery Status

    // TagBluetooth MAC Address at offset Bluetooth MAC Address

    // TagBluetooth Name at offset Bluetooth Name

    // TagCountry at offset Country

    // TagDefault Settings at offset Default Settings

    // TagDevice Sounds at offset Device Sounds

    // TagDual Files at offset Dual Files

    // TagEmergency SOS at offset Emergency SOS

    // TagExposure at offset Exposure

    // TagExtreme Weather Mode at offset Extreme Weather Mode

    // TagFCC-ID at offset FCC-ID

    // TagFirmware at offset Firmware

    // TagFirmware Version at offset Firmware Version

    // TagFormat SD Card at offset Format SD Card

    // TagG Sensor at offset G Sensor

    // TagGPS Stamp at offset GPS Stamp

    // TagImage Stabilisation at offset Image Stabilisation

    // TagKeep User Settings at offset Keep User Settings

    // TagLanguage at offset Language

    // TagLinux at offset Linux

    // TagModel at offset Model

    // TagModel Stamp at offset Model Stamp

    // TagMyNextbase - Paired Device Name at offset MyNextbase - Paired Device Name

    // TagMyNextbase - Pairing at offset MyNextbase - Pairing

    // TagNumber / License Plate at offset Number / License Plate

    // TagParking Mode at offset Parking Mode

    // TagRecording History at offset Recording History

    // TagResolution at offset Resolution

    // TagReversing Camera at offset Reversing Camera

    // TagSD Card Class at offset SD Card Class

    // TagSD Card Format at offset SD Card Format

    // TagSD Card Manf Date at offset SD Card Manf Date

    // TagSD Card Manf ID at offset SD Card Manf ID

    // TagSD Card Model No at offset SD Card Model No

    // TagSD Card OEM ID at offset SD Card OEM ID

    // TagSD Card Serial No at offset SD Card Serial No

    // TagSD Card Size at offset SD Card Size

    // TagSD Card Type at offset SD Card Type

    // TagSD Card Used Space at offset SD Card Used Space

    // TagScreen Dimming at offset Screen Dimming

    // TagScreen Saver at offset Screen Saver

    // SerialNumber at offset Serial No

    // TagSpeed Stamp at offset Speed Stamp

    // TagSpeed Units at offset Speed Units

    // TagSystem Info at offset System Info

    // TimeAndDate at offset Time & Date

    // TagTime Lapse at offset Time Lapse

    // VideoTimeStamp at offset Time Stamp

    // TagTime Zone / DST at offset Time Zone / DST

    // TagVideo Length at offset Video Length

    // TagWi-Fi MAC Address at offset Wi-Fi MAC Address

    // TagWi-Fi Password at offset Wi-Fi Password

    // TagWi-Fi SSID at offset Wi-Fi SSID

    // What3Words at offset what3words

    Ok(tags)
}

fn process_quicktime_video(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // DisplaySize at offset 0

    // SlideShow at offset 6

    Ok(tags)
}

fn process_quicktime_datainfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // DataRef at offset dref

    Ok(tags)
}

fn process_quicktime_grpl(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_iteminfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ItemInfoEntry at offset infe

    Ok(tags)
}

fn process_quicktime_itemlist(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // iTunesInfo at offset ----

    // AlbumArtist at offset aART

    // AppleStoreAccountType at offset akID
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // Album at offset albm

    // ArtistID at offset atID
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // Author at offset auth

    // AppleStoreCatalogID at offset cnID
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // CoverArt at offset covr

    // Compilation at offset cpil
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // Copyright at offset cprt

    // Description at offset desc

    // DiskNumber at offset disk
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    // Description at offset dscp

    // GenreID at offset geID
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // Genre at offset gnre
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    // Grouping at offset grup

    // GoogleHostHeader at offset gshh
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // GooglePingMessage at offset gspm
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // GooglePingURL at offset gspu
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // GoogleSourceData at offset gssd
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // GoogleStartTime at offset gsst
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // GoogleTrackDuration at offset gstd
    if data.len() >= 2 {
        // TODO: Handle format string
    }

    // HDVideo at offset hdvd
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // iTunesU at offset itnu
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // Podcast at offset pcst
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // PlayGap at offset pgap
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // AlbumID at offset plID
    if data.len() >= 2 {
        // TODO: Handle format int64u
    }

    // ReleaseDate at offset rldt

    // Rating at offset rtng
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // AppleStoreCountry at offset sfID
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // ShowMovement at offset shwm
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // PreviewImage at offset snal

    // MediaType at offset stik
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // Title at offset titl

    // BeatsPerMinute at offset tmpo
    if data.len() >= 2 {
        // TODO: Handle format int16u
    }

    // ThumbnailImage at offset tnal

    // TrackNumber at offset trkn
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    // TVEpisode at offset tves
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // TVSeason at offset tvsn
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // Author at offset �aut

    // Composer at offset �com

    // Copyright at offset �cpy

    // ContentCreateDate at offset �day

    // MovementCount at offset �mvc
    if data.len() >= 2 {
        // TODO: Handle format int16u
    }

    // MovementNumber at offset �mvi
    if data.len() >= 2 {
        // TODO: Handle format int16u
    }

    // GPSCoordinates at offset �xyz

    Ok(tags)
}

fn process_quicktime_itemprop(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ItemPropertyContainer at offset ipco

    // ItemPropertyAssociation at offset ipma

    Ok(tags)
}

fn process_quicktime_itemref(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AuxiliaryImageRef at offset auxl

    // ContentDescribes at offset cdsc

    // DerivedImageRef at offset dimg

    // ThumbnailRef at offset thmb

    Ok(tags)
}

fn process_quicktime_audiokeys(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Mute at offset player.movie.audio.mute
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_quicktime_videokeys(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FrameReadoutTime at offset camera.framereadouttimeinmicroseconds

    Ok(tags)
}

fn process_quicktime_keys(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ApplePhotosVariationIdentifier at offset apple.photos.variation-identifier

    // Tagartist at offset artist

    // Tagartwork at offset artwork

    // Author at offset author

    // AndroidCaptureFPS at offset com.android.capture.fps

    // XiaomiHDR10 at offset com.xiaomi.hdr10

    // XiaomiPreviewVideoCover at offset com.xiaomi.preview_video_cover

    // Tagcomment at offset comment

    // CompatibleBrands at offset compatible_brands

    // Copyright at offset copyright

    // CreationTime at offset creation_time

    // CreationDate at offset creationdate

    // Tagdescription at offset description

    // FaceInfo at offset detected-face

    // DetectedFaceBounds at offset detected-face.bounds

    // DetectedFaceID at offset detected-face.face-id

    // DetectedFaceRollAngle at offset detected-face.roll-angle

    // DetectedFaceYawAngle at offset detected-face.yaw-angle

    // CameraDirection at offset direction.facing

    // CameraMotion at offset direction.motion

    // Tagdirector at offset director

    // DisplayName at offset displayname

    // Tagencoder at offset encoder

    // Taggenre at offset genre

    // Taginformation at offset information

    // Tagkeywords at offset keywords

    // LivePhotoInfo at offset live-photo-info

    // LivePhotoAuto at offset live-photo.auto

    // LivePhotoVitalityScore at offset live-photo.vitality-score

    // LivePhotoVitalityScoringVersion at offset live-photo.vitality-scoring-version

    // GPSCoordinates at offset location.ISO6709

    // LocationAccuracyHorizontal at offset location.accuracy.horizontal

    // LocationBody at offset location.body

    // LocationDate at offset location.date

    // LocationName at offset location.name

    // LocationNote at offset location.note

    // LocationRole at offset location.role

    // MajorBrand at offset major_brand

    // Make at offset make

    // MinorVersion at offset minor_version

    // Model at offset model

    // Mute at offset player.movie.audio.mute
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // Tagproducer at offset producer

    // Tagpublisher at offset publisher

    // SceneIlluminance at offset scene-illuminance

    // Tagsoftware at offset software

    // StillImageTime at offset still-image-time

    // Tagtitle at offset title

    // VideoOrientation at offset video-orientation

    // Tagyear at offset year

    Ok(tags)
}

fn process_quicktime_itunesinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TagActors at offset Actors

    // EncodingParams at offset Encoding Params

    // Data at offset data

    // ContentRating at offset iTunEXTC

    // iTunMOVI at offset iTunMOVI

    // VolumeNormalization at offset iTunNORM

    // iTunSMPB at offset iTunSMPB

    // Mean at offset mean

    // Name at offset name

    // iTunTool at offset tool
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_quicktime_faceinfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FaceRec at offset crec

    Ok(tags)
}

fn process_quicktime_audiosampledesc(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AudioVendorID at offset 20
    if data.len() >= 48 {
        // TODO: Handle format undef
    }

    // AudioChannels at offset 24
    if data.len() >= 50 {
        // TODO: Handle format int16u
    }

    // AudioBitsPerSample at offset 26
    if data.len() >= 54 {
        // TODO: Handle format int16u
    }

    // AudioSampleRate at offset 32
    if data.len() >= 66 {
        // TODO: Handle format fixed32u
    }

    // AudioFormat at offset 4
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // SpatialAudio at offset SA3D

    // BitrateInfo at offset btrt

    // AudioChannelLayout at offset chan

    // DecodeConfig at offset damr

    // PurchaseInfo at offset pinf

    // ProtectionInfo at offset sinf

    // Wave at offset wave

    Ok(tags)
}

fn process_quicktime_visualsampledesc(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // VendorID at offset 10
    if data.len() >= 28 {
        // TODO: Handle format string
    }

    // XResolution at offset 18
    if data.len() >= 38 {
        // TODO: Handle format fixed32u
    }

    // CompressorID at offset 2
    if data.len() >= 12 {
        // TODO: Handle format string
    }

    // YResolution at offset 20
    if data.len() >= 42 {
        // TODO: Handle format fixed32u
    }

    // CompressorName at offset 25
    if data.len() >= 114 {
        // TODO: Handle format string
    }

    // CDI1 at offset CDI1

    // CMP1 at offset CMP1

    // AVCConfiguration at offset avcC

    // BitrateInfo at offset btrt

    // CleanAperture at offset clap

    // ColorRepresentation at offset colr

    // VideoFieldOrder at offset fiel

    // Gamma at offset gama
    if data.len() >= 2 {
        // TODO: Handle format fixed32u
    }

    // PixelAspectRatio at offset pasp

    // Stereoscopic3D at offset st3d
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // SphericalVideo at offset sv3d

    Ok(tags)
}

fn process_quicktime_hintsampledesc(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // HintTrackVersion at offset 16
    if data.len() >= 34 {
        // TODO: Handle format int16u
    }

    // MaxPacketSize at offset 20
    if data.len() >= 44 {
        // TODO: Handle format int32u
    }

    // HintFormat at offset 4
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // SequenceNumberRandomOffset at offset snro
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // RTPTimeScale at offset tims
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // TimestampRandomOffset at offset tsro
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_quicktime_metasampledesc(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MetaFormat at offset 4
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // MetaType at offset 8

    // BitrateInfo at offset btrt

    // Keys at offset keys

    Ok(tags)
}

fn process_quicktime_othersampledesc(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PlaybackFrameRate at offset 24
    if data.len() >= 50 {
        // TODO: Handle format rational64u
    }

    // OtherFormat at offset 4
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // FontTable at offset ftab
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    // MarlinDictionary at offset mrld

    // MarlinHeader at offset mrlh

    // MarlinValues at offset mrlv

    // OtherName at offset name
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_quicktime_bitrate(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_cleanaperture(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_colorrep(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ColorProfiles at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    // VideoFullRangeFlag at offset 10

    // ColorPrimaries at offset 4
    if data.len() >= 10 {
        // TODO: Handle format int16u
    }

    // TransferCharacteristics at offset 6
    if data.len() >= 14 {
        // TODO: Handle format int16u
    }

    // MatrixCoefficients at offset 8
    if data.len() >= 18 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_quicktime_sv3d(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Projection at offset proj

    // MetadataSource at offset svhd
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_quicktime_spatialaudio(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AmbisonicType at offset 1

    // AmbisonicChannelMap at offset 12

    // AmbisonicOrder at offset 2
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // AmbisonicChannelOrdering at offset 6

    // AmbisonicNormalization at offset 7

    // AmbisonicChannels at offset 8
    if data.len() >= 20 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_quicktime_channellayout(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Channel5Flags at offset 100
    if data.len() >= 204 {
        // TODO: Handle format int32u
    }

    // Channel5Coordinates at offset 104
    if data.len() >= 214 {
        // TODO: Handle format float
    }

    // Channel6Label at offset 116
    if data.len() >= 236 {
        // TODO: Handle format int32u
    }

    // NumChannelDescriptions at offset 12
    if data.len() >= 28 {
        // TODO: Handle format int32u
    }

    // Channel6Flags at offset 120
    if data.len() >= 244 {
        // TODO: Handle format int32u
    }

    // Channel6Coordinates at offset 124
    if data.len() >= 254 {
        // TODO: Handle format float
    }

    // Channel7Label at offset 136
    if data.len() >= 276 {
        // TODO: Handle format int32u
    }

    // Channel7Flags at offset 140
    if data.len() >= 284 {
        // TODO: Handle format int32u
    }

    // Channel7Coordinates at offset 144
    if data.len() >= 294 {
        // TODO: Handle format float
    }

    // Channel8Label at offset 156
    if data.len() >= 316 {
        // TODO: Handle format int32u
    }

    // Channel1Label at offset 16
    if data.len() >= 36 {
        // TODO: Handle format int32u
    }

    // Channel8Flags at offset 160
    if data.len() >= 324 {
        // TODO: Handle format int32u
    }

    // Channel8Coordinates at offset 164
    if data.len() >= 334 {
        // TODO: Handle format float
    }

    // Channel1Flags at offset 20
    if data.len() >= 44 {
        // TODO: Handle format int32u
    }

    // Channel1Coordinates at offset 24
    if data.len() >= 54 {
        // TODO: Handle format float
    }

    // Channel2Label at offset 36
    if data.len() >= 76 {
        // TODO: Handle format int32u
    }

    // LayoutFlags at offset 4
    if data.len() >= 10 {
        // TODO: Handle format int16u
    }

    // Channel2Flags at offset 40
    if data.len() >= 84 {
        // TODO: Handle format int32u
    }

    // Channel2Coordinates at offset 44
    if data.len() >= 94 {
        // TODO: Handle format float
    }

    // Channel3Label at offset 56
    if data.len() >= 116 {
        // TODO: Handle format int32u
    }

    // AudioChannels at offset 6
    if data.len() >= 14 {
        // TODO: Handle format int16u
    }

    // Channel3Flags at offset 60
    if data.len() >= 124 {
        // TODO: Handle format int32u
    }

    // Channel3Coordinates at offset 64
    if data.len() >= 134 {
        // TODO: Handle format float
    }

    // Channel4Label at offset 76
    if data.len() >= 156 {
        // TODO: Handle format int32u
    }

    // AudioChannelTypes at offset 8
    if data.len() >= 20 {
        // TODO: Handle format int32u
    }

    // Channel4Flags at offset 80
    if data.len() >= 164 {
        // TODO: Handle format int32u
    }

    // Channel4Coordinates at offset 84
    if data.len() >= 174 {
        // TODO: Handle format float
    }

    // Channel5Label at offset 96
    if data.len() >= 196 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_quicktime_decodeconfig(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // EncoderVendor at offset 0
    if data.len() >= 8 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_quicktime_protectioninfo(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Endianness at offset enda
    if data.len() >= 2 {
        // TODO: Handle format int16u
    }

    // SchemeInfo at offset schi

    // SchemeType at offset schm

    Ok(tags)
}

fn process_quicktime_wave(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Endianness at offset enda
    if data.len() >= 2 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_quicktime_genmediaheader(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // GenMediaInfo at offset gmin

    // Text at offset text

    // TimeCode at offset tmcd

    Ok(tags)
}

fn process_quicktime_hintheader(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MaxBitrate at offset 4
    if data.len() >= 12 {
        // TODO: Handle format int32u
    }

    // AvgBitrate at offset 6
    if data.len() >= 16 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_quicktime_audioheader(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Balance at offset 2
    if data.len() >= 6 {
        // TODO: Handle format fixed16s
    }

    Ok(tags)
}

fn process_quicktime_sampletable(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ChunkOffset64 at offset co64

    // CompositionToDecodeTimelineMapping at offset cslg

    // CompositionTimeToSample at offset ctts

    // SamplePaddingBits at offset padb

    // SampleToGroup at offset sbgp

    // IdependentAndDisposableSamples at offset sdtp

    // SampleGroupDescription at offset sgpd

    // ChunkOffset at offset stco

    // SampleDegradationPriority at offset stdp

    // PartialSyncSamples at offset stps

    // SampleToChunk at offset stsc

    // ShadowSyncSampleTable at offset stsh

    // SyncSampleTable at offset stss

    // SampleSizes at offset stsz

    // CompactSampleSizes at offset stz2

    // Sub-sampleInformation at offset subs

    Ok(tags)
}

fn process_quicktime_videoheader(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // GraphicsMode at offset 2

    // OpColor at offset 3
    if data.len() >= 12 {
        if let Ok(values) = read_int16u_array(&data[6..12], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("OpColor".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_quicktime_itempropcont(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AuxiliaryImageType at offset auxC
    if data.len() >= 2 {
        // TODO: Handle format undef
    }

    // AV1Configuration at offset av1C

    // CleanAperture at offset clap
    if data.len() >= 2 {
        // TODO: Handle format rational64s
    }

    // ContentLightLevel at offset clli

    // HEVCConfiguration at offset hvcC

    // Rotation at offset irot
    if !data.is_empty() {
        // TODO: Handle format int8u
    }

    // ImageSpatialExtent at offset ispe

    // PixelAspectRatio at offset pasp
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // ImagePixelDepth at offset pixi

    // RelativeLocation at offset rloc
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_quicktime_av1config(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AV1ConfigurationVersion at offset 0

    // SeqProfile at offset 1

    // SeqLevelIdx0 at offset 1.1

    // SeqTier0 at offset 2

    // HighBitDepth at offset 2.1

    // TwelveBit at offset 2.2

    // ChromaFormat at offset 2.3

    // ChromaSamplePosition at offset 2.4

    // InitialDelaySamples at offset 3

    Ok(tags)
}

fn process_quicktime_contentlightlevel(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_hevcconfig(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // GeneralProfileSpace at offset 1

    // GeneralTierFlag at offset 1.1

    // GeneralProfileIDC at offset 1.2

    // GeneralLevelIDC at offset 12

    // MinSpatialSegmentationIDC at offset 13
    if data.len() >= 28 {
        // TODO: Handle format int16u
    }

    // ParallelismType at offset 15

    // ChromaFormat at offset 16

    // BitDepthLuma at offset 17

    // BitDepthChroma at offset 18

    // AverageFrameRate at offset 19
    if data.len() >= 40 {
        // TODO: Handle format int16u
    }

    // GenProfileCompatibilityFlags at offset 2
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // ConstantFrameRate at offset 21

    // NumTemporalLayers at offset 21.1

    // TemporalIDNested at offset 21.2

    // ConstraintIndicatorFlags at offset 6
    if data.len() >= 18 {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_quicktime_proj(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CubemapProj at offset cbmp

    // EquirectangularProj at offset equi

    // ProjectionHeader at offset prhd

    Ok(tags)
}

fn process_quicktime_cbmp(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_equi(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ProjectionBoundsTop at offset 1

    // ProjectionBoundsBottom at offset 2

    // ProjectionBoundsLeft at offset 3

    // ProjectionBoundsRight at offset 4

    Ok(tags)
}

fn process_quicktime_prhd(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_moviefraghdr(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_quicktime_trackfragment(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Meta at offset meta

    Ok(tags)
}

// Stub functions for tables not extracted by tag kit
fn process_quicktime_stream(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

fn process_quicktime_tags360fly(
    data: &[u8],
    _byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    // TODO: Implement when this table is extracted
    tracing::debug!("Stub function called for {}", data.len());
    Ok(vec![])
}

pub fn process_tag_0x0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    if let Some(tag_kit) = QUICKTIME_PM_TAG_KITS.get(&tag_id) {
        // Normal PrintConv processing only
        match &tag_kit.print_conv {
            PrintConvType::None => value.clone(),
            PrintConvType::Simple(lookup) => {
                // Convert value to string key for lookup
                let key = match value {
                    TagValue::U8(v) => v.to_string(),
                    TagValue::U16(v) => v.to_string(),
                    TagValue::U32(v) => v.to_string(),
                    TagValue::I16(v) => v.to_string(),
                    TagValue::I32(v) => v.to_string(),
                    TagValue::String(s) => s.clone(),
                    _ => return value.clone(),
                };

                if let Some(result) = lookup.get(&key) {
                    TagValue::String(result.to_string())
                } else {
                    TagValue::String(format!("Unknown ({})", value))
                }
            }
            PrintConvType::Expression(expr) => {
                // TODO: Implement expression evaluation
                warnings.push(format!(
                    "Expression PrintConv not yet implemented for tag {}: {}",
                    tag_kit.name, expr
                ));
                value.clone()
            }
            PrintConvType::Manual(func_name) => {
                // TODO: Look up in manual registry
                warnings.push(format!(
                    "Manual PrintConv '{}' not found for tag {}",
                    func_name, tag_kit.name
                ));
                value.clone()
            }
        }
    } else {
        // Tag not found in kit
        value.clone()
    }
}

/// Check if a tag has subdirectory processing
pub fn has_subdirectory(tag_id: u32) -> bool {
    if let Some(tag_kit) = QUICKTIME_PM_TAG_KITS.get(&tag_id) {
        tag_kit.subdirectory.is_some()
    } else {
        false
    }
}

/// Process subdirectory tags and return multiple extracted tags
pub fn process_subdirectory(
    tag_id: u32,
    value: &TagValue,
    byte_order: ByteOrder,
) -> Result<HashMap<String, TagValue>> {
    use tracing::debug;
    let mut result = HashMap::new();

    debug!("process_subdirectory called for tag_id: 0x{:04x}", tag_id);

    if let Some(tag_kit) = QUICKTIME_PM_TAG_KITS.get(&tag_id) {
        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {
            debug!("Found subdirectory processor for tag_id: 0x{:04x}", tag_id);
            let bytes = match value {
                TagValue::U16Array(arr) => {
                    debug!("Converting U16Array with {} elements to bytes", arr.len());
                    // Convert U16 array to bytes based on byte order
                    let mut bytes = Vec::with_capacity(arr.len() * 2);
                    for val in arr {
                        match byte_order {
                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),
                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),
                        }
                    }
                    bytes
                }
                TagValue::U8Array(arr) => arr.clone(),
                _ => return Ok(result), // Not array data
            };

            debug!("Calling processor with {} bytes", bytes.len());
            // Process subdirectory and collect all extracted tags
            match processor(&bytes, byte_order) {
                Ok(extracted_tags) => {
                    debug!("Processor returned {} tags", extracted_tags.len());
                    for (name, value) in extracted_tags {
                        result.insert(name, value);
                    }
                }
                Err(e) => {
                    debug!("Processor error: {:?}", e);
                }
            }
        } else {
            debug!(
                "No subdirectory processor found for tag_id: 0x{:04x}",
                tag_id
            );
        }
    } else {
        debug!("Tag not found in TAG_KITS: 0x{:04x}", tag_id);
    }

    Ok(result)
}
