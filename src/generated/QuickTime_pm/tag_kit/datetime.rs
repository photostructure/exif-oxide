//! Tag kits for datetime category from QuickTime.pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.

#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

use super::*;
use super::{PrintConvType, SubDirectoryType, TagKitDef};
use crate::types::TagValue;
use std::collections::HashMap;
use std::sync::LazyLock;

/// Get tag definitions for datetime category
pub fn get_datetime_tags() -> Vec<(u32, TagKitDef)> {
    vec![
        (0, TagKitDef {
            id: 0,
            name: "ContentCreateDate",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: Some("some stupid Ricoh programmer used the '@' symbol instead of the copyright\n            symbol in these tag ID's for the Ricoh Theta Z1 and maybe other models"),
            print_conv: PrintConvType::Manual("complex_expression_printconv"),
            value_conv: Some("\n        require Image::ExifTool::XMP;\n        $val =  Image::ExifTool::XMP::ConvertXMPDate($val);\n        $val =~ s/([-+]\\d{2})(\\d{2})$/$1:$2/; # add colon to timezone if necessary\n        return $val;\n    "),
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "DateTimeOriginal",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: Some("Apple Photos has been reported to show a crazy date/time for some MP4 files\n            containing this tag, but perhaps only if it is missing a time zone"),
            print_conv: PrintConvType::Manual("complex_expression_printconv"),
            value_conv: Some("\n        require Image::ExifTool::XMP;\n        $val =  Image::ExifTool::XMP::ConvertXMPDate($val);\n        $val =~ s/([-+]\\d{2})(\\d{2})$/$1:$2/; # add colon to timezone if necessary\n        return $val;\n    "),
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "TimeStamp",
            format: "int32u",
            groups: HashMap::new(),
            writable: true,
            notes: None,
            print_conv: PrintConvType::Manual("complex_expression_printconv"),
            value_conv: Some("$val =~ s/ .*//; ConvertUnixTime($val)"),
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "ContentCreateDate",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: None,
            print_conv: PrintConvType::Manual("complex_expression_printconv"),
            value_conv: Some("\n        require Image::ExifTool::XMP;\n        $val =  Image::ExifTool::XMP::ConvertXMPDate($val);\n        $val =~ s/([-+]\\d{2})(\\d{2})$/$1:$2/; # add colon to timezone if necessary\n        return $val;\n    "),
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "GoogleStartTime",
            format: "string",
            groups: HashMap::new(),
            writable: false,
            notes: None,
            print_conv: PrintConvType::None,
            value_conv: None,
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "ReleaseDate",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: None,
            print_conv: PrintConvType::None,
            value_conv: None,
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "ContentCreateDate",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: None,
            print_conv: PrintConvType::Manual("complex_expression_printconv"),
            value_conv: Some("\n        require Image::ExifTool::XMP;\n        $val =  Image::ExifTool::XMP::ConvertXMPDate($val);\n        $val =~ s/([-+]\\d{2})(\\d{2})$/$1:$2/; # add colon to timezone if necessary\n        return $val;\n    "),
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "CreationTime",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: None,
            print_conv: PrintConvType::Manual("complex_expression_printconv"),
            value_conv: Some("\n        require Image::ExifTool::XMP;\n        $val =  Image::ExifTool::XMP::ConvertXMPDate($val);\n        $val =~ s/([-+]\\d{2})(\\d{2})$/$1:$2/; # add colon to timezone if necessary\n        return $val;\n    "),
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "CreationDate",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: None,
            print_conv: PrintConvType::Manual("complex_expression_printconv"),
            value_conv: Some("\n        require Image::ExifTool::XMP;\n        $val =  Image::ExifTool::XMP::ConvertXMPDate($val);\n        $val =~ s/([-+]\\d{2})(\\d{2})$/$1:$2/; # add colon to timezone if necessary\n        return $val;\n    "),
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "LocationDate",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: None,
            print_conv: PrintConvType::Manual("complex_expression_printconv"),
            value_conv: Some("\n        require Image::ExifTool::XMP;\n        $val =  Image::ExifTool::XMP::ConvertXMPDate($val);\n        $val =~ s/([-+]\\d{2})(\\d{2})$/$1:$2/; # add colon to timezone if necessary\n        return $val;\n    "),
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "StillImageTime",
            format: "unknown",
            groups: HashMap::new(),
            writable: true,
            notes: Some("this tag always has a value of -1; the time of the still image is obtained\n            from the associated SampleTime"),
            print_conv: PrintConvType::None,
            value_conv: None,
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "CompositionToDecodeTimelineMapping",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: None,
            print_conv: PrintConvType::None,
            value_conv: None,
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "CompositionTimeToSample",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: None,
            print_conv: PrintConvType::None,
            value_conv: None,
            subdirectory: None,
        }),
        (0, TagKitDef {
            id: 0,
            name: "TimeToSampleTable",
            format: "unknown",
            groups: HashMap::new(),
            writable: false,
            notes: None,
            print_conv: PrintConvType::None,
            value_conv: None,
            subdirectory: None,
        }),
    ]
}
