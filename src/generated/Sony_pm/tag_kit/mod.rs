//! Modular tag kits with embedded PrintConv for Sony_pm
//!
//! This file is automatically generated by codegen.
//! DO NOT EDIT MANUALLY - changes will be overwritten.
//!
//! Generated from: Sony.pm table: Main
//!
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(dead_code)]
#![allow(unused_variables)]

pub mod camera;
pub mod color;
pub mod core;
pub mod datetime;
pub mod exif_specific;
pub mod interop;
pub mod other;
pub mod thumbnail;

use crate::expressions::ExpressionEvaluator;
use crate::tiff_types::ByteOrder;
use crate::types::{Result, TagValue};
use std::collections::HashMap;
use std::sync::LazyLock;

#[derive(Debug, Clone)]
pub struct TagKitDef {
    pub id: u32,
    pub name: &'static str,
    pub format: &'static str,
    pub groups: HashMap<&'static str, &'static str>,
    pub writable: bool,
    pub notes: Option<&'static str>,
    pub print_conv: PrintConvType,
    pub value_conv: Option<&'static str>,
    pub subdirectory: Option<SubDirectoryType>,
}

#[derive(Debug, Clone)]
pub enum PrintConvType {
    None,
    Simple(&'static HashMap<String, &'static str>),
    Expression(&'static str),
    Manual(&'static str),
}

/// Type alias for subdirectory processor function
pub type SubDirectoryProcessor = fn(&[u8], ByteOrder) -> Result<Vec<(String, TagValue)>>;

#[derive(Debug, Clone)]
pub enum SubDirectoryType {
    Binary { processor: SubDirectoryProcessor },
}

/// All tag kits for Sony_pm
pub static SONY_PM_TAG_KITS: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {
    let mut map: HashMap<u32, TagKitDef> = HashMap::new();

    // camera tags
    for (id, tag_def) in camera::get_camera_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // color tags
    for (id, tag_def) in color::get_color_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // core tags
    for (id, tag_def) in core::get_core_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // datetime tags
    for (id, tag_def) in datetime::get_datetime_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // exif_specific tags
    for (id, tag_def) in exif_specific::get_exif_specific_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // interop tags
    for (id, tag_def) in interop::get_interop_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // other tags
    for (id, tag_def) in other::get_other_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    // thumbnail tags
    for (id, tag_def) in thumbnail::get_thumbnail_tags() {
        // Priority insertion: preserve existing entries with subdirectory processors
        match map.get(&id) {
            Some(existing) if existing.subdirectory.is_some() => {
                // Keep existing tag if it has a subdirectory processor
                if tag_def.subdirectory.is_none() {
                    // Skip this tag - existing one is more important
                    continue;
                }
            }
            _ => {}
        }
        map.insert(id, tag_def);
    }

    map
});

// Helper functions for reading binary data
fn model_matches(model: &str, pattern: &str) -> bool {
    // ExifTool regexes are already in a compatible format
    // Just need to ensure proper escaping was preserved

    match regex::Regex::new(pattern) {
        Ok(re) => re.is_match(model),
        Err(e) => {
            tracing::warn!("Failed to compile model regex '{}': {}", pattern, e);
            false
        }
    }
}

fn format_matches(format: &str, pattern: &str) -> bool {
    if let Ok(re) = regex::Regex::new(pattern) {
        re.is_match(format)
    } else {
        tracing::warn!("Failed to compile format regex: {}", pattern);
        false
    }
}

fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {
    if data.len() < count * 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16u array".to_string(),
        ));
    }
    let mut values = Vec::with_capacity(count);
    for i in 0..count {
        let offset = i * 2;
        let value = match byte_order {
            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),
            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),
        };
        values.push(value);
    }
    Ok(values)
}

fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {
    if data.len() < 2 {
        return Err(crate::types::ExifError::ParseError(
            "Insufficient data for int16s".to_string(),
        ));
    }
    Ok(match byte_order {
        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),
        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),
    })
}

// Subdirectory processing functions
fn process_sony_moresettings(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // DriveMode2 at offset 1

    // SharpnessSetting at offset 10
    if data.len() >= 21 {
        // TODO: Handle format int8s
    }

    // FlashAction2 at offset 119

    // FlashActionExternal at offset 120

    // FlashActionExternal at offset 124

    // WhiteBalanceSetting at offset 13

    // FlashStatus at offset 130

    // FlashStatus at offset 134

    // ColorTemperatureSetting at offset 14

    // ColorCompensationFilterSet at offset 15
    if data.len() >= 31 {
        // TODO: Handle format int8s
    }

    // FlashMode at offset 16

    // LongExposureNoiseReduction at offset 17

    // HighISONoiseReduction at offset 18

    // FocusMode at offset 19

    // ExposureProgram at offset 2

    // MultiFrameNoiseReduction at offset 21

    // HDRSetting at offset 22

    // HDRLevel at offset 23

    // ViewingMode at offset 24

    // FaceDetection at offset 25

    // CustomWB_RBLevels at offset 26
    if data.len() >= 56 {
        // TODO: Handle format int16uRev
    }

    // MeteringMode at offset 3

    // FNumber at offset 34

    // ExposureCompensation2 at offset 36
    if data.len() >= 74 {
        if let Ok(value) = read_int16s(&data[72..74], byte_order) {
            tags.push(("ExposureCompensation2".to_string(), TagValue::I16(value)));
        }
    }

    // ExposureTime at offset 39

    // DynamicRangeOptimizerSetting at offset 4

    // Orientation2 at offset 40

    // FocusPosition2 at offset 43

    // FocusPosition2 at offset 47

    // FlashAction at offset 48

    // FocusMode2 at offset 50

    // ColorSpace at offset 6

    // CreativeStyleSetting at offset 7

    // ContrastSetting at offset 8
    if data.len() >= 17 {
        // TODO: Handle format int8s
    }

    // SaturationSetting at offset 9
    if data.len() >= 19 {
        // TODO: Handle format int8s
    }

    Ok(tags)
}

fn process_sony_faceinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FacesDetected at offset 0
    if data.len() >= 2 {
        if let Ok(value) = read_int16s(&data[0..2], byte_order) {
            tags.push(("FacesDetected".to_string(), TagValue::I16(value)));
        }
    }

    // Face1Position at offset 1
    if data.len() >= 10 {
        if let Ok(values) = read_int16u_array(&data[2..10], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face1Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face3Position at offset 11
    if data.len() >= 30 {
        if let Ok(values) = read_int16u_array(&data[22..30], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face3Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face4Position at offset 16
    if data.len() >= 40 {
        if let Ok(values) = read_int16u_array(&data[32..40], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face4Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face5Position at offset 21
    if data.len() >= 50 {
        if let Ok(values) = read_int16u_array(&data[42..50], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face5Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face6Position at offset 26
    if data.len() >= 60 {
        if let Ok(values) = read_int16u_array(&data[52..60], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face6Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face7Position at offset 31
    if data.len() >= 70 {
        if let Ok(values) = read_int16u_array(&data[62..70], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face7Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face8Position at offset 36
    if data.len() >= 80 {
        if let Ok(values) = read_int16u_array(&data[72..80], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face8Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face2Position at offset 6
    if data.len() >= 20 {
        if let Ok(values) = read_int16u_array(&data[12..20], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face2Position".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_sony_faceinfoa(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Face2Position at offset 101
    if data.len() >= 210 {
        if let Ok(values) = read_int16u_array(&data[202..210], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face2Position".to_string(), TagValue::String(value_str)));
        }
    }

    // PotentialFace1Position at offset 11
    if data.len() >= 30 {
        if let Ok(values) = read_int16u_array(&data[22..30], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PotentialFace1Position".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // Face3Position at offset 111
    if data.len() >= 230 {
        if let Ok(values) = read_int16u_array(&data[222..230], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face3Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face4Position at offset 121
    if data.len() >= 250 {
        if let Ok(values) = read_int16u_array(&data[242..250], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face4Position".to_string(), TagValue::String(value_str)));
        }
    }

    // FaceTest2 at offset 2

    // PotentialFace2Position at offset 21
    if data.len() >= 50 {
        if let Ok(values) = read_int16u_array(&data[42..50], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PotentialFace2Position".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FacesDetected at offset 3

    // PotentialFace3Position at offset 31
    if data.len() >= 70 {
        if let Ok(values) = read_int16u_array(&data[62..70], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PotentialFace3Position".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // PotentialFace4Position at offset 41
    if data.len() >= 90 {
        if let Ok(values) = read_int16u_array(&data[82..90], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PotentialFace4Position".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // PotentialFace5Position at offset 51
    if data.len() >= 110 {
        if let Ok(values) = read_int16u_array(&data[102..110], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PotentialFace5Position".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // PotentialFace6Position at offset 61
    if data.len() >= 130 {
        if let Ok(values) = read_int16u_array(&data[122..130], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PotentialFace6Position".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // PotentialFace7Position at offset 71
    if data.len() >= 150 {
        if let Ok(values) = read_int16u_array(&data[142..150], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PotentialFace7Position".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FaceTest8 at offset 8

    // PotentialFace8Position at offset 81
    if data.len() >= 170 {
        if let Ok(values) = read_int16u_array(&data[162..170], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "PotentialFace8Position".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // Face1Position at offset 91
    if data.len() >= 190 {
        if let Ok(values) = read_int16u_array(&data[182..190], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face1Position".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_sony_camerainfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensSpec at offset 0
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // FocusModeSetting at offset 20

    // AFPointSelected at offset 21

    // AFPoint at offset 25

    // AFStatusActiveSensor at offset 30
    if data.len() >= 62 {
        if let Ok(value) = read_int16s(&data[60..62], byte_order) {
            tags.push(("AFStatusActiveSensor".to_string(), TagValue::I16(value)));
        }
    }

    // AFMicroAdjValue at offset 304

    // AFMicroAdjMode at offset 305

    // AFMicroAdjRegisteredLenses at offset 305.1

    // AFStatusUpper-left at offset 32
    if data.len() >= 66 {
        if let Ok(value) = read_int16s(&data[64..66], byte_order) {
            tags.push(("AFStatusUpper-left".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusLeft at offset 34
    if data.len() >= 70 {
        if let Ok(value) = read_int16s(&data[68..70], byte_order) {
            tags.push(("AFStatusLeft".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusLower-left at offset 36
    if data.len() >= 74 {
        if let Ok(value) = read_int16s(&data[72..74], byte_order) {
            tags.push(("AFStatusLower-left".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusFarLeft at offset 38
    if data.len() >= 78 {
        if let Ok(value) = read_int16s(&data[76..78], byte_order) {
            tags.push(("AFStatusFarLeft".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusBottomAssist-left at offset 40
    if data.len() >= 82 {
        if let Ok(value) = read_int16s(&data[80..82], byte_order) {
            tags.push((
                "AFStatusBottomAssist-left".to_string(),
                TagValue::I16(value),
            ));
        }
    }

    // AFStatusBottom at offset 42
    if data.len() >= 86 {
        if let Ok(value) = read_int16s(&data[84..86], byte_order) {
            tags.push(("AFStatusBottom".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusBottomAssist-right at offset 44
    if data.len() >= 90 {
        if let Ok(value) = read_int16s(&data[88..90], byte_order) {
            tags.push((
                "AFStatusBottomAssist-right".to_string(),
                TagValue::I16(value),
            ));
        }
    }

    // AFStatusCenter-7 at offset 46
    if data.len() >= 94 {
        if let Ok(value) = read_int16s(&data[92..94], byte_order) {
            tags.push(("AFStatusCenter-7".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenter-horizontal at offset 48
    if data.len() >= 98 {
        if let Ok(value) = read_int16s(&data[96..98], byte_order) {
            tags.push((
                "AFStatusCenter-horizontal".to_string(),
                TagValue::I16(value),
            ));
        }
    }

    // AFStatusCenter-9 at offset 50
    if data.len() >= 102 {
        if let Ok(value) = read_int16s(&data[100..102], byte_order) {
            tags.push(("AFStatusCenter-9".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenter-10 at offset 52
    if data.len() >= 106 {
        if let Ok(value) = read_int16s(&data[104..106], byte_order) {
            tags.push(("AFStatusCenter-10".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenter-11 at offset 54
    if data.len() >= 110 {
        if let Ok(value) = read_int16s(&data[108..110], byte_order) {
            tags.push(("AFStatusCenter-11".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenter-12 at offset 56
    if data.len() >= 114 {
        if let Ok(value) = read_int16s(&data[112..114], byte_order) {
            tags.push(("AFStatusCenter-12".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenter-vertical at offset 58
    if data.len() >= 118 {
        if let Ok(value) = read_int16s(&data[116..118], byte_order) {
            tags.push(("AFStatusCenter-vertical".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenter-14 at offset 60
    if data.len() >= 122 {
        if let Ok(value) = read_int16s(&data[120..122], byte_order) {
            tags.push(("AFStatusCenter-14".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusTopAssist-left at offset 62
    if data.len() >= 126 {
        if let Ok(value) = read_int16s(&data[124..126], byte_order) {
            tags.push(("AFStatusTopAssist-left".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusTop at offset 64
    if data.len() >= 130 {
        if let Ok(value) = read_int16s(&data[128..130], byte_order) {
            tags.push(("AFStatusTop".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusTopAssist-right at offset 66
    if data.len() >= 134 {
        if let Ok(value) = read_int16s(&data[132..134], byte_order) {
            tags.push(("AFStatusTopAssist-right".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusFarRight at offset 68
    if data.len() >= 138 {
        if let Ok(value) = read_int16s(&data[136..138], byte_order) {
            tags.push(("AFStatusFarRight".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusUpper-right at offset 70
    if data.len() >= 142 {
        if let Ok(value) = read_int16s(&data[140..142], byte_order) {
            tags.push(("AFStatusUpper-right".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusRight at offset 72
    if data.len() >= 146 {
        if let Ok(value) = read_int16s(&data[144..146], byte_order) {
            tags.push(("AFStatusRight".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusLower-right at offset 74
    if data.len() >= 150 {
        if let Ok(value) = read_int16s(&data[148..150], byte_order) {
            tags.push(("AFStatusLower-right".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenterF2-8 at offset 76
    if data.len() >= 154 {
        if let Ok(value) = read_int16s(&data[152..154], byte_order) {
            tags.push(("AFStatusCenterF2-8".to_string(), TagValue::I16(value)));
        }
    }

    Ok(tags)
}

fn process_sony_camerainfo2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensSpec at offset 0
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // AFPointSelected at offset 20

    // FocusModeSetting at offset 21

    // AFPoint at offset 24

    // AFStatusActiveSensor at offset 27
    if data.len() >= 56 {
        if let Ok(value) = read_int16s(&data[54..56], byte_order) {
            tags.push(("AFStatusActiveSensor".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusTop-right at offset 29
    if data.len() >= 60 {
        if let Ok(value) = read_int16s(&data[58..60], byte_order) {
            tags.push(("AFStatusTop-right".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusBottom-right at offset 31
    if data.len() >= 64 {
        if let Ok(value) = read_int16s(&data[62..64], byte_order) {
            tags.push(("AFStatusBottom-right".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusBottom at offset 33
    if data.len() >= 68 {
        if let Ok(value) = read_int16s(&data[66..68], byte_order) {
            tags.push(("AFStatusBottom".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusMiddleHorizontal at offset 35
    if data.len() >= 72 {
        if let Ok(value) = read_int16s(&data[70..72], byte_order) {
            tags.push(("AFStatusMiddleHorizontal".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenterVertical at offset 37
    if data.len() >= 76 {
        if let Ok(value) = read_int16s(&data[74..76], byte_order) {
            tags.push(("AFStatusCenterVertical".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusTop at offset 39
    if data.len() >= 80 {
        if let Ok(value) = read_int16s(&data[78..80], byte_order) {
            tags.push(("AFStatusTop".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusTop-left at offset 41
    if data.len() >= 84 {
        if let Ok(value) = read_int16s(&data[82..84], byte_order) {
            tags.push(("AFStatusTop-left".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusBottom-left at offset 43
    if data.len() >= 88 {
        if let Ok(value) = read_int16s(&data[86..88], byte_order) {
            tags.push(("AFStatusBottom-left".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusLeft at offset 45
    if data.len() >= 92 {
        if let Ok(value) = read_int16s(&data[90..92], byte_order) {
            tags.push(("AFStatusLeft".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenterHorizontal at offset 47
    if data.len() >= 96 {
        if let Ok(value) = read_int16s(&data[94..96], byte_order) {
            tags.push(("AFStatusCenterHorizontal".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusRight at offset 49
    if data.len() >= 100 {
        if let Ok(value) = read_int16s(&data[98..100], byte_order) {
            tags.push(("AFStatusRight".to_string(), TagValue::I16(value)));
        }
    }

    Ok(tags)
}

fn process_sony_camerainfo3(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // LensSpec at offset 0
    if data.len() >= 16 {
        // TODO: Handle format undef
    }

    // FocalLength at offset 14
    if data.len() >= 30 {
        // TODO: Handle format int16u
    }

    // FocalLengthTeleZoom at offset 16
    if data.len() >= 34 {
        // TODO: Handle format int16u
    }

    // AFPointSelected at offset 20

    // FocusMode at offset 21

    // AFPoint at offset 24

    // FocusStatus at offset 25

    // AFStatusActiveSensor at offset 27
    if data.len() >= 56 {
        if let Ok(value) = read_int16s(&data[54..56], byte_order) {
            tags.push(("AFStatusActiveSensor".to_string(), TagValue::I16(value)));
        }
    }

    // AFPointSelected at offset 28

    // AFStatusBottom-right at offset 31
    if data.len() >= 64 {
        if let Ok(value) = read_int16s(&data[62..64], byte_order) {
            tags.push(("AFStatusBottom-right".to_string(), TagValue::I16(value)));
        }
    }

    // AFPoint at offset 32

    // AFStatusCenterVertical at offset 37
    if data.len() >= 76 {
        if let Ok(value) = read_int16s(&data[74..76], byte_order) {
            tags.push(("AFStatusCenterVertical".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusTop at offset 39
    if data.len() >= 80 {
        if let Ok(value) = read_int16s(&data[78..80], byte_order) {
            tags.push(("AFStatusTop".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusTop-left at offset 41
    if data.len() >= 84 {
        if let Ok(value) = read_int16s(&data[82..84], byte_order) {
            tags.push(("AFStatusTop-left".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusBottom-left at offset 43
    if data.len() >= 88 {
        if let Ok(value) = read_int16s(&data[86..88], byte_order) {
            tags.push(("AFStatusBottom-left".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusLeft at offset 45
    if data.len() >= 92 {
        if let Ok(value) = read_int16s(&data[90..92], byte_order) {
            tags.push(("AFStatusLeft".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenterHorizontal at offset 47
    if data.len() >= 96 {
        if let Ok(value) = read_int16s(&data[94..96], byte_order) {
            tags.push(("AFStatusCenterHorizontal".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusRight at offset 49
    if data.len() >= 100 {
        if let Ok(value) = read_int16s(&data[98..100], byte_order) {
            tags.push(("AFStatusRight".to_string(), TagValue::I16(value)));
        }
    }

    Ok(tags)
}

fn process_sony_camerainfounknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_sony_focusinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ISOSetting at offset 109

    // ISO at offset 111

    // DynamicRangeOptimizerMode at offset 119

    // Rotation at offset 16

    // ImageStabilizationSetting at offset 20

    // DynamicRangeOptimizerMode at offset 21

    // ShutterCount at offset 2118
    if data.len() >= 4240 {
        // TODO: Handle format int32u
    }

    // FocusPosition at offset 2491

    // BracketShotNumber at offset 43

    // TiffMeteringImage at offset 4368
    if data.len() >= 27936 {
        // TODO: Handle format undef
    }

    // WhiteBalanceBracketing at offset 44

    // BracketShotNumber2 at offset 45

    // DynamicRangeOptimizerBracket at offset 46

    // ExposureBracketShotNumber at offset 47

    // ExposureProgram at offset 63

    // CreativeStyle at offset 65

    Ok(tags)
}

fn process_sony_moreinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MoreSettings at offset 1

    // MoreInfo0401 at offset 1025

    // TiffMeteringImage at offset 263

    // MoreInfo0201 at offset 513

    Ok(tags)
}

fn process_sony_afstatus15(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFStatusUpper-left at offset 0
    if data.len() >= 2 {
        if let Ok(value) = read_int16s(&data[0..2], byte_order) {
            tags.push(("AFStatusUpper-left".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusNearRight at offset 10
    if data.len() >= 22 {
        if let Ok(value) = read_int16s(&data[20..22], byte_order) {
            tags.push(("AFStatusNearRight".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenterHorizontal at offset 12
    if data.len() >= 26 {
        if let Ok(value) = read_int16s(&data[24..26], byte_order) {
            tags.push(("AFStatusCenterHorizontal".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusNearLeft at offset 14
    if data.len() >= 30 {
        if let Ok(value) = read_int16s(&data[28..30], byte_order) {
            tags.push(("AFStatusNearLeft".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusBottomHorizontal at offset 16
    if data.len() >= 34 {
        if let Ok(value) = read_int16s(&data[32..34], byte_order) {
            tags.push(("AFStatusBottomHorizontal".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusTopVertical at offset 18
    if data.len() >= 38 {
        if let Ok(value) = read_int16s(&data[36..38], byte_order) {
            tags.push(("AFStatusTopVertical".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusLeft at offset 2
    if data.len() >= 6 {
        if let Ok(value) = read_int16s(&data[4..6], byte_order) {
            tags.push(("AFStatusLeft".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusCenterVertical at offset 20
    if data.len() >= 42 {
        if let Ok(value) = read_int16s(&data[40..42], byte_order) {
            tags.push(("AFStatusCenterVertical".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusBottomVertical at offset 22
    if data.len() >= 46 {
        if let Ok(value) = read_int16s(&data[44..46], byte_order) {
            tags.push(("AFStatusBottomVertical".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusFarRight at offset 24
    if data.len() >= 50 {
        if let Ok(value) = read_int16s(&data[48..50], byte_order) {
            tags.push(("AFStatusFarRight".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusUpper-right at offset 26
    if data.len() >= 54 {
        if let Ok(value) = read_int16s(&data[52..54], byte_order) {
            tags.push(("AFStatusUpper-right".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusRight at offset 28
    if data.len() >= 58 {
        if let Ok(value) = read_int16s(&data[56..58], byte_order) {
            tags.push(("AFStatusRight".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusLower-right at offset 30
    if data.len() >= 62 {
        if let Ok(value) = read_int16s(&data[60..62], byte_order) {
            tags.push(("AFStatusLower-right".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusUpper-middle at offset 32
    if data.len() >= 66 {
        if let Ok(value) = read_int16s(&data[64..66], byte_order) {
            tags.push(("AFStatusUpper-middle".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusLower-middle at offset 34
    if data.len() >= 70 {
        if let Ok(value) = read_int16s(&data[68..70], byte_order) {
            tags.push(("AFStatusLower-middle".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusLower-left at offset 4
    if data.len() >= 10 {
        if let Ok(value) = read_int16s(&data[8..10], byte_order) {
            tags.push(("AFStatusLower-left".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusFarLeft at offset 6
    if data.len() >= 14 {
        if let Ok(value) = read_int16s(&data[12..14], byte_order) {
            tags.push(("AFStatusFarLeft".to_string(), TagValue::I16(value)));
        }
    }

    // AFStatusTopHorizontal at offset 8
    if data.len() >= 18 {
        if let Ok(value) = read_int16s(&data[16..18], byte_order) {
            tags.push(("AFStatusTopHorizontal".to_string(), TagValue::I16(value)));
        }
    }

    Ok(tags)
}

fn process_sony_faceinfo1(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Face1Position at offset 0
    if data.len() >= 8 {
        if let Ok(values) = read_int16u_array(&data[0..8], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face1Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face5Position at offset 128
    if data.len() >= 264 {
        if let Ok(values) = read_int16u_array(&data[256..264], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face5Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face6Position at offset 160
    if data.len() >= 328 {
        if let Ok(values) = read_int16u_array(&data[320..328], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face6Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face7Position at offset 192
    if data.len() >= 392 {
        if let Ok(values) = read_int16u_array(&data[384..392], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face7Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face8Position at offset 224
    if data.len() >= 456 {
        if let Ok(values) = read_int16u_array(&data[448..456], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face8Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face2Position at offset 32
    if data.len() >= 72 {
        if let Ok(values) = read_int16u_array(&data[64..72], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face2Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face3Position at offset 64
    if data.len() >= 136 {
        if let Ok(values) = read_int16u_array(&data[128..136], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face3Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face4Position at offset 96
    if data.len() >= 200 {
        if let Ok(values) = read_int16u_array(&data[192..200], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face4Position".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_sony_faceinfo2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Face1Position at offset 0
    if data.len() >= 8 {
        if let Ok(values) = read_int16u_array(&data[0..8], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face1Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face4Position at offset 111
    if data.len() >= 230 {
        if let Ok(values) = read_int16u_array(&data[222..230], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face4Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face5Position at offset 148
    if data.len() >= 304 {
        if let Ok(values) = read_int16u_array(&data[296..304], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face5Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face6Position at offset 185
    if data.len() >= 378 {
        if let Ok(values) = read_int16u_array(&data[370..378], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face6Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face7Position at offset 222
    if data.len() >= 452 {
        if let Ok(values) = read_int16u_array(&data[444..452], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face7Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face8Position at offset 259
    if data.len() >= 526 {
        if let Ok(values) = read_int16u_array(&data[518..526], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face8Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face2Position at offset 37
    if data.len() >= 82 {
        if let Ok(values) = read_int16u_array(&data[74..82], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face2Position".to_string(), TagValue::String(value_str)));
        }
    }

    // Face3Position at offset 74
    if data.len() >= 156 {
        if let Ok(values) = read_int16u_array(&data[148..156], byte_order, 4) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Face3Position".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_sony_camerasettings(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    tracing::debug!(
        "process_sony_camerasettings called with {} bytes",
        data.len()
    );
    use crate::generated::Sony_pm::camerasettings_binary_data::{
        SonyCameraSettingsTable, CAMERASETTINGS_TAGS,
    };

    let table = SonyCameraSettingsTable::new();
    let mut tags = Vec::new();

    let entry_size = 2; // Default to 2 bytes (int16u format)

    tracing::debug!(
        "CamerasettingsBinaryData: first_entry={}, {} tag definitions",
        table.first_entry,
        CAMERASETTINGS_TAGS.len()
    );

    for (&offset, &tag_name) in CAMERASETTINGS_TAGS.iter() {
        let byte_offset = ((offset as i32 - table.first_entry) * entry_size) as usize;
        if byte_offset + entry_size as usize <= data.len() {
            let tag_value = match entry_size {
                2 => {
                    let raw_u16 = byte_order.read_u16(data, byte_offset)?;
                    TagValue::U16(raw_u16)
                }
                4 => {
                    let raw_u32 = byte_order.read_u32(data, byte_offset)?;
                    TagValue::U32(raw_u32)
                }
                _ => continue,
            };
            tracing::debug!("Extracted tag {}: {} = {}", offset, tag_name, tag_value);
            tags.push((tag_name.to_string(), tag_value));
        } else {
            tracing::debug!(
                "Skipping tag {} ({}): offset {} exceeds data length {}",
                offset,
                tag_name,
                byte_offset,
                data.len()
            );
        }
    }

    tracing::debug!("process_sony_camerasettings extracted {} tags", tags.len());
    Ok(tags)
}

fn process_sony_camerasettings2(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    tracing::debug!(
        "process_sony_camerasettings2 called with {} bytes",
        data.len()
    );
    use crate::generated::Sony_pm::camerasettings2_binary_data::{
        SonyCameraSettings2Table, CAMERASETTINGS2_TAGS,
    };

    let table = SonyCameraSettings2Table::new();
    let mut tags = Vec::new();

    let entry_size = 2; // Default to 2 bytes (int16u format)

    tracing::debug!(
        "Camerasettings2BinaryData: first_entry={}, {} tag definitions",
        table.first_entry,
        CAMERASETTINGS2_TAGS.len()
    );

    for (&offset, &tag_name) in CAMERASETTINGS2_TAGS.iter() {
        let byte_offset = ((offset as i32 - table.first_entry) * entry_size) as usize;
        if byte_offset + entry_size as usize <= data.len() {
            let tag_value = match entry_size {
                2 => {
                    let raw_u16 = byte_order.read_u16(data, byte_offset)?;
                    TagValue::U16(raw_u16)
                }
                4 => {
                    let raw_u32 = byte_order.read_u32(data, byte_offset)?;
                    TagValue::U32(raw_u32)
                }
                _ => continue,
            };
            tracing::debug!("Extracted tag {}: {} = {}", offset, tag_name, tag_value);
            tags.push((tag_name.to_string(), tag_value));
        } else {
            tracing::debug!(
                "Skipping tag {} ({}): offset {} exceeds data length {}",
                offset,
                tag_name,
                byte_offset,
                data.len()
            );
        }
    }

    tracing::debug!("process_sony_camerasettings2 extracted {} tags", tags.len());
    Ok(tags)
}

fn process_sony_camerasettings3(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShutterSpeedSetting at offset 0

    // ApertureSetting at offset 1

    // AspectRatio at offset 10

    // LensE-mountVersion at offset 1008
    if data.len() >= 1010 {
        // TODO: Handle format int16u
    }

    // LensFirmwareVersion at offset 1011
    if data.len() >= 1013 {
        // TODO: Handle format int16u
    }

    // LensType2 at offset 1015
    if data.len() >= 1017 {
        // TODO: Handle format int16u
    }

    // ImageNumber at offset 1024
    if data.len() >= 1026 {
        // TODO: Handle format int16u
    }

    // FolderNumber at offset 1026
    if data.len() >= 1028 {
        // TODO: Handle format int16u
    }

    // Quality at offset 11

    // DynamicRangeOptimizerSetting at offset 12

    // AFButtonPressed at offset 131

    // LiveViewMetering at offset 132

    // ViewingMode2 at offset 133

    // AELock at offset 134

    // FlashStatusBuilt-in at offset 135

    // FlashStatusExternal at offset 136

    // LiveViewFocusMode at offset 139

    // ColorSpace at offset 14

    // CreativeStyleSetting at offset 15

    // LensMount at offset 153

    // ContrastSetting at offset 16
    if data.len() >= 17 {
        // TODO: Handle format int8s
    }

    // SaturationSetting at offset 17
    if data.len() >= 18 {
        // TODO: Handle format int8s
    }

    // SharpnessSetting at offset 18
    if data.len() >= 19 {
        // TODO: Handle format int8s
    }

    // ISOSetting at offset 2

    // WhiteBalanceSetting at offset 22

    // ColorTemperatureSetting at offset 23

    // ColorCompensationFilterSet at offset 24
    if data.len() >= 25 {
        // TODO: Handle format int8s
    }

    // CustomWB_RGBLevels at offset 25
    if data.len() >= 31 {
        // TODO: Handle format int16uRev
    }

    // SequenceNumber at offset 268

    // FolderNumber at offset 276
    if data.len() >= 280 {
        // TODO: Handle format int32u
    }

    // ImageNumber at offset 276.1
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // ExposureCompensationSet at offset 3

    // FlashMode at offset 32

    // FlashControl at offset 33

    // FlashExposureCompSet at offset 35

    // AFAreaMode at offset 36

    // LongExposureNoiseReduction at offset 37

    // HighISONoiseReduction at offset 38

    // SmileShutterMode at offset 39

    // DriveModeSetting at offset 4

    // RedEyeReduction at offset 40

    // HDRSetting at offset 45

    // HDRLevel at offset 46

    // ViewingMode at offset 47

    // FaceDetection at offset 48

    // SmileShutter at offset 49

    // ExposureProgram at offset 5

    // SweepPanoramaSize at offset 50

    // SweepPanoramaDirection at offset 51

    // ShotNumberSincePowerUp2 at offset 512
    if data.len() >= 516 {
        // TODO: Handle format int32u
    }

    // DriveMode at offset 52

    // MultiFrameNoiseReduction at offset 53

    // LiveViewAFSetting at offset 54

    // PanoramaSize3D at offset 56

    // FocusModeSetting at offset 6

    // AFButtonPressed at offset 643

    // LiveViewMetering at offset 644

    // ViewingMode2 at offset 645

    // AELock at offset 646

    // FlashStatusBuilt-in at offset 647

    // FlashStatusExternal at offset 648

    // LiveViewFocusMode at offset 651

    // MeteringMode at offset 7

    // SequenceNumber at offset 780

    // ImageNumber at offset 788
    if data.len() >= 790 {
        // TODO: Handle format int16u
    }

    // FolderNumber at offset 790
    if data.len() >= 792 {
        // TODO: Handle format int16u
    }

    // SonyImageSize at offset 9

    Ok(tags)
}

fn process_sony_camerasettingsunknown(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    Ok(tags)
}

fn process_sony_extrainfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // BatteryTemperature at offset 1

    // ImageStabilization2 at offset 10

    // BatteryLevel at offset 12

    // BatteryUnknown at offset 2
    if data.len() >= 12 {
        // TODO: Handle format undef
    }

    // ExtraInfoVersion at offset 26
    if data.len() >= 56 {
        // TODO: Handle format int8u
    }

    // BatteryVoltage at offset 8
    if data.len() >= 24 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_sony_extrainfo2(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ImageStabilization at offset 18

    // BatteryLevel at offset 4

    Ok(tags)
}

fn process_sony_extrainfo3(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // BatteryUnknown at offset 0
    if data.len() >= 2 {
        // TODO: Handle format int16u
    }

    // ImageStabilization at offset 17

    // BatteryTemperature at offset 2

    // CameraOrientation at offset 24

    // BatteryLevel at offset 4

    // BatteryVoltage1 at offset 6
    if data.len() >= 14 {
        // TODO: Handle format int16u
    }

    // BatteryVoltage2 at offset 8
    if data.len() >= 18 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_sony_meterinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MeterInfo1Row1 at offset 0
    if data.len() >= 108 {
        // TODO: Handle format int32u
    }

    // MeterInfo2Row3 at offset 1020
    if data.len() >= 2172 {
        // TODO: Handle format int32u
    }

    // MeterInfo1Row2 at offset 108
    if data.len() >= 324 {
        // TODO: Handle format int32u
    }

    // MeterInfo2Row4 at offset 1152
    if data.len() >= 2436 {
        // TODO: Handle format int32u
    }

    // MeterInfo2Row5 at offset 1284
    if data.len() >= 2700 {
        // TODO: Handle format int32u
    }

    // MeterInfo2Row6 at offset 1416
    if data.len() >= 2964 {
        // TODO: Handle format int32u
    }

    // MeterInfo2Row7 at offset 1548
    if data.len() >= 3228 {
        // TODO: Handle format int32u
    }

    // MeterInfo2Row8 at offset 1680
    if data.len() >= 3492 {
        // TODO: Handle format int32u
    }

    // MeterInfo2Row9 at offset 1812
    if data.len() >= 3756 {
        // TODO: Handle format int32u
    }

    // MeterInfo1Row3 at offset 216
    if data.len() >= 540 {
        // TODO: Handle format int32u
    }

    // MeterInfo1Row4 at offset 324
    if data.len() >= 756 {
        // TODO: Handle format int32u
    }

    // MeterInfo1Row5 at offset 432
    if data.len() >= 972 {
        // TODO: Handle format int32u
    }

    // MeterInfo1Row6 at offset 540
    if data.len() >= 1188 {
        // TODO: Handle format int32u
    }

    // MeterInfo1Row7 at offset 648
    if data.len() >= 1404 {
        // TODO: Handle format int32u
    }

    // MeterInfo2Row1 at offset 756
    if data.len() >= 1644 {
        // TODO: Handle format int32u
    }

    // MeterInfo2Row2 at offset 888
    if data.len() >= 1908 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_sony_moreinfo0201(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ImageCount at offset 283
    if data.len() >= 570 {
        // TODO: Handle format int32u
    }

    // ShutterCount at offset 293
    if data.len() >= 590 {
        // TODO: Handle format int32u
    }

    // ShutterCount at offset 330
    if data.len() >= 664 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_sony_meterinfo9(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MeterInfo1Row1 at offset 0
    if data.len() >= 180 {
        // TODO: Handle format undef
    }

    // MeterInfo2Row5 at offset 1070
    if data.len() >= 2360 {
        // TODO: Handle format undef
    }

    // MeterInfo2Row6 at offset 1180
    if data.len() >= 2580 {
        // TODO: Handle format undef
    }

    // MeterInfo2Row7 at offset 1290
    if data.len() >= 2800 {
        // TODO: Handle format undef
    }

    // MeterInfo2Row8 at offset 1400
    if data.len() >= 3020 {
        // TODO: Handle format undef
    }

    // MeterInfo2Row9 at offset 1510
    if data.len() >= 3240 {
        // TODO: Handle format undef
    }

    // MeterInfo1Row3 at offset 180
    if data.len() >= 540 {
        // TODO: Handle format undef
    }

    // MeterInfo1Row4 at offset 270
    if data.len() >= 720 {
        // TODO: Handle format undef
    }

    // MeterInfo1Row5 at offset 360
    if data.len() >= 900 {
        // TODO: Handle format undef
    }

    // MeterInfo1Row6 at offset 450
    if data.len() >= 1080 {
        // TODO: Handle format undef
    }

    // MeterInfo1Row7 at offset 540
    if data.len() >= 1260 {
        // TODO: Handle format undef
    }

    // MeterInfo2Row1 at offset 630
    if data.len() >= 1480 {
        // TODO: Handle format undef
    }

    // MeterInfo2Row2 at offset 740
    if data.len() >= 1700 {
        // TODO: Handle format undef
    }

    // MeterInfo2Row3 at offset 850
    if data.len() >= 1920 {
        // TODO: Handle format undef
    }

    // MeterInfo1Row2 at offset 90
    if data.len() >= 360 {
        // TODO: Handle format undef
    }

    // MeterInfo2Row4 at offset 960
    if data.len() >= 2140 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_sony_moreinfo0401(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotNumberSincePowerUp at offset 1102
    if data.len() >= 2208 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_sony_panorama(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // PanoramaDirection at offset 3

    Ok(tags)
}

fn process_sony_tag2010a(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // MeterInfo at offset 1200
    if data.len() >= 3144 {
        // TODO: Handle format int32u
    }

    // ReleaseMode3 at offset 4392

    // ReleaseMode2 at offset 4396

    // SelfTimer at offset 4404

    // FlashMode at offset 4408

    // StopsAboveBaseISO at offset 4414
    if data.len() >= 4416 {
        // TODO: Handle format int16u
    }

    // BrightnessValue at offset 4416
    if data.len() >= 4418 {
        // TODO: Handle format int16u
    }

    // DynamicRangeOptimizer at offset 4420

    // HDRSetting at offset 4424

    // ExposureCompensation at offset 4428
    if data.len() >= 4430 {
        if let Ok(value) = read_int16s(&data[4428..4430], byte_order) {
            tags.push(("ExposureCompensation".to_string(), TagValue::I16(value)));
        }
    }

    // PictureProfile at offset 4446

    // PictureProfile at offset 4447

    // PictureEffect2 at offset 4451

    // Quality2 at offset 4464

    // MeteringMode at offset 4468

    // ExposureProgram at offset 4469

    // WB_RGBLevels at offset 4476
    if data.len() >= 4482 {
        if let Ok(values) = read_int16u_array(&data[4476..4482], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    Ok(tags)
}

fn process_sony_tag2010b(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SequenceImageNumber at offset 0
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // MeterInfo at offset 1204
    if data.len() >= 3148 {
        // TODO: Handle format int32u
    }

    // SequenceFileNumber at offset 4
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // SonyDateTime at offset 438
    if data.len() >= 452 {
        // TODO: Handle format undef
    }

    // ReleaseMode3 at offset 4392

    // ReleaseMode2 at offset 4396

    // SelfTimer at offset 4404

    // FlashMode at offset 4408

    // StopsAboveBaseISO at offset 4414
    if data.len() >= 4416 {
        // TODO: Handle format int16u
    }

    // BrightnessValue at offset 4416
    if data.len() >= 4418 {
        // TODO: Handle format int16u
    }

    // DynamicRangeOptimizer at offset 4420

    // HDRSetting at offset 4424

    // ExposureCompensation at offset 4428
    if data.len() >= 4430 {
        if let Ok(value) = read_int16s(&data[4428..4430], byte_order) {
            tags.push(("ExposureCompensation".to_string(), TagValue::I16(value)));
        }
    }

    // PictureProfile at offset 4450

    // PictureProfile at offset 4451

    // PictureEffect2 at offset 4455

    // Quality2 at offset 4468

    // MeteringMode at offset 4472

    // ExposureProgram at offset 4473

    // WB_RGBLevels at offset 4480
    if data.len() >= 4486 {
        if let Ok(values) = read_int16u_array(&data[4480..4486], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    // SonyISO at offset 4632
    if data.len() >= 4634 {
        // TODO: Handle format int16u
    }

    // DistortionCorrParams at offset 6691
    if data.len() >= 6723 {
        if let Ok(values) = read_int16s_array(&data[6691..6723], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "DistortionCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ReleaseMode2 at offset 8
    if data.len() >= 12 {
        // TODO: Handle format int32u
    }

    // DynamicRangeOptimizer at offset 804

    Ok(tags)
}

fn process_sony_tag2010c(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SequenceImageNumber at offset 0
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // MeterInfo at offset 1168
    if data.len() >= 3112 {
        // TODO: Handle format int32u
    }

    // SequenceFileNumber at offset 4
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // ReleaseMode3 at offset 4356

    // ReleaseMode2 at offset 4360

    // SelfTimer at offset 4368

    // FlashMode at offset 4372

    // StopsAboveBaseISO at offset 4378
    if data.len() >= 4380 {
        // TODO: Handle format int16u
    }

    // BrightnessValue at offset 4380
    if data.len() >= 4382 {
        // TODO: Handle format int16u
    }

    // DynamicRangeOptimizer at offset 4384

    // HDRSetting at offset 4388

    // ExposureCompensation at offset 4392
    if data.len() >= 4394 {
        if let Ok(value) = read_int16s(&data[4392..4394], byte_order) {
            tags.push(("ExposureCompensation".to_string(), TagValue::I16(value)));
        }
    }

    // PictureProfile at offset 4414

    // PictureProfile at offset 4415

    // PictureEffect2 at offset 4419

    // Quality2 at offset 4432

    // MeteringMode at offset 4436

    // ExposureProgram at offset 4437

    // WB_RGBLevels at offset 4444
    if data.len() >= 4450 {
        if let Ok(values) = read_int16u_array(&data[4444..4450], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    // SonyISO at offset 4596
    if data.len() >= 4598 {
        // TODO: Handle format int16u
    }

    // DigitalZoomRatio at offset 512

    // SonyDateTime at offset 528
    if data.len() >= 542 {
        // TODO: Handle format undef
    }

    // DynamicRangeOptimizer at offset 768

    // ReleaseMode2 at offset 8
    if data.len() >= 12 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_sony_tag2010d(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SequenceImageNumber at offset 0
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // MeterInfo at offset 1292
    if data.len() >= 3236 {
        // TODO: Handle format int32u
    }

    // SequenceFileNumber at offset 4
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // ReleaseMode3 at offset 4480

    // ReleaseMode2 at offset 4484

    // SelfTimer at offset 4492

    // FlashMode at offset 4496

    // StopsAboveBaseISO at offset 4502
    if data.len() >= 4504 {
        // TODO: Handle format int16u
    }

    // BrightnessValue at offset 4504
    if data.len() >= 4506 {
        // TODO: Handle format int16u
    }

    // DynamicRangeOptimizer at offset 4508

    // HDRSetting at offset 4512

    // PictureProfile at offset 4538

    // PictureProfile at offset 4539

    // PictureEffect2 at offset 4543

    // MeteringMode at offset 4560

    // ExposureProgram at offset 4561

    // WB_RGBLevels at offset 4568
    if data.len() >= 4574 {
        if let Ok(values) = read_int16u_array(&data[4568..4574], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    // SonyISO at offset 4720
    if data.len() >= 4722 {
        // TODO: Handle format int16u
    }

    // SonyDateTime at offset 510
    if data.len() >= 524 {
        // TODO: Handle format undef
    }

    // ReleaseMode2 at offset 8
    if data.len() >= 12 {
        // TODO: Handle format int32u
    }

    // DynamicRangeOptimizer at offset 892

    Ok(tags)
}

fn process_sony_tag2010e(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SequenceImageNumber at offset 0
    if data.len() >= 4 {
        // TODO: Handle format int32u
    }

    // MeterInfo at offset 1208
    if data.len() >= 3152 {
        // TODO: Handle format int32u
    }

    // SequenceFileNumber at offset 4
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // ReleaseMode3 at offset 4444

    // ReleaseMode2 at offset 4448

    // SelfTimer at offset 4456

    // FlashMode at offset 4460

    // StopsAboveBaseISO at offset 4466
    if data.len() >= 4468 {
        // TODO: Handle format int16u
    }

    // BrightnessValue at offset 4468
    if data.len() >= 4470 {
        // TODO: Handle format int16u
    }

    // DynamicRangeOptimizer at offset 4472

    // HDRSetting at offset 4476

    // ExposureCompensation at offset 4480
    if data.len() >= 4482 {
        if let Ok(value) = read_int16s(&data[4480..4482], byte_order) {
            tags.push(("ExposureCompensation".to_string(), TagValue::I16(value)));
        }
    }

    // PictureProfile at offset 4502

    // PictureProfile at offset 4503

    // PictureEffect2 at offset 4507

    // Quality2 at offset 4520

    // MeteringMode at offset 4524

    // ExposureProgram at offset 4525

    // WB_RGBLevels at offset 4532
    if data.len() >= 4538 {
        if let Ok(values) = read_int16u_array(&data[4532..4538], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    // SonyISO at offset 4692
    if data.len() >= 4694 {
        // TODO: Handle format int16u
    }

    // SonyISO at offset 4696
    if data.len() >= 4698 {
        // TODO: Handle format int16u
    }

    // FocalLength at offset 4728
    if data.len() >= 4730 {
        // TODO: Handle format int16u
    }

    // MinFocalLength at offset 4730
    if data.len() >= 4732 {
        // TODO: Handle format int16u
    }

    // MaxFocalLength at offset 4732
    if data.len() >= 4734 {
        // TODO: Handle format int16u
    }

    // SonyISO at offset 4736
    if data.len() >= 4738 {
        // TODO: Handle format int16u
    }

    // DigitalZoomRatio at offset 540

    // SonyDateTime at offset 556
    if data.len() >= 570 {
        // TODO: Handle format undef
    }

    // DistortionCorrParams at offset 6256
    if data.len() >= 6288 {
        if let Ok(values) = read_int16s_array(&data[6256..6288], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "DistortionCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // LensFormat at offset 6289

    // LensMount at offset 6290

    // LensType2 at offset 6291
    if data.len() >= 6293 {
        // TODO: Handle format int16u
    }

    // LensType at offset 6294
    if data.len() >= 6296 {
        // TODO: Handle format int16u
    }

    // DistortionCorrParamsPresent at offset 6296

    // DistortionCorrParamsNumber at offset 6297

    // AspectRatio at offset 6444

    // AspectRatio at offset 6792

    // ReleaseMode2 at offset 8
    if data.len() >= 12 {
        // TODO: Handle format int32u
    }

    // DynamicRangeOptimizer at offset 808

    Ok(tags)
}

fn process_sony_tag2010f(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ReleaseMode2 at offset 4
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // ReleaseMode3 at offset 4116

    // ReleaseMode2 at offset 4120

    // SelfTimer at offset 4128

    // FlashMode at offset 4132

    // StopsAboveBaseISO at offset 4138
    if data.len() >= 4140 {
        // TODO: Handle format int16u
    }

    // BrightnessValue at offset 4140
    if data.len() >= 4142 {
        // TODO: Handle format int16u
    }

    // DynamicRangeOptimizer at offset 4144

    // HDRSetting at offset 4148

    // ExposureCompensation at offset 4152
    if data.len() >= 4154 {
        if let Ok(value) = read_int16s(&data[4152..4154], byte_order) {
            tags.push(("ExposureCompensation".to_string(), TagValue::I16(value)));
        }
    }

    // PictureProfile at offset 4174

    // PictureProfile at offset 4175

    // PictureEffect2 at offset 4179

    // Quality2 at offset 4192

    // MeteringMode at offset 4196

    // ExposureProgram at offset 4197

    // WB_RGBLevels at offset 4204
    if data.len() >= 4210 {
        if let Ok(values) = read_int16u_array(&data[4204..4210], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    // FocalLength at offset 4404
    if data.len() >= 4406 {
        // TODO: Handle format int16u
    }

    // MinFocalLength at offset 4406
    if data.len() >= 4408 {
        // TODO: Handle format int16u
    }

    // MaxFocalLength at offset 4408
    if data.len() >= 4410 {
        // TODO: Handle format int16u
    }

    // SonyISO at offset 4412
    if data.len() >= 4414 {
        // TODO: Handle format int16u
    }

    // MeterInfo at offset 480
    if data.len() >= 2424 {
        // TODO: Handle format int32u
    }

    // AspectRatio at offset 6444

    // DynamicRangeOptimizer at offset 80

    Ok(tags)
}

fn process_sony_tag2010g(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ReleaseMode2 at offset 4
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // ReleaseMode3 at offset 524

    // ReleaseMode2 at offset 528

    // SelfTimer at offset 536

    // FlashMode at offset 540

    // StopsAboveBaseISO at offset 546
    if data.len() >= 548 {
        // TODO: Handle format int16u
    }

    // BrightnessValue at offset 548
    if data.len() >= 550 {
        // TODO: Handle format int16u
    }

    // DynamicRangeOptimizer at offset 552

    // HDRSetting at offset 556

    // ExposureCompensation at offset 560
    if data.len() >= 562 {
        if let Ok(value) = read_int16s(&data[560..562], byte_order) {
            tags.push(("ExposureCompensation".to_string(), TagValue::I16(value)));
        }
    }

    // PictureProfile at offset 582

    // PictureProfile at offset 583

    // PictureEffect2 at offset 587

    // Quality2 at offset 600

    // MeteringMode at offset 604

    // ExposureProgram at offset 605

    // WB_RGBLevels at offset 612
    if data.len() >= 618 {
        if let Ok(values) = read_int16u_array(&data[612..618], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    // DistortionCorrParams at offset 6300
    if data.len() >= 6332 {
        if let Ok(values) = read_int16s_array(&data[6300..6332], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "DistortionCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // LensFormat at offset 6333

    // LensMount at offset 6334

    // LensType2 at offset 6335
    if data.len() >= 6337 {
        // TODO: Handle format int16u
    }

    // LensType at offset 6338
    if data.len() >= 6340 {
        // TODO: Handle format int16u
    }

    // DistortionCorrParamsPresent at offset 6340

    // DistortionCorrParamsNumber at offset 6341

    // AspectRatio at offset 6488

    // DynamicRangeOptimizer at offset 80

    // FocalLength at offset 812
    if data.len() >= 814 {
        // TODO: Handle format int16u
    }

    // MinFocalLength at offset 814
    if data.len() >= 816 {
        // TODO: Handle format int16u
    }

    // MaxFocalLength at offset 816
    if data.len() >= 818 {
        // TODO: Handle format int16u
    }

    // SonyISO at offset 836
    if data.len() >= 838 {
        // TODO: Handle format int16u
    }

    // MeterInfo at offset 904
    if data.len() >= 2848 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_sony_tag2010h(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ReleaseMode2 at offset 4
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // ReleaseMode3 at offset 524

    // ReleaseMode2 at offset 528

    // SelfTimer at offset 536

    // FlashMode at offset 540

    // StopsAboveBaseISO at offset 546
    if data.len() >= 548 {
        // TODO: Handle format int16u
    }

    // BrightnessValue at offset 548
    if data.len() >= 550 {
        // TODO: Handle format int16u
    }

    // DynamicRangeOptimizer at offset 552

    // HDRSetting at offset 556

    // ExposureCompensation at offset 560
    if data.len() >= 562 {
        if let Ok(value) = read_int16s(&data[560..562], byte_order) {
            tags.push(("ExposureCompensation".to_string(), TagValue::I16(value)));
        }
    }

    // PictureProfile at offset 582

    // PictureProfile at offset 583

    // PictureEffect2 at offset 587

    // Quality2 at offset 600

    // MeteringMode at offset 604

    // ExposureProgram at offset 605

    // WB_RGBLevels at offset 612
    if data.len() >= 618 {
        if let Ok(values) = read_int16u_array(&data[612..618], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    // DistortionCorrParams at offset 6348
    if data.len() >= 6380 {
        if let Ok(values) = read_int16s_array(&data[6348..6380], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "DistortionCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // LensFormat at offset 6381

    // LensMount at offset 6382

    // LensType2 at offset 6383
    if data.len() >= 6385 {
        // TODO: Handle format int16u
    }

    // LensType at offset 6386
    if data.len() >= 6388 {
        // TODO: Handle format int16u
    }

    // DistortionCorrParamsPresent at offset 6388

    // DistortionCorrParamsNumber at offset 6389

    // AspectRatio at offset 6444

    // DynamicRangeOptimizer at offset 80

    // FocalLength at offset 812
    if data.len() >= 814 {
        // TODO: Handle format int16u
    }

    // MinFocalLength at offset 814
    if data.len() >= 816 {
        // TODO: Handle format int16u
    }

    // MaxFocalLength at offset 816
    if data.len() >= 818 {
        // TODO: Handle format int16u
    }

    // SonyISO at offset 838
    if data.len() >= 840 {
        // TODO: Handle format int16u
    }

    // MeterInfo at offset 904
    if data.len() >= 2848 {
        // TODO: Handle format int32u
    }

    // MeterInfo at offset 920
    if data.len() >= 2864 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_sony_tag2010i(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ReleaseMode2 at offset 4
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    // ReleaseMode3 at offset 516

    // ReleaseMode2 at offset 520

    // SelfTimer at offset 528

    // FlashMode at offset 529

    // StopsAboveBaseISO at offset 535
    if data.len() >= 537 {
        // TODO: Handle format int16u
    }

    // BrightnessValue at offset 537
    if data.len() >= 539 {
        // TODO: Handle format int16u
    }

    // DynamicRangeOptimizer at offset 539

    // HDRSetting at offset 543

    // ExposureCompensation at offset 547
    if data.len() >= 549 {
        if let Ok(value) = read_int16s(&data[547..549], byte_order) {
            tags.push(("ExposureCompensation".to_string(), TagValue::I16(value)));
        }
    }

    // PictureProfile at offset 567

    // PictureProfile at offset 568

    // PictureEffect2 at offset 572

    // Quality2 at offset 583

    // MeteringMode at offset 587

    // ExposureProgram at offset 588

    // WB_RGBLevels at offset 594
    if data.len() >= 600 {
        if let Ok(values) = read_int16u_array(&data[594..600], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("WB_RGBLevels".to_string(), TagValue::String(value_str)));
        }
    }

    // DistortionCorrParams at offset 6096
    if data.len() >= 6128 {
        if let Ok(values) = read_int16s_array(&data[6096..6128], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "DistortionCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // LensFormat at offset 6129

    // LensMount at offset 6130

    // LensType2 at offset 6131
    if data.len() >= 6133 {
        // TODO: Handle format int16u
    }

    // LensType at offset 6134
    if data.len() >= 6136 {
        // TODO: Handle format int16u
    }

    // DistortionCorrParamsPresent at offset 6136

    // DistortionCorrParamsNumber at offset 6137

    // AspectRatio at offset 6284

    // FocalLength at offset 778
    if data.len() >= 780 {
        // TODO: Handle format int16u
    }

    // DynamicRangeOptimizer at offset 78

    // MinFocalLength at offset 780
    if data.len() >= 782 {
        // TODO: Handle format int16u
    }

    // MaxFocalLength at offset 782
    if data.len() >= 784 {
        // TODO: Handle format int16u
    }

    // SonyISO at offset 800
    if data.len() >= 802 {
        // TODO: Handle format int16u
    }

    // MeterInfo at offset 877
    if data.len() >= 4117 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_sony_tag202a(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FocalPlaneAFPointsUsed at offset 1
    if data.len() >= 2 {
        // TODO: Handle format int8u
    }

    // FocalPlaneAFPointLocation2 at offset 10
    if data.len() >= 14 {
        if let Ok(values) = read_int16u_array(&data[10..14], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation2".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation3 at offset 14
    if data.len() >= 18 {
        if let Ok(values) = read_int16u_array(&data[14..18], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation3".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation4 at offset 18
    if data.len() >= 22 {
        if let Ok(values) = read_int16u_array(&data[18..22], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation4".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointArea at offset 2
    if data.len() >= 6 {
        if let Ok(values) = read_int16u_array(&data[2..6], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointArea".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation5 at offset 22
    if data.len() >= 26 {
        if let Ok(values) = read_int16u_array(&data[22..26], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation5".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation6 at offset 26
    if data.len() >= 30 {
        if let Ok(values) = read_int16u_array(&data[26..30], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation6".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation7 at offset 30
    if data.len() >= 34 {
        if let Ok(values) = read_int16u_array(&data[30..34], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation7".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation8 at offset 34
    if data.len() >= 38 {
        if let Ok(values) = read_int16u_array(&data[34..38], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation8".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation9 at offset 38
    if data.len() >= 42 {
        if let Ok(values) = read_int16u_array(&data[38..42], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation9".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation10 at offset 42
    if data.len() >= 46 {
        if let Ok(values) = read_int16u_array(&data[42..46], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation10".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation11 at offset 46
    if data.len() >= 50 {
        if let Ok(values) = read_int16u_array(&data[46..50], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation11".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation12 at offset 50
    if data.len() >= 54 {
        if let Ok(values) = read_int16u_array(&data[50..54], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation12".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation13 at offset 54
    if data.len() >= 58 {
        if let Ok(values) = read_int16u_array(&data[54..58], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation13".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation14 at offset 58
    if data.len() >= 62 {
        if let Ok(values) = read_int16u_array(&data[58..62], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation14".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation1 at offset 6
    if data.len() >= 10 {
        if let Ok(values) = read_int16u_array(&data[6..10], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation1".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // FocalPlaneAFPointLocation15 at offset 62
    if data.len() >= 66 {
        if let Ok(values) = read_int16u_array(&data[62..66], byte_order, 2) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "FocalPlaneAFPointLocation15".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_sony_hiddeninfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // HiddenDataOffset at offset 0

    // HiddenDataLength at offset 1

    Ok(tags)
}

fn process_sony_shotinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    tracing::debug!("process_sony_shotinfo called with {} bytes", data.len());
    use crate::generated::Sony_pm::shotinfo_binary_data::{SonyShotInfoTable, SHOTINFO_TAGS};

    let table = SonyShotInfoTable::new();
    let mut tags = Vec::new();

    let entry_size = 2; // Default to 2 bytes (int16u format)

    tracing::debug!(
        "ShotinfoBinaryData: first_entry={}, {} tag definitions",
        table.first_entry,
        SHOTINFO_TAGS.len()
    );

    for (&offset, &tag_name) in SHOTINFO_TAGS.iter() {
        let byte_offset = ((offset as i32 - table.first_entry) * entry_size) as usize;
        if byte_offset + entry_size as usize <= data.len() {
            let tag_value = match entry_size {
                2 => {
                    let raw_u16 = byte_order.read_u16(data, byte_offset)?;
                    TagValue::U16(raw_u16)
                }
                4 => {
                    let raw_u32 = byte_order.read_u32(data, byte_offset)?;
                    TagValue::U32(raw_u32)
                }
                _ => continue,
            };
            tracing::debug!("Extracted tag {}: {} = {}", offset, tag_name, tag_value);
            tags.push((tag_name.to_string(), tag_value));
        } else {
            tracing::debug!(
                "Skipping tag {} ({}): offset {} exceeds data length {}",
                offset,
                tag_name,
                byte_offset,
                data.len()
            );
        }
    }

    tracing::debug!("process_sony_shotinfo extracted {} tags", tags.len());
    Ok(tags)
}

fn process_sony_tag900b(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // FaceDetection at offset 189

    // FacesDetected at offset 2

    Ok(tags)
}

fn process_sony_tag9050a(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SonyMaxAperture at offset 0

    // SonyMinAperture at offset 1

    // ReleaseMode2 at offset 103

    // InternalSerialNumber at offset 124
    if data.len() >= 128 {
        // TODO: Handle format int8u
    }

    // InternalSerialNumber at offset 240
    if data.len() >= 245 {
        // TODO: Handle format int8u
    }

    // LensMount at offset 261

    // LensFormat at offset 262

    // LensType2 at offset 263
    if data.len() >= 265 {
        // TODO: Handle format int16u
    }

    // LensType at offset 265
    if data.len() >= 267 {
        // TODO: Handle format int16u
    }

    // DistortionCorrParamsPresent at offset 267

    // APS-CSizeCapture at offset 276

    // LensSpecFeatures at offset 277
    if data.len() >= 281 {
        // TODO: Handle format undef
    }

    // LensSpecFeatures at offset 278
    if data.len() >= 282 {
        // TODO: Handle format undef
    }

    // Shutter at offset 32
    if data.len() >= 38 {
        if let Ok(values) = read_int16u_array(&data[32..38], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Shutter".to_string(), TagValue::String(value_str)));
        }
    }

    // ShutterCount3 at offset 416
    if data.len() >= 420 {
        // TODO: Handle format int32u
    }

    // ShutterCount3 at offset 426
    if data.len() >= 430 {
        // TODO: Handle format int32u
    }

    // ShutterCount3 at offset 445
    if data.len() >= 449 {
        // TODO: Handle format int32u
    }

    // FlashStatus at offset 49

    // ShutterCount at offset 50
    if data.len() >= 54 {
        // TODO: Handle format int32u
    }

    // SonyExposureTime at offset 58
    if data.len() >= 60 {
        // TODO: Handle format int16u
    }

    // SonyFNumber at offset 60
    if data.len() >= 62 {
        // TODO: Handle format int16u
    }

    // ReleaseMode2 at offset 63

    // ShutterCount2 at offset 76
    if data.len() >= 80 {
        // TODO: Handle format int32u
    }

    // SonyDateTime2 at offset 81
    if data.len() >= 93 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_sony_tag9050b(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SonyMaxAperture at offset 0

    // SonyMinAperture at offset 1

    // ReleaseMode2 at offset 107

    // ReleaseMode2 at offset 109

    // ReleaseMode2 at offset 115

    // InternalSerialNumber at offset 136
    if data.len() >= 142 {
        // TODO: Handle format int8u
    }

    // LensMount at offset 261

    // LensFormat at offset 262

    // LensType2 at offset 263
    if data.len() >= 265 {
        // TODO: Handle format int16u
    }

    // LensType at offset 265
    if data.len() >= 267 {
        // TODO: Handle format int16u
    }

    // DistortionCorrParamsPresent at offset 267

    // APS-CSizeCapture at offset 276

    // LensSpecFeatures at offset 278
    if data.len() >= 282 {
        // TODO: Handle format undef
    }

    // Shutter at offset 38
    if data.len() >= 44 {
        if let Ok(values) = read_int16u_array(&data[38..44], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Shutter".to_string(), TagValue::String(value_str)));
        }
    }

    // ShutterCount3 at offset 415
    if data.len() >= 419 {
        // TODO: Handle format int32u
    }

    // ShutterCount3 at offset 459
    if data.len() >= 463 {
        // TODO: Handle format int32u
    }

    // ShutterCount3 at offset 461
    if data.len() >= 465 {
        // TODO: Handle format int32u
    }

    // APS-CSizeCapture at offset 491

    // LensSpecFeatures at offset 493
    if data.len() >= 497 {
        // TODO: Handle format undef
    }

    // APS-CSizeCapture at offset 494

    // LensSpecFeatures at offset 496
    if data.len() >= 500 {
        // TODO: Handle format undef
    }

    // APS-CSizeCapture at offset 538

    // LensSpecFeatures at offset 542
    if data.len() >= 546 {
        // TODO: Handle format undef
    }

    // FlashStatus at offset 57

    // ShutterCount at offset 58
    if data.len() >= 62 {
        // TODO: Handle format int32u
    }

    // SonyExposureTime at offset 70
    if data.len() >= 72 {
        // TODO: Handle format int16u
    }

    // SonyFNumber at offset 72
    if data.len() >= 74 {
        // TODO: Handle format int16u
    }

    // ReleaseMode2 at offset 75

    // ShutterCount2 at offset 80
    if data.len() >= 84 {
        // TODO: Handle format int32u
    }

    // ShutterCount2 at offset 82
    if data.len() >= 86 {
        // TODO: Handle format int32u
    }

    // ShutterCount2 at offset 88
    if data.len() >= 92 {
        // TODO: Handle format int32u
    }

    // SonyTimeMinSec at offset 97
    if data.len() >= 101 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_sony_tag9050c(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SonyExposureTime at offset 102
    if data.len() >= 104 {
        // TODO: Handle format int16u
    }

    // SonyFNumber at offset 104
    if data.len() >= 106 {
        // TODO: Handle format int16u
    }

    // ReleaseMode2 at offset 107

    // InternalSerialNumber at offset 136
    if data.len() >= 142 {
        // TODO: Handle format int8u
    }

    // InternalSerialNumber at offset 138
    if data.len() >= 144 {
        // TODO: Handle format int8u
    }

    // Shutter at offset 38
    if data.len() >= 44 {
        if let Ok(values) = read_int16u_array(&data[38..44], byte_order, 3) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("Shutter".to_string(), TagValue::String(value_str)));
        }
    }

    // FlashStatus at offset 57

    // ShutterCount at offset 58
    if data.len() >= 62 {
        // TODO: Handle format int32u
    }

    // SonyExposureTime at offset 70
    if data.len() >= 72 {
        // TODO: Handle format int16u
    }

    // SonyFNumber at offset 72
    if data.len() >= 74 {
        // TODO: Handle format int16u
    }

    // ReleaseMode2 at offset 75

    // ShutterCount2 at offset 80
    if data.len() >= 84 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_sony_tag9050d(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShutterCount at offset 10
    if data.len() >= 14 {
        // TODO: Handle format int32u
    }

    // SonyExposureTime at offset 26
    if data.len() >= 28 {
        // TODO: Handle format int16u
    }

    // SonyFNumber at offset 28
    if data.len() >= 30 {
        // TODO: Handle format int16u
    }

    // ReleaseMode2 at offset 31

    // InternalSerialNumber at offset 56
    if data.len() >= 62 {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_sony_tag9400a(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SequenceFileNumber at offset 12
    if data.len() >= 16 {
        // TODO: Handle format int32u
    }

    // ReleaseMode2 at offset 16

    // DigitalZoom at offset 18

    // ShotNumberSincePowerUp at offset 26
    if data.len() >= 30 {
        // TODO: Handle format int32u
    }

    // SequenceLength at offset 34

    // CameraOrientation at offset 40

    // Quality2 at offset 41

    // SonyImageHeight at offset 68
    if data.len() >= 70 {
        // TODO: Handle format int16u
    }

    // SequenceImageNumber at offset 8
    if data.len() >= 12 {
        // TODO: Handle format int32u
    }

    // ModelReleaseYear at offset 82
    if data.len() >= 83 {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_sony_tag9400b(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // SequenceFileNumber at offset 12
    if data.len() >= 16 {
        // TODO: Handle format int32u
    }

    // ReleaseMode2 at offset 16

    // DigitalZoom at offset 18

    // ShotNumberSincePowerUp at offset 22
    if data.len() >= 26 {
        // TODO: Handle format int32u
    }

    // SequenceLength at offset 30

    // CameraOrientation at offset 36

    // Quality2 at offset 37

    // SonyImageHeight at offset 63
    if data.len() >= 65 {
        // TODO: Handle format int16u
    }

    // ModelReleaseYear at offset 70
    if data.len() >= 71 {
        // TODO: Handle format int8u
    }

    // SequenceImageNumber at offset 8
    if data.len() >= 12 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_sony_tag9400c(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ShotNumberSincePowerUp at offset 10
    if data.len() >= 14 {
        // TODO: Handle format int32u
    }

    // SequenceImageNumber at offset 18
    if data.len() >= 22 {
        // TODO: Handle format int32u
    }

    // SequenceLength at offset 22

    // SequenceFileNumber at offset 26
    if data.len() >= 30 {
        // TODO: Handle format int32u
    }

    // SequenceLength at offset 30

    // ShutterType at offset 307

    // ShutterType at offset 313

    // ShutterType at offset 319

    // CameraOrientation at offset 41

    // ModelReleaseYear at offset 83
    if data.len() >= 84 {
        // TODO: Handle format int8u
    }

    // ReleaseMode2 at offset 9

    Ok(tags)
}

fn process_sony_tag9401(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Ver9401 at offset 0

    // ISOInfo at offset 1012
    if data.len() >= 1017 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1102
    if data.len() >= 1107 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1176
    if data.len() >= 1181 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1181
    if data.len() >= 1186 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1182
    if data.len() >= 1187 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1185
    if data.len() >= 1190 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1186
    if data.len() >= 1191 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1210
    if data.len() >= 1215 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1437
    if data.len() >= 1442 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1588
    if data.len() >= 1593 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1590
    if data.len() >= 1595 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1612
    if data.len() >= 1617 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1619
    if data.len() >= 1624 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1656
    if data.len() >= 1661 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1720
    if data.len() >= 1725 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1758
    if data.len() >= 1763 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 1767
    if data.len() >= 1772 {
        // TODO: Handle format int8u
    }

    // ISOInfo at offset 994
    if data.len() >= 999 {
        // TODO: Handle format int8u
    }

    Ok(tags)
}

fn process_sony_tag9402(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TempTest1 at offset 2

    // FocusMode at offset 22

    // AFAreaMode at offset 23

    // AmbientTemperature at offset 4
    if data.len() >= 5 {
        // TODO: Handle format int8s
    }

    // FocusPosition2 at offset 45

    Ok(tags)
}

fn process_sony_tag9403(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TempTest2 at offset 4

    // CameraTemperature at offset 5
    if data.len() >= 6 {
        // TODO: Handle format int8s
    }

    Ok(tags)
}

fn process_sony_tag9404a(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ExposureProgram at offset 11

    // IntelligentAuto at offset 13

    // LensZoomPosition at offset 25
    if data.len() >= 27 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_sony_tag9404b(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ExposureProgram at offset 12

    // IntelligentAuto at offset 14

    // LensZoomPosition at offset 30
    if data.len() >= 32 {
        // TODO: Handle format int16u
    }

    // FocusPosition2 at offset 32

    Ok(tags)
}

fn process_sony_tag9404c(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // ExposureProgram at offset 11

    // IntelligentAuto at offset 13

    Ok(tags)
}

fn process_sony_tag9405a(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // DistortionCorrParamsPresent at offset 1536

    // DistortionCorrection at offset 1537

    // LensFormat at offset 1539

    // LensMount at offset 1540

    // LensType2 at offset 1541
    if data.len() >= 1543 {
        // TODO: Handle format int16u
    }

    // LensType at offset 1544
    if data.len() >= 1546 {
        // TODO: Handle format int16u
    }

    // VignettingCorrParams at offset 1610
    if data.len() >= 1642 {
        if let Ok(values) = read_int16s_array(&data[1610..1642], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "VignettingCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ChromaticAberrationCorrParams at offset 1642
    if data.len() >= 1706 {
        if let Ok(values) = read_int16s_array(&data[1642..1706], byte_order, 32) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "ChromaticAberrationCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // DistortionCorrParams at offset 1738
    if data.len() >= 1770 {
        if let Ok(values) = read_int16s_array(&data[1738..1770], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "DistortionCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

fn process_sony_tag9405b(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // StopsAboveBaseISO at offset 10
    if data.len() >= 12 {
        // TODO: Handle format int16u
    }

    // DistortionCorrParams at offset 100
    if data.len() >= 132 {
        if let Ok(values) = read_int16s_array(&data[100..132], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "DistortionCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // SonyExposureTime2 at offset 14
    if data.len() >= 16 {
        // TODO: Handle format int16u
    }

    // ExposureTime at offset 16
    if data.len() >= 18 {
        // TODO: Handle format rational32u
    }

    // SonyFNumber at offset 20
    if data.len() >= 22 {
        // TODO: Handle format int16u
    }

    // SonyMaxApertureValue at offset 22
    if data.len() >= 24 {
        // TODO: Handle format int16u
    }

    // SequenceImageNumber at offset 36
    if data.len() >= 40 {
        // TODO: Handle format int32u
    }

    // SonyISO at offset 4
    if data.len() >= 6 {
        // TODO: Handle format int16u
    }

    // ReleaseMode2 at offset 52

    // BaseISO at offset 6
    if data.len() >= 8 {
        // TODO: Handle format int16u
    }

    // SonyImageWidthMax at offset 62
    if data.len() >= 64 {
        // TODO: Handle format int16u
    }

    // SonyImageHeightMax at offset 64
    if data.len() >= 66 {
        // TODO: Handle format int16u
    }

    // HighISONoiseReduction at offset 66

    // LongExposureNoiseReduction at offset 68

    // PictureEffect2 at offset 70

    // ExposureProgram at offset 72

    // CreativeStyle at offset 74

    // Sharpness at offset 82
    if data.len() >= 83 {
        // TODO: Handle format int8s
    }

    // LensZoomPosition at offset 834
    if data.len() >= 836 {
        // TODO: Handle format int16u
    }

    // VignettingCorrParams at offset 842
    if data.len() >= 874 {
        if let Ok(values) = read_int16s_array(&data[842..874], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "VignettingCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // LensZoomPosition at offset 846
    if data.len() >= 848 {
        // TODO: Handle format int16u
    }

    // VignettingCorrParams at offset 848
    if data.len() >= 880 {
        if let Ok(values) = read_int16s_array(&data[848..880], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "VignettingCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // LensZoomPosition at offset 858
    if data.len() >= 860 {
        // TODO: Handle format int16u
    }

    // VignettingCorrParams at offset 860
    if data.len() >= 892 {
        if let Ok(values) = read_int16s_array(&data[860..892], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "VignettingCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // VignettingCorrParams at offset 872
    if data.len() >= 904 {
        if let Ok(values) = read_int16s_array(&data[872..904], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "VignettingCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ChromaticAberrationCorrParams at offset 892
    if data.len() >= 956 {
        if let Ok(values) = read_int16s_array(&data[892..956], byte_order, 32) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "ChromaticAberrationCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // DistortionCorrParamsPresent at offset 90

    // ChromaticAberrationCorrParams at offset 900
    if data.len() >= 964 {
        if let Ok(values) = read_int16s_array(&data[900..964], byte_order, 32) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "ChromaticAberrationCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // DistortionCorrection at offset 91

    // ChromaticAberrationCorrParams at offset 924
    if data.len() >= 988 {
        if let Ok(values) = read_int16s_array(&data[924..988], byte_order, 32) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "ChromaticAberrationCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // LensFormat at offset 93

    // LensMount at offset 94

    // ChromaticAberrationCorrParams at offset 944
    if data.len() >= 1008 {
        if let Ok(values) = read_int16s_array(&data[944..1008], byte_order, 32) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "ChromaticAberrationCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ChromaticAberrationCorrParams at offset 952
    if data.len() >= 1016 {
        if let Ok(values) = read_int16s_array(&data[952..1016], byte_order, 32) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "ChromaticAberrationCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // LensType2 at offset 96
    if data.len() >= 98 {
        // TODO: Handle format int16u
    }

    // LensType at offset 98
    if data.len() >= 100 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_sony_tag9406(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // BatteryTemperature at offset 5

    // BatteryLevelGrip1 at offset 6

    // BatteryLevel at offset 7

    // BatteryLevelGrip2 at offset 8

    Ok(tags)
}

fn process_sony_tag9406b(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Battery2 at offset 1

    // BatteryStatus1 at offset 4

    // BatteryLevel at offset 5

    // BatteryStatus2 at offset 6

    // BatteryLevel2 at offset 7

    Ok(tags)
}

fn process_sony_tag940a(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFPointsSelected at offset 4
    if data.len() >= 8 {
        // TODO: Handle format int32u
    }

    Ok(tags)
}

fn process_sony_tag940c(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // CameraE-mountVersion at offset 11
    if data.len() >= 13 {
        // TODO: Handle format int16u
    }

    // LensE-mountVersion at offset 13
    if data.len() >= 15 {
        // TODO: Handle format int16u
    }

    // LensFirmwareVersion at offset 20
    if data.len() >= 22 {
        // TODO: Handle format int16u
    }

    // LensMount2 at offset 8

    // LensType3 at offset 9
    if data.len() >= 11 {
        // TODO: Handle format int16u
    }

    Ok(tags)
}

fn process_sony_afinfo(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // AFAreaMode at offset 10

    // FocusMode at offset 11

    // AFStatus79 at offset 125
    if data.len() >= 315 {
        if let Ok(values) = read_int16s_array(&data[125..315], byte_order, 95) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push(("AFStatus79".to_string(), TagValue::String(value_str)));
        }
    }

    // AFPointsUsed at offset 16
    if data.len() >= 26 {
        // TODO: Handle format int8u
    }

    // AFType at offset 2

    // AFPointsUsed at offset 366
    if data.len() >= 370 {
        // TODO: Handle format int32u
    }

    // AFMicroAdj at offset 381
    if data.len() >= 382 {
        // TODO: Handle format int8s
    }

    // ExposureProgram at offset 382

    // AFStatusActiveSensor at offset 4
    if data.len() >= 6 {
        if let Ok(value) = read_int16s(&data[4..6], byte_order) {
            tags.push(("AFStatusActiveSensor".to_string(), TagValue::I16(value)));
        }
    }

    // FocusMode at offset 5

    // AFPoint at offset 55

    // AFPointInFocus at offset 56

    // AFPointAtShutterRelease at offset 57

    // AFAreaMode at offset 58

    // AFStatusActiveSensor at offset 59
    if data.len() >= 61 {
        if let Ok(value) = read_int16s(&data[59..61], byte_order) {
            tags.push(("AFStatusActiveSensor".to_string(), TagValue::I16(value)));
        }
    }

    // ExposureProgram at offset 67

    // AFMicroAdj at offset 80
    if data.len() >= 81 {
        // TODO: Handle format int8s
    }

    Ok(tags)
}

fn process_sony_tag940e(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // TiffMeteringImageWidth at offset 6662

    // TiffMeteringImageHeight at offset 6663

    // TiffMeteringImage at offset 6664
    if data.len() >= 11944 {
        // TODO: Handle format undef
    }

    Ok(tags)
}

fn process_sony_tag9416(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {
    let mut tags = Vec::new();
    // Tag9416_0000 at offset 0

    // SonyExposureTime2 at offset 10
    if data.len() >= 12 {
        // TODO: Handle format int16u
    }

    // PictureProfile at offset 112

    // FocalLength at offset 113
    if data.len() >= 115 {
        // TODO: Handle format int16u
    }

    // MinFocalLength at offset 115
    if data.len() >= 117 {
        // TODO: Handle format int16u
    }

    // MaxFocalLength at offset 117
    if data.len() >= 119 {
        // TODO: Handle format int16u
    }

    // ExposureTime at offset 12
    if data.len() >= 14 {
        // TODO: Handle format rational32u
    }

    // SonyFNumber2 at offset 16
    if data.len() >= 18 {
        // TODO: Handle format int16u
    }

    // SonyMaxApertureValue at offset 18
    if data.len() >= 20 {
        // TODO: Handle format int16u
    }

    // VignettingCorrParams at offset 2191
    if data.len() >= 2223 {
        if let Ok(values) = read_int16s_array(&data[2191..2223], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "VignettingCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // VignettingCorrParams at offset 2193
    if data.len() >= 2225 {
        if let Ok(values) = read_int16s_array(&data[2193..2225], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "VignettingCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // VignettingCorrParams at offset 2205
    if data.len() >= 2269 {
        if let Ok(values) = read_int16s_array(&data[2205..2269], byte_order, 32) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "VignettingCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // APS-CSizeCapture at offset 2229

    // APS-CSizeCapture at offset 2231

    // APS-CSizeCapture at offset 2277

    // ChromaticAberrationCorrParams at offset 2324
    if data.len() >= 2388 {
        if let Ok(values) = read_int16s_array(&data[2324..2388], byte_order, 32) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "ChromaticAberrationCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ChromaticAberrationCorrParams at offset 2326
    if data.len() >= 2390 {
        if let Ok(values) = read_int16s_array(&data[2326..2390], byte_order, 32) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "ChromaticAberrationCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // ChromaticAberrationCorrParams at offset 2373
    if data.len() >= 2437 {
        if let Ok(values) = read_int16s_array(&data[2373..2437], byte_order, 32) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "ChromaticAberrationCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    // SequenceImageNumber at offset 29
    if data.len() >= 33 {
        // TODO: Handle format int32u
    }

    // SonyISO at offset 4
    if data.len() >= 6 {
        // TODO: Handle format int16u
    }

    // ReleaseMode2 at offset 43

    // ExposureProgram at offset 53

    // CreativeStyle at offset 55

    // StopsAboveBaseISO at offset 6
    if data.len() >= 8 {
        // TODO: Handle format int16u
    }

    // LensMount at offset 72

    // LensFormat at offset 73

    // LensMount at offset 74

    // LensType2 at offset 75
    if data.len() >= 77 {
        // TODO: Handle format int16u
    }

    // LensType at offset 77
    if data.len() >= 79 {
        // TODO: Handle format int16u
    }

    // DistortionCorrParams at offset 79
    if data.len() >= 111 {
        if let Ok(values) = read_int16s_array(&data[79..111], byte_order, 16) {
            let value_str = values
                .iter()
                .map(|v| v.to_string())
                .collect::<Vec<_>>()
                .join(" ");
            tags.push((
                "DistortionCorrParams".to_string(),
                TagValue::String(value_str),
            ));
        }
    }

    Ok(tags)
}

pub fn process_tag_0x1_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x1_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_moresettings(data, byte_order)
}

pub fn process_tag_0x2_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x10_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x10_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    match count {
        368 => {
            debug!("Matched count 368 for variant sony_camerainfo");
            process_sony_camerainfo(data, byte_order)
        }
        5478 => {
            debug!("Matched count 5478 for variant sony_camerainfo");
            process_sony_camerainfo(data, byte_order)
        }
        5506 => {
            debug!("Matched count 5506 for variant sony_camerainfo2");
            process_sony_camerainfo2(data, byte_order)
        }
        6118 => {
            debug!("Matched count 6118 for variant sony_camerainfo2");
            process_sony_camerainfo2(data, byte_order)
        }
        15360 => {
            debug!("Matched count 15360 for variant sony_camerainfo3");
            process_sony_camerainfo3(data, byte_order)
        }
        _ => Ok(vec![]), // No matching variant
    }
}

pub fn process_tag_0x20_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x20_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    match count {
        19154 => {
            debug!("Matched count 19154 for variant sony_focusinfo");
            process_sony_focusinfo(data, byte_order)
        }
        19148 => {
            debug!("Matched count 19148 for variant sony_focusinfo");
            process_sony_focusinfo(data, byte_order)
        }
        _ => Ok(vec![]), // No matching variant
    }
}

pub fn process_tag_0x23_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x23_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x48_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x48_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x5e_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x5e_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x114_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x114_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    match count {
        280 => {
            debug!("Matched count 280 for variant sony_camerasettings");
            process_sony_camerasettings(data, byte_order)
        }
        364 => {
            debug!("Matched count 364 for variant sony_camerasettings");
            process_sony_camerasettings(data, byte_order)
        }
        332 => {
            debug!("Matched count 332 for variant sony_camerasettings2");
            process_sony_camerasettings2(data, byte_order)
        }
        1536 => {
            debug!("Matched count 1536 for variant sony_camerasettings3");
            process_sony_camerasettings3(data, byte_order)
        }
        2048 => {
            debug!("Matched count 2048 for variant sony_camerasettings3");
            process_sony_camerasettings3(data, byte_order)
        }
        _ => Ok(vec![]), // No matching variant
    }
}

pub fn process_tag_0x116_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x116_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x1e0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x1e0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_meterinfo(data, byte_order)
}

pub fn process_tag_0x201_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x201_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_moreinfo0201(data, byte_order)
}

pub fn process_tag_0x36d_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x36d_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_meterinfo9(data, byte_order)
}

pub fn process_tag_0x388_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x388_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x398_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x398_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x401_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x401_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_moreinfo0401(data, byte_order)
}

pub fn process_tag_0x490_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x490_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_meterinfo(data, byte_order)
}

pub fn process_tag_0x4b0_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4b0_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_meterinfo(data, byte_order)
}

pub fn process_tag_0x4b4_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4b4_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_meterinfo(data, byte_order)
}

pub fn process_tag_0x4b8_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x4b8_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_meterinfo(data, byte_order)
}

pub fn process_tag_0x50c_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x50c_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_meterinfo(data, byte_order)
}

pub fn process_tag_0xe00_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xe00_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Cross-module reference to Image::ExifTool::PrintIM::Main
    // TODO: Implement cross-module subdirectory support
    Ok(vec![])
}

pub fn process_tag_0x1003_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x1003_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x2010_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2010_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x202a_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x202a_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x2044_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x2044_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_hiddeninfo(data, byte_order)
}

pub fn process_tag_0x3000_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x3000_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_shotinfo(data, byte_order)
}

pub fn process_tag_0x900b_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x900b_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x9050_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9050_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x9400_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9400_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x9401_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9401_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_tag9401(data, byte_order)
}

pub fn process_tag_0x9402_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9402_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x9403_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9403_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_tag9403(data, byte_order)
}

pub fn process_tag_0x9404_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9404_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x9405_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9405_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x9406_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9406_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x940a_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x940a_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x940c_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x940c_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x940e_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x940e_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

pub fn process_tag_0x9416_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0x9416_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    // Single unconditional subdirectory
    process_sony_tag9416(data, byte_order)
}

pub fn process_tag_0xb028_subdirectory(
    data: &[u8],
    byte_order: ByteOrder,
) -> Result<Vec<(String, TagValue)>> {
    use tracing::debug;
    // TODO: Accept model and format parameters when runtime integration supports it
    let count = data.len() / 2;
    debug!(
        "process_tag_0xb028_subdirectory called with {} bytes, count={}",
        data.len(),
        count
    );

    Ok(vec![])
}

/// Apply PrintConv for a tag from this module
pub fn apply_print_conv(
    tag_id: u32,
    value: &TagValue,
    _evaluator: &mut ExpressionEvaluator,
    _errors: &mut Vec<String>,
    warnings: &mut Vec<String>,
) -> TagValue {
    match tag_id {
        1 => crate::implementations::print_conv::fnumber_print_conv(value),
        14 => crate::implementations::print_conv::focallength_print_conv(value),
        16 => crate::implementations::print_conv::focallength_print_conv(value),
        32 => crate::implementations::print_conv::fnumber_print_conv(value),
        34 => crate::implementations::print_conv::fnumber_print_conv(value),
        35 => crate::implementations::print_conv::focallength_print_conv(value),
        37 => crate::implementations::print_conv::focallength_print_conv(value),
        38 => crate::implementations::print_conv::fnumber_print_conv(value),
        41 => crate::implementations::print_conv::fnumber_print_conv(value),
        48 => crate::implementations::print_conv::fnumber_print_conv(value),
        778 => crate::implementations::print_conv::focallength_print_conv(value),
        780 => crate::implementations::print_conv::focallength_print_conv(value),
        782 => crate::implementations::print_conv::focallength_print_conv(value),
        812 => crate::implementations::print_conv::focallength_print_conv(value),
        814 => crate::implementations::print_conv::focallength_print_conv(value),
        816 => crate::implementations::print_conv::focallength_print_conv(value),
        4404 => crate::implementations::print_conv::focallength_print_conv(value),
        4406 => crate::implementations::print_conv::focallength_print_conv(value),
        4408 => crate::implementations::print_conv::focallength_print_conv(value),
        4728 => crate::implementations::print_conv::focallength_print_conv(value),
        4730 => crate::implementations::print_conv::focallength_print_conv(value),
        4732 => crate::implementations::print_conv::focallength_print_conv(value),
        _ => {
            // Fall back to shared handling
            if let Some(tag_kit) = SONY_PM_TAG_KITS.get(&tag_id) {
                crate::implementations::generic::apply_fallback_print_conv(
                    tag_id,
                    &tag_kit.name,
                    "Sony",
                    value,
                    crate::to_print_conv_ref!(&tag_kit.print_conv),
                )
            } else {
                value.clone()
            }
        }
    }
}

/// Apply ValueConv for a tag from this module
pub fn apply_value_conv(
    tag_id: u32,
    value: &TagValue,
    _errors: &mut Vec<String>,
) -> Result<TagValue> {
    match tag_id {
        0 => crate::implementations::value_conv::sony_exposure_time_value_conv(value),
        1 => crate::implementations::value_conv::sony_fnumber_value_conv(value),
        4 => crate::implementations::value_conv::canon_plus_1_value_conv(value),
        6 => crate::implementations::value_conv::multiply_100_value_conv(value),
        7 => crate::implementations::value_conv::multiply_100_value_conv(value),
        11 => crate::implementations::value_conv::multiply_100_value_conv(value),
        12 => crate::implementations::value_conv::multiply_100_value_conv(value),
        14 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        20 => crate::implementations::value_conv::sony_iso_value_conv(value),
        22 => crate::implementations::value_conv::sony_iso_value_conv(value),
        23 => crate::implementations::value_conv::multiply_100_value_conv(value),
        31 => crate::implementations::value_conv::sony_iso_value_conv(value),
        32 => crate::implementations::value_conv::sony_fnumber_value_conv(value),
        33 => crate::implementations::value_conv::sony_exposure_time_value_conv(value),
        34 => crate::implementations::value_conv::sony_fnumber_value_conv(value),
        35 => crate::implementations::value_conv::sony_exposure_time_value_conv(value),
        36 => crate::implementations::value_conv::divide_8_value_conv(value),
        37 => crate::implementations::value_conv::sony_iso_value_conv(value),
        38 => crate::implementations::value_conv::divide_8_value_conv(value),
        39 => crate::implementations::value_conv::sony_exposure_time_value_conv(value),
        40 => crate::implementations::value_conv::sony_exposure_time_value_conv(value),
        41 => crate::implementations::value_conv::sony_fnumber_value_conv(value),
        42 => crate::implementations::value_conv::divide_8_value_conv(value),
        44 => crate::implementations::value_conv::divide_8_value_conv(value),
        47 => crate::implementations::value_conv::sony_exposure_time_value_conv(value),
        48 => crate::implementations::value_conv::sony_fnumber_value_conv(value),
        109 => crate::implementations::value_conv::sony_iso_value_conv(value),
        111 => crate::implementations::value_conv::sony_iso_value_conv(value),
        778 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        780 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        782 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        812 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        814 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        816 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        4404 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        4406 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        4408 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        4728 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        4730 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        4732 => crate::implementations::value_conv::canon_div_10_value_conv(value),
        _ => {
            // Fall back to missing handler for unknown expressions
            if let Some(tag_kit) = SONY_PM_TAG_KITS.get(&tag_id) {
                if let Some(expr) = tag_kit.value_conv {
                    Ok(crate::implementations::missing::missing_value_conv(
                        tag_id,
                        &tag_kit.name,
                        "Sony",
                        expr,
                        value,
                    ))
                } else {
                    Ok(value.clone())
                }
            } else {
                Ok(value.clone())
            }
        }
    }
}

/// Check if a tag has subdirectory processing
pub fn has_subdirectory(tag_id: u32) -> bool {
    if let Some(tag_kit) = SONY_PM_TAG_KITS.get(&tag_id) {
        tag_kit.subdirectory.is_some()
    } else {
        false
    }
}

/// Process subdirectory tags and return multiple extracted tags
pub fn process_subdirectory(
    tag_id: u32,
    value: &TagValue,
    byte_order: ByteOrder,
) -> Result<HashMap<String, TagValue>> {
    use tracing::debug;
    let mut result = HashMap::new();

    debug!("process_subdirectory called for tag_id: 0x{:04x}", tag_id);

    if let Some(tag_kit) = SONY_PM_TAG_KITS.get(&tag_id) {
        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {
            debug!("Found subdirectory processor for tag_id: 0x{:04x}", tag_id);
            let bytes = match value {
                TagValue::U16Array(arr) => {
                    debug!("Converting U16Array with {} elements to bytes", arr.len());
                    // Convert U16 array to bytes based on byte order
                    let mut bytes = Vec::with_capacity(arr.len() * 2);
                    for val in arr {
                        match byte_order {
                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),
                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),
                        }
                    }
                    bytes
                }
                TagValue::U8Array(arr) => arr.clone(),
                _ => return Ok(result), // Not array data
            };

            debug!("Calling processor with {} bytes", bytes.len());
            // Process subdirectory and collect all extracted tags
            match processor(&bytes, byte_order) {
                Ok(extracted_tags) => {
                    debug!("Processor returned {} tags", extracted_tags.len());
                    for (name, value) in extracted_tags {
                        result.insert(name, value);
                    }
                }
                Err(e) => {
                    debug!("Processor error: {:?}", e);
                }
            }
        } else {
            debug!(
                "No subdirectory processor found for tag_id: 0x{:04x}",
                tag_id
            );
        }
    } else {
        debug!("Tag not found in TAG_KITS: 0x{:04x}", tag_id);
    }

    Ok(result)
}
