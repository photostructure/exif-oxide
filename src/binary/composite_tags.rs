//! Auto-generated composite binary tag definitions from ExifTool
//!
//! EXIFTOOL-SOURCE: lib/Image/ExifTool/Exif.pm (Composite tags)
//! EXIFTOOL-VERSION: 12.65
//!
//! This file is auto-generated by exiftool_sync extract binary-tags.
//! Do not edit manually.

use crate::core::types::ExifValue;
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct CompositeTagDefinition {
    pub name: &'static str,
    pub requires: &'static [(u16, &'static str)], // (tag_id, tag_name)
    pub desires: &'static [(u16, &'static str)],  // Optional tags
    pub groups: &'static [(u8, &'static str)],    // Group assignments
}

pub static BINARY_COMPOSITE_TAGS: &[CompositeTagDefinition] = &[
    CompositeTagDefinition {
        name: "ThumbnailImage",
        requires: &[(0x0201, "ThumbnailOffset"), (0x0202, "ThumbnailLength")],
        desires: &[],
        groups: &[(2, "Preview"), (0, "EXIF"), (1, "IFD1")],
    },
    CompositeTagDefinition {
        name: "PreviewImage",
        requires: &[
            (0x0111, "PreviewImageStart"),
            (0x0117, "PreviewImageLength"),
        ],
        desires: &[
            (0x0000, "PreviewImageValid"),
            (0x0000, "PreviewImageStart (1)"),
            (0x0000, "PreviewImageLength (1)"),
        ],
        groups: &[(0, "EXIF"), (1, "SubIFD"), (2, "Preview")],
    },
    CompositeTagDefinition {
        name: "JpgFromRaw",
        requires: &[(0x0111, "JpgFromRawStart"), (0x0117, "JpgFromRawLength")],
        desires: &[],
        groups: &[(1, "SubIFD"), (0, "EXIF"), (2, "Preview")],
    },
];

/// Extract binary data for composite tags like ThumbnailImage
pub fn extract_composite_binary_tag(
    tag_name: &str,
    tags: &HashMap<u16, ExifValue>,
    file_data: &[u8],
) -> Option<Vec<u8>> {
    let composite_def = BINARY_COMPOSITE_TAGS
        .iter()
        .find(|def| def.name == tag_name)?;

    // Basic offset/length extraction pattern
    if composite_def.requires.len() >= 2 {
        let offset_tag_id = composite_def.requires[0].0;
        let length_tag_id = composite_def.requires[1].0;

        if let (Some(ExifValue::U32(offset)), Some(ExifValue::U32(length))) =
            (tags.get(&offset_tag_id), tags.get(&length_tag_id))
        {
            let start = *offset as usize;
            let end = start + *length as usize;

            if end <= file_data.len() {
                return Some(file_data[start..end].to_vec());
            }
        }
    }

    None
}

/// Extract ThumbnailImage binary data
pub fn extract_thumbnail_image(
    tags: &HashMap<u16, ExifValue>,
    file_data: &[u8],
) -> Option<Vec<u8>> {
    extract_composite_binary_tag("ThumbnailImage", tags, file_data)
}

/// Extract PreviewImage binary data
pub fn extract_preview_image(tags: &HashMap<u16, ExifValue>, file_data: &[u8]) -> Option<Vec<u8>> {
    extract_composite_binary_tag("PreviewImage", tags, file_data)
}

/// Extract JpgFromRaw binary data
pub fn extract_jpgfromraw(tags: &HashMap<u16, ExifValue>, file_data: &[u8]) -> Option<Vec<u8>> {
    extract_composite_binary_tag("JpgFromRaw", tags, file_data)
}
