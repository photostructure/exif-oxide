# exif-oxide Architecture

## Overview

This document represents the eighth iteration of the exif-oxide architecture, incorporating deep understanding of ExifTool's PROCESS_PROC system, ProcessBinaryData complexity, sophisticated error handling, and WRITE_PROC infrastructure. We embrace manual porting of complex logic while using code generation only for straightforward translations.

## Core Philosophy

1. **No Novel Parsing**: ExifTool has already solved every edge case - we port, not reinvent
2. **Manual Excellence**: Complex logic is manually ported with references to ExifTool source
3. **Simple Codegen**: Generator handles only straightforward, unambiguous translations
4. **Always Working**: System produces compilable code at every stage
5. **Transparent Progress**: Clear visibility into what's implemented vs TODO

## Key Insights from ExifTool Analysis

### PROCESS_PROC Complexity

- 121+ uses of ProcessBinaryData across manufacturers
- Custom processors for encrypted data (Nikon), serial data (Canon), text formats (JVC)
- Sophisticated dispatch with table-level and SubDirectory overrides
- No code sharing between processors - each is self-contained

### ProcessBinaryData Sophistication

- Variable-length formats with offset tracking (`var_string`, `var_int16u`)
- Hook mechanism for dynamic format assignment
- Bit-level extraction with Mask/BitShift
- Complex format expressions like `string[$val{3}]`

### Error Handling Excellence

- MINOR_ERRORS classification system
- Graceful degradation with corruption
- Manufacturer-specific quirk handling
- Size limits and validation boundaries

### State Management Requirements

- PROCESSED hash for recursion prevention
- DataMember dependencies between tags
- VALUE hash for extracted data
- Directory context (Base, DataPos, PATH)

## System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        Build Pipeline                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ExifTool Source → Perl Extractor → JSON → Rust Codegen        │
│                                                ↓                 │
│                                         Generated Code           │
│                                                +                 │
│                                      Implementation Palette      │
│                                                ↓                 │
│                                         exif-oxide Library       │
└─────────────────────────────────────────────────────────────────┘

Implementation Palette Structure:
implementations/
├── registry.rs              # Maps signatures/keys to implementations
├── process/
│   ├── mod.rs              # ProcessProc trait and dispatch
│   ├── exif.rs             # ProcessExif implementation
│   ├── binary_data.rs      # ProcessBinaryData with simple patterns
│   ├── xmp.rs              # ProcessXMP implementation
│   └── manufacturers/
│       ├── canon/
│       │   ├── mod.rs
│       │   └── serial_data.rs  # ProcessSerialData
│       ├── nikon/
│       │   ├── mod.rs
│       │   └── encrypted.rs    # ProcessNikonEncrypted
│       └── sony/
│           └── encrypted.rs    # Sony encryption
├── conversions/
│   ├── print_conv/
│   │   ├── lookups.rs      # Simple hash lookups
│   │   ├── bitwise.rs      # BITMASK operations
│   │   └── format.rs       # sprintf-style formatting
│   ├── value_conv/
│   │   ├── math.rs         # Mathematical conversions
│   │   └── binary.rs       # Binary data handling
│   └── conditions/
│       └── model.rs        # Model/firmware conditions
├── formats/
│   ├── simple.rs           # int16u[10], string[20]
│   └── variable.rs         # string[$val{3}] ONLY
├── crypto/
│   ├── nikon.rs           # Nikon decryption algorithm
│   └── sony.rs            # Sony decryption algorithm
└── error/
    └── classification.rs   # MINOR_ERRORS system port
```

## Public API Design

The codegen produces a public API that the CLI and library consumers use:

```rust
/// Main metadata reader - generated by codegen
pub struct ExifReader {
    // State management (see TODO-STATE-MANAGEMENT.md)
    processed: HashSet<DirectoryPath>,
    values: HashMap<String, TagValue>,
    data_members: HashMap<String, Value>,

    // Current processing context
    path: Vec<String>,
    base: u32,
    byte_order: ByteOrder,
}

impl ExifReader {
    /// Primary entry point - signature that codegen guarantees
    pub fn read_metadata(
        &mut self,
        data: &[u8],
        options: ReadOptions,
    ) -> Result<Metadata, ExifError> {
        // Codegen produces this implementation:
        // 1. Detect file format using magic numbers
        // 2. Dispatch to appropriate processor
        // 3. Traverse metadata structure
        // 4. Apply conversions
        // 5. Return structured results
    }

    /// Extract specific tags only
    pub fn read_tags(
        &mut self,
        data: &[u8],
        tag_names: &[String],
    ) -> Result<HashMap<String, TagValue>, ExifError> {
        let options = ReadOptions::default()
            .with_requested_tags(tag_names);
        let metadata = self.read_metadata(data, options)?;
        Ok(metadata.filtered_tags(tag_names))
    }

    /// Extract binary data (thumbnails, previews)
    pub fn read_binary_tag(
        &mut self,
        data: &[u8],
        tag_name: &str,
    ) -> Result<Vec<u8>, ExifError> {
        // Special handling for binary extraction
    }
}

/// Results structure
pub struct Metadata {
    pub tags: HashMap<String, TagValue>,
    pub errors: Vec<ExifError>,
    pub warnings: Vec<String>,
}

/// Tag value representation
pub enum TagValue {
    String(String),
    Integer(i64),
    Float(f64),
    Rational(i64, i64),
    Binary(Vec<u8>),
    Array(Vec<TagValue>),
}
```

## Code Generation Strategy

### What Codegen Handles

1. **Tag Table Generation**

   ```rust
   // Generated from ExifTool tables
   pub static EXIF_TAGS: TagTable = TagTable {
       name: "EXIF::Main",
       process_proc: ProcessProc::Exif,
       tags: &[
           Tag {
               id: 0x010e,
               name: "ImageDescription",
               format: Format::String,
               // Simple PrintConv only
               print_conv: Some(PrintConv::PassThrough),
           },
           // ... more tags
       ],
   };
   ```

2. **Simple Conversions**

   ```rust
   // Generated for simple hash lookups
   fn print_conv_orientation(val: &TagValue) -> String {
       match val.as_u16() {
           Some(1) => "Horizontal (normal)".to_string(),
           Some(2) => "Mirror horizontal".to_string(),
           // ...
           _ => format!("Unknown ({})", val),
       }
   }
   ```

3. **Dispatch Tables**
   ```rust
   // Generated processor dispatch
   fn select_processor(table: &TagTable) -> ProcessFunc {
       match table.process_proc {
           ProcessProc::Exif => process::exif::process_exif,
           ProcessProc::BinaryData => process::binary_data::process_binary,
           ProcessProc::Custom(name) => {
               registry::get_processor(name)
                   .unwrap_or(process::exif::process_exif)
           }
       }
   }
   ```

### What Codegen Does NOT Handle

1. **Complex Perl Logic**: Multi-line conditions, evals, complex math
2. **Dynamic Patterns**: Anything beyond `simple[$val{N}]`
3. **Encryption**: All crypto is manually implemented
4. **Hook Logic**: ProcessBinaryData Hooks are manual
5. **Error Recovery**: Manufacturer quirks are manual

### TODO Tracking System

Instead of generating thousands of stub functions that would panic with `todo!()`, we use a runtime fallback system:

#### For PrintConv/ValueConv - Runtime References

```rust
// In generated code - NO STUBS GENERATED
Tag {
    id: 0x0112,
    name: "Orientation",
    print_conv: Some("exif_orientation_lookup"), // Just a reference
    value_conv: None,
}

// At runtime - graceful fallback
fn apply_print_conv(tag: &Tag, value: &TagValue) -> String {
    if let Some(conv_name) = &tag.print_conv {
        match registry.get_print_conv(conv_name) {
            Some(conv_fn) => conv_fn(value),
            None => {
                // Track missing implementation
                metrics::log_missing_impl(conv_name, &tag.name);
                // Return raw value formatted - never panic!
                format!("{:?}", value)
            }
        }
    } else {
        format!("{:?}", value)
    }
}
```

#### For PROCESS_PROC - Required Implementations

Since there are only ~50 custom processors, we can enumerate them:

```rust
// Generated enum of all known processors
pub enum ProcessorType {
    Exif,
    BinaryData,
    Canon(CanonProcessor),
    Nikon(NikonProcessor),
    // ... ~50 variants total
}

// Runtime dispatch with clear errors
fn dispatch_processor(proc_type: ProcessorType, data: &[u8]) -> Result<()> {
    match proc_type {
        ProcessorType::Canon(CanonProcessor::SerialData) => {
            registry.get_processor("Canon::SerialData")
                .ok_or(ExifError::missing_processor("Canon::SerialData"))?
                (data)
        }
        // ...
    }
}
```

#### Missing Implementation Tracking

```rust
// Generated metadata about what implementations are needed
pub static TAG_IMPL_REQUIREMENTS: &[(TagDef, ImplRequirement)] = &[
    (
        TagDef { table: "EXIF::Main", id: 0x0112, name: "Orientation" },
        ImplRequirement {
            print_conv: Some("orientation_lookup"),
            value_conv: None,
            priority: Priority::High,
            test_images: &["t/images/Canon.jpg"],
        }
    ),
    // ... all requirements
];

// Runtime tracking
lazy_static! {
    static ref MISSING_IMPLS: Mutex<HashMap<String, MissingImpl>> =
        Mutex::new(HashMap::new());
}
```

#### Developer Tools

```bash
# Show what implementations are actually needed
cargo run -p exif-oxide -- --show-missing photo.jpg

Output:
Missing Implementations for photo.jpg
=====================================
HIGH PRIORITY (blocks common tags):
- orientation_lookup (PrintConv)
  Used by: EXIF:Orientation

MEDIUM PRIORITY:
- canon_custom_functions (PrintConv)
  Used by: Canon:CustomFunctions

# Generate stubs only for what's needed
cargo run -p exif-oxide -- --generate-stubs photo.jpg
# Creates: implementations/stubs/photo_jpg_stubs.rs with 2 functions
```

#### Graceful Degradation

```rust
// In generated tag extraction
impl Tag {
    fn extract(&self, data: &[u8], ctx: &Context) -> Result<ExtractedTag> {
        let raw_value = self.parse_raw(data)?;

        // ValueConv with fallback
        let converted_value = self.value_conv
            .and_then(|ref_name| ctx.apply_value_conv(ref_name, &raw_value).ok())
            .unwrap_or(raw_value.clone());

        // PrintConv with fallback
        let display_value = self.print_conv
            .and_then(|ref_name| ctx.apply_print_conv(ref_name, &converted_value).ok())
            .unwrap_or_else(|| format!("{:?}", converted_value));

        Ok(ExtractedTag {
            name: self.name.clone(),
            raw: raw_value,
            converted: converted_value,
            display: display_value,
        })
    }
}
```

## Implementation Palette

### Indexing Scheme

The palette uses multiple indexing strategies:

1. **Signature-Based** (for PrintConv/ValueConv)

   ```rust
   registry.register_print_conv(
       "{ 0 => 'None', 1 => 'Horizontal (normal)', ... }",
       implementations::print_conv::orientation
   );
   ```

2. **Key-Based** (for complex implementations)

   ```rust
   registry.register_processor(
       ProcessorKey {
           table: "Canon::Main",
           tag: Some(0x5),
           name: "ProcessSerialData",
       },
       implementations::process::canon::serial_data::process
   );
   ```

3. **Pattern-Based** (for formats)
   ```rust
   registry.register_format_pattern(
       "string[$val{*}]",
       implementations::formats::variable::string_from_val
   );
   ```

### Manual Implementation Pattern

Each manual implementation includes:

```rust
/// Canon Serial/AF Data Processing
///
/// Handles variable-length serial data based on NumAFPoints.
/// ExifTool: lib/Image/ExifTool/Canon.pm:6337 ProcessSerialData
pub fn process_serial_data(
    reader: &mut ExifReader,
    data: &[u8],
    table: &TagTable,
) -> Result<()> {
    // Manual port of ProcessSerialData logic
    // References specific line numbers in ExifTool

    // Get NumAFPoints from DataMember
    let num_points = reader.data_members.get("NumAFPoints")
        .and_then(|v| v.as_u16())
        .unwrap_or(0);

    // Complex logic ported from Perl...
}
```

## Handling ProcessBinaryData

### Supported Format Patterns

Only these simple patterns are handled by codegen:

1. **Fixed Arrays**: `int16u[10]`, `string[32]`
2. **Simple Variables**: `string[$val{3}]` where tag 3 has the length

### Format Handler Example

```rust
// In implementations/formats/variable.rs
pub fn parse_string_from_val(
    data: &[u8],
    offset: usize,
    val_ref: usize,
    ctx: &Context,
) -> Result<(String, usize)> {
    // Get length from previously extracted value
    let length = ctx.get_value(val_ref)
        .and_then(|v| v.as_usize())
        .ok_or("Missing length value")?;

    // Validate bounds
    if offset + length > data.len() {
        return Err("String extends beyond data");
    }

    // Extract string
    let bytes = &data[offset..offset + length];
    let string = String::from_utf8_lossy(bytes).into_owned();

    Ok((string, length))
}
```

### Complex Format Handling

For complex formats, entire tag tables are manually implemented:

```rust
// When Format contains Hook or complex expressions
pub fn process_sony_camera_settings(
    reader: &mut ExifReader,
    data: &[u8],
) -> Result<()> {
    // Entire manual implementation
    // No attempt to parse Perl Hook code
}
```

## Error Handling Architecture

Port ExifTool's classification system:

```rust
pub enum ErrorLevel {
    /// Fatal - stop processing
    Fatal,
    /// Minor - continue but warn (ExifTool's MINOR_ERRORS)
    Minor,
    /// Warning - informational only
    Warning,
}

pub struct ExifError {
    pub level: ErrorLevel,
    pub message: String,
    pub context: ErrorContext,
}

pub struct ErrorContext {
    pub path: Vec<String>,      // IFD0.ExifIFD.MakerNotes
    pub tag: Option<String>,
    pub offset: Option<usize>,
}
```

## Write Support Architecture

High-level design for future write support:

```rust
/// Write support trait - implemented later
pub trait WriteProc {
    fn write_directory(
        &self,
        writer: &mut ExifWriter,
        values: &HashMap<String, TagValue>,
        original: Option<&[u8]>,
    ) -> Result<Vec<u8>>;
}

/// Writer state (future)
pub struct ExifWriter {
    // Offset fixup system
    fixups: HashMap<u32, FixupInfo>,
    // New values to write
    new_values: HashMap<String, TagValue>,
    // Write options
    options: WriteOptions,
}
```

## Development Workflow

1. **Extract Phase**

   ```bash
   perl codegen/extract_tables.pl > codegen/tag_tables.json
   ```

2. **Generate Phase**

   ```bash
   cargo run -p codegen
   ```

   Output:

   ```
   Generated: 15,234 tag definitions
   Simple conversions implemented: 2,341
   Complex conversions referenced: 1,893 (no stubs generated)
   Custom processors identified: 47

   Code is ready to compile and run!
   Use --show-missing on actual images to see what's needed.
   ```

3. **Discover Missing Implementations**

   ```bash
   # Run on actual images to find what's needed
   cargo run -p exif-oxide -- t/images/Canon/EOS-5D.jpg --show-missing

   Missing implementations for this file:
   - orientation_lookup (EXIF:Orientation)
   - canon_ev_format (Canon:ExposureCompensation)
   - canon_wb_lookup (Canon:WhiteBalance)

   # Generate just these stubs
   cargo run -p exif-oxide -- t/images/Canon/EOS-5D.jpg --generate-stubs
   # Creates: implementations/stubs/eos_5d_stubs.rs
   ```

4. **Implement What's Needed**

   - Developer implements the specific functions
   - References ExifTool source
   - Registers in implementation palette
   - No need to implement unused conversions!

5. **Validate Phase**
   ```bash
   cargo test
   # Runs against ExifTool test images
   # Compares output with exiftool -j
   # Shows coverage metrics
   ```

## Benefits Over Previous Approaches

1. **Realistic**: No Perl parsing, just manual porting of what matters
2. **Incremental**: Ship working code immediately, improve coverage over time
3. **Maintainable**: Clear separation between generated and manual code
4. **Traceable**: Every manual implementation references ExifTool source
5. **Robust**: Handles ExifTool's full complexity through manual excellence
6. **No Panic**: System never crashes on missing implementations - always returns useful data
7. **Demand-Driven**: Only implement what's actually used in real files
8. **Zero Stub Spam**: No thousands of TODO functions cluttering the codebase

## Example Milestone Implementation

### Milestone 1: Basic JPEG/EXIF Support

Generated code provides:

- JPEG segment parsing (APP1 extraction)
- Basic EXIF IFD traversal
- Simple tag extraction (strings, integers)
- Common PrintConv lookups (Orientation, Flash)

Manual implementations add:

- EXIF date parsing
- Rational number handling
- Basic MakerNote detection

Coverage: ~200 common tags, enough for basic photo management.

### Milestone 2: Canon Support

Manual implementations:

- ProcessSerialData for AF information
- Canon-specific offset calculations
- CameraSettings binary data
- Canon PrintConv functions

This pattern continues for each manufacturer.

## Conclusion

ARCHITECTURE-TAKE-5 embraces the reality of ExifTool's complexity. Rather than trying to automatically handle Perl's flexibility, we:

1. Use codegen only for unambiguous translations
2. Manually port complex logic with full traceability
3. Build an implementation palette that grows over time
4. Maintain ExifTool compatibility through careful porting

This approach is more labor-intensive but results in:

- Correct handling of manufacturer quirks
- Predictable performance
- Maintainable code
- Clear progress tracking

The key insight: ExifTool's value isn't in its Perl code, but in the accumulated knowledge of metadata formats. We preserve this knowledge through careful manual translation, not automatic parsing.
