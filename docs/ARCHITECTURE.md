# exif-oxide Architecture

## Overview

This document represents the eighth iteration of the exif-oxide architecture, incorporating deep understanding of ExifTool's PROCESS_PROC system, ProcessBinaryData complexity, sophisticated error handling, and WRITE_PROC infrastructure. We embrace manual porting of complex logic while using code generation only for straightforward translations.

**Scope**: This project targets mainstream metadata tags only (frequency > 80% in TagMetadata.json), reducing the implementation burden from 15,000+ tags to approximately 500-1000. We explicitly do not support ExifTool's custom tag definitions or user-defined tags.

## Core Philosophy

1. **No Novel Parsing**: ExifTool has already solved every edge case - we port, not reinvent
2. **Manual Excellence**: Complex logic is manually ported with references to ExifTool source
3. **Simple Codegen**: Generator handles only straightforward, unambiguous translations
4. **Always Working**: System produces compilable code at every stage
5. **Transparent Progress**: Clear visibility into what's implemented vs TODO
6. **Mainstream Focus**: Only implement tags with >80% frequency or marked mainstream in TagMetadata.json
7. **Streaming First**: All binary data handled via streaming to minimize memory usage

## Key Insights from ExifTool Analysis

### PROCESS_PROC Complexity

- 121+ uses of ProcessBinaryData across manufacturers
- Custom processors for encrypted data (Nikon), serial data (Canon), text formats (JVC)
- Sophisticated dispatch with table-level and SubDirectory overrides
- No code sharing between processors - each is self-contained

### ProcessBinaryData Sophistication

- Variable-length formats with offset tracking (`var_string`, `var_int16u`)
- Hook mechanism for dynamic format assignment
- Bit-level extraction with Mask/BitShift
- Complex format expressions like `string[$val{3}]`

### Error Handling Excellence

- MINOR_ERRORS classification system
- Graceful degradation with corruption
- Manufacturer-specific quirk handling
- Size limits and validation boundaries

### State Management Requirements

- PROCESSED hash for recursion prevention
- DataMember dependencies between tags
- VALUE hash for extracted data
- Directory context (Base, DataPos, PATH)

## Mainstream Tag Filtering

To maintain a manageable scope, exif-oxide only implements tags that meet one of these criteria:

1. **Frequency > 80%**: Tags appearing in more than 80% of images
2. **Mainstream flag**: Tags marked as `mainstream: true` in TagMetadata.json
3. **Critical dependencies**: Tags required by other mainstream tags (DataMember)

This reduces scope from ~15,000 tags to ~500-1000, focusing on tags that matter for media management applications.

### Filtering During Codegen

```rust
// In codegen/src/filter.rs
fn should_generate_tag(tag: &Tag, metadata: &TagMetadata) -> bool {
    if let Some(meta) = metadata.get(&tag.name) {
        meta.mainstream || meta.frequency > 0.8
    } else {
        false // Unknown tags excluded by default
    }
}
```

## System Architecture

### Build pipeline

1. **ExifTool Source**
2. **Perl Extractor**
3. **JSON**
4. **Rust Codegen**
5. **Generated Code**
6. **Implementation Palette**
7. **exif-oxide Library**

### Implementation Palette Structure

implementations/
├── registry.rs # Maps signatures/keys to implementations
├── process/
│ ├── mod.rs # ProcessProc trait and dispatch
│ ├── exif.rs # ProcessExif implementation
│ ├── binary_data.rs # ProcessBinaryData with simple patterns
│ ├── xmp.rs # ProcessXMP implementation
│ └── manufacturers/
│ ├── canon/
│ │ ├── mod.rs
│ │ └── serial_data.rs # ProcessSerialData
│ ├── nikon/
│ │ ├── mod.rs
│ │ └── encrypted.rs # ProcessNikonEncrypted
│ └── sony/
│ └── encrypted.rs # Sony encryption
├── conversions/
│ ├── print_conv/
│ │ ├── lookups.rs # Simple hash lookups
│ │ ├── bitwise.rs # BITMASK operations
│ │ └── format.rs # sprintf-style formatting
│ ├── value_conv/
│ │ ├── math.rs # Mathematical conversions
│ │ └── binary.rs # Binary data handling
│ └── conditions/
│ └── model.rs # Model/firmware conditions
├── formats/
│ ├── simple.rs # int16u[10], string[20]
│ └── variable.rs # string[$val{3}] ONLY
├── crypto/
│ ├── nikon.rs # Nikon decryption algorithm
│ └── sony.rs # Sony decryption algorithm
└── error/
└── classification.rs # MINOR_ERRORS system port

## Public API Design

The codegen produces a public API that the CLI and library consumers use:

```rust
/// Main metadata reader - generated by codegen
pub struct ExifReader {
    // State management (see TODO-STATE-MANAGEMENT.md)
    processed: HashSet<DirectoryPath>,
    values: HashMap<String, TagValue>,
    data_members: HashMap<String, Value>,

    // Current processing context
    path: Vec<String>,
    base: u32,
    byte_order: ByteOrder,
}

impl ExifReader {
    /// Primary entry point for in-memory data
    pub fn read_metadata(
        &mut self,
        data: &[u8],
        options: ReadOptions,
    ) -> Result<Metadata, ExifError> {
        // Codegen produces this implementation:
        // 1. Detect file format using magic numbers
        // 2. Dispatch to appropriate processor
        // 3. Traverse metadata structure
        // 4. Apply conversions
        // 5. Return structured results
    }

    /// Streaming entry point (preferred)
    pub fn read_metadata_stream<R: Read + Seek>(
        &mut self,
        reader: R,
        options: ReadOptions,
    ) -> Result<Metadata, ExifError> {
        // Streaming implementation that doesn't load entire file
        // Binary tags return BinaryRef for separate streaming
    }

    /// Extract specific tags only
    pub fn read_tags(
        &mut self,
        data: &[u8],
        tag_names: &[String],
    ) -> Result<HashMap<String, TagValue>, ExifError> {
        let options = ReadOptions::default()
            .with_requested_tags(tag_names);
        let metadata = self.read_metadata(data, options)?;
        Ok(metadata.filtered_tags(tag_names))
    }

    /// Get reference to binary data for streaming
    pub fn get_binary_ref(
        &mut self,
        data: &[u8],
        tag_name: &str,
    ) -> Result<BinaryRef, ExifError> {
        // Returns reference for separate streaming
        // Does NOT load binary data into memory
    }

    /// Stream binary data separately
    pub fn stream_binary_tag<R: Read + Seek>(
        &self,
        reader: R,
        binary_ref: &BinaryRef,
    ) -> Result<impl Read, ExifError> {
        Ok(BinaryTagReader::new(reader, binary_ref))
    }
}

/// Streaming reader for binary data
pub struct BinaryTagReader<R: Read + Seek> {
    reader: R,
    offset: u64,
    remaining: usize,
}

impl<R: Read + Seek> Read for BinaryTagReader<R> {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        // Efficient streaming implementation
    }
}

/// Results structure
pub struct Metadata {
    pub tags: HashMap<String, TagValue>,
    pub errors: Vec<ExifError>,
    pub warnings: Vec<String>,
}

/// Tag value representation
pub enum TagValue {
    String(String),
    Integer(i64),
    Float(f64),
    Rational(i64, i64),
    Binary(BinaryRef),  // Changed: streaming reference, not data
    Array(Vec<TagValue>),
}

/// Reference to binary data for streaming
pub struct BinaryRef {
    offset: u64,
    length: usize,
    format: BinaryFormat,  // JPEG, TIFF, etc.
}
```

## Code Generation Strategy

### What Codegen Handles

1. **Tag Table Generation**

   ```rust
   // Generated from ExifTool tables
   pub static EXIF_TAGS: TagTable = TagTable {
       name: "EXIF::Main",
       process_proc: ProcessProc::Exif,
       tags: &[
           Tag {
               id: 0x010e,
               name: "ImageDescription",
               format: Format::String,
               // Simple PrintConv only
               print_conv: Some(PrintConv::PassThrough),
           },
           // ... more tags
       ],
   };
   ```

2. **Simple Conversions**

   ```rust
   // Generated for simple hash lookups
   fn print_conv_orientation(val: &TagValue) -> String {
       match val.as_u16() {
           Some(1) => "Horizontal (normal)".to_string(),
           Some(2) => "Mirror horizontal".to_string(),
           // ...
           _ => format!("Unknown ({})", val),
       }
   }
   ```

3. **Dispatch Tables**
   ```rust
   // Generated processor dispatch
   fn select_processor(table: &TagTable) -> ProcessFunc {
       match table.process_proc {
           ProcessProc::Exif => process::exif::process_exif,
           ProcessProc::BinaryData => process::binary_data::process_binary,
           ProcessProc::Custom(name) => {
               registry::get_processor(name)
                   .unwrap_or(process::exif::process_exif)
           }
       }
   }
   ```

4. **Conversion Reference Lists** (Milestone 8a)
   ```rust
   // Generated from same source as tag definitions
   // Ensures single source of truth for conversion requirements
   pub static REQUIRED_PRINT_CONV: &[&str] = &[
       "orientation_print_conv",
       "flash_print_conv", 
       "colorspace_print_conv",
       // ... automatically extracted from all tag tables
   ];
   
   pub static REQUIRED_VALUE_CONV: &[&str] = &[
       "gps_coordinate_value_conv",
       "apex_shutter_value_conv",
       // ... extracted from ExifTool value conversion references
   ];
   ```

### What Codegen Does NOT Handle

1. **Complex Perl Logic**: Multi-line conditions, evals, complex math
2. **Dynamic Patterns**: Anything beyond `simple[$val{N}]`
3. **Encryption**: All crypto is manually implemented
4. **Hook Logic**: ProcessBinaryData Hooks are manual
5. **Error Recovery**: Manufacturer quirks are manual

### TODO Tracking System

Instead of generating thousands of stub functions that would panic with `todo!()`, we use a runtime fallback system:

#### For PrintConv/ValueConv - Runtime References

```rust
// In generated code - NO STUBS GENERATED
Tag {
    id: 0x0112,
    name: "Orientation",
    print_conv: Some("exif_orientation_lookup"), // Just a reference
    value_conv: None,
}

// At runtime - graceful fallback
fn apply_print_conv(tag: &Tag, value: &TagValue) -> String {
    if let Some(conv_name) = &tag.print_conv {
        match registry.get_print_conv(conv_name) {
            Some(conv_fn) => conv_fn(value),
            None => {
                // Track missing implementation
                metrics::log_missing_impl(conv_name, &tag.name);
                // Return raw value formatted - never panic!
                format!("{:?}", value)
            }
        }
    } else {
        format!("{:?}", value)
    }
}
```

The auto-generated `REQUIRED_PRINT_CONV`/`REQUIRED_VALUE_CONV` arrays (Milestone 8a) provide development visibility into the complete scope of conversion implementations needed, while maintaining DRY principles by extracting these references during the same codegen pass that creates the tag definitions.

#### For PROCESS_PROC - Required Implementations

Since there are only ~50 custom processors, we can enumerate them:

```rust
// Generated enum of all known processors
pub enum ProcessorType {
    Exif,
    BinaryData,
    Canon(CanonProcessor),
    Nikon(NikonProcessor),
    // ... ~50 variants total
}

// Runtime dispatch with clear errors
fn dispatch_processor(proc_type: ProcessorType, data: &[u8]) -> Result<()> {
    match proc_type {
        ProcessorType::Canon(CanonProcessor::SerialData) => {
            registry.get_processor("Canon::SerialData")
                .ok_or(ExifError::missing_processor("Canon::SerialData"))?
                (data)
        }
        // ...
    }
}
```

#### Missing Implementation Tracking

```rust
// Generated metadata about what implementations are needed
pub static TAG_IMPL_REQUIREMENTS: &[(TagDef, ImplRequirement)] = &[
    (
        TagDef { table: "EXIF::Main", id: 0x0112, name: "Orientation" },
        ImplRequirement {
            print_conv: Some("orientation_lookup"),
            value_conv: None,
            priority: Priority::High,
            test_images: &["t/images/Canon.jpg"],
        }
    ),
    // ... all requirements
];

// Runtime tracking
lazy_static! {
    static ref MISSING_IMPLS: Mutex<HashMap<String, MissingImpl>> =
        Mutex::new(HashMap::new());
}
```

#### Developer Tools

```bash
# Show what implementations are actually needed
cargo run -p exif-oxide -- --show-missing photo.jpg

Output:
Missing Implementations for photo.jpg
=====================================
HIGH PRIORITY (blocks common tags):
- orientation_lookup (PrintConv)
  Used by: EXIF:Orientation

MEDIUM PRIORITY:
- canon_custom_functions (PrintConv)
  Used by: Canon:CustomFunctions

# Generate stubs only for what's needed
cargo run -p exif-oxide -- --generate-stubs photo.jpg
# Creates: implementations/stubs/photo_jpg_stubs.rs with 2 functions
```

#### Graceful Degradation

```rust
// In generated tag extraction
impl Tag {
    fn extract(&self, data: &[u8], ctx: &Context) -> Result<ExtractedTag> {
        let raw_value = self.parse_raw(data)?;

        // ValueConv with fallback
        let converted_value = self.value_conv
            .and_then(|ref_name| ctx.apply_value_conv(ref_name, &raw_value).ok())
            .unwrap_or(raw_value.clone());

        // PrintConv with fallback
        let display_value = self.print_conv
            .and_then(|ref_name| ctx.apply_print_conv(ref_name, &converted_value).ok())
            .unwrap_or_else(|| format!("{:?}", converted_value));

        Ok(ExtractedTag {
            name: self.name.clone(),
            raw: raw_value,
            converted: converted_value,
            display: display_value,
        })
    }
}
```

## Implementation Palette

### Indexing Scheme

The palette uses multiple indexing strategies:

1. **Signature-Based** (for PrintConv/ValueConv)

   ```rust
   registry.register_print_conv(
       "{ 0 => 'None', 1 => 'Horizontal (normal)', ... }",
       implementations::print_conv::orientation
   );
   ```

2. **Key-Based** (for complex implementations)

   ```rust
   registry.register_processor(
       ProcessorKey {
           table: "Canon::Main",
           tag: Some(0x5),
           name: "ProcessSerialData",
       },
       implementations::process::canon::serial_data::process
   );
   ```

3. **Pattern-Based** (for formats)
   ```rust
   registry.register_format_pattern(
       "string[$val{*}]",
       implementations::formats::variable::string_from_val
   );
   ```

### Manual Implementation Pattern

Each manual implementation includes:

```rust
/// Canon Serial/AF Data Processing
///
/// Handles variable-length serial data based on NumAFPoints.
/// ExifTool: lib/Image/ExifTool/Canon.pm:6337 ProcessSerialData
pub fn process_serial_data(
    reader: &mut ExifReader,
    data: &[u8],
    table: &TagTable,
) -> Result<()> {
    // Manual port of ProcessSerialData logic
    // References specific line numbers in ExifTool

    // Get NumAFPoints from DataMember
    let num_points = reader.data_members.get("NumAFPoints")
        .and_then(|v| v.as_u16())
        .unwrap_or(0);

    // Complex logic ported from Perl...
}
```

## Handling ProcessBinaryData

### Supported Format Patterns

Only these simple patterns are handled by codegen:

1. **Fixed Arrays**: `int16u[10]`, `string[32]`
2. **Simple Variables**: `string[$val{3}]` where tag 3 has the length

### Format Handler Example

```rust
// In implementations/formats/variable.rs
pub fn parse_string_from_val(
    data: &[u8],
    offset: usize,
    val_ref: usize,
    ctx: &Context,
) -> Result<(String, usize)> {
    // Get length from previously extracted value
    let length = ctx.get_value(val_ref)
        .and_then(|v| v.as_usize())
        .ok_or("Missing length value")?;

    // Validate bounds
    if offset + length > data.len() {
        return Err("String extends beyond data");
    }

    // Extract string
    let bytes = &data[offset..offset + length];
    let string = String::from_utf8_lossy(bytes).into_owned();

    Ok((string, length))
}
```

### Complex Format Handling

For complex formats, entire tag tables are manually implemented:

```rust
// When Format contains Hook or complex expressions
pub fn process_sony_camera_settings(
    reader: &mut ExifReader,
    data: &[u8],
) -> Result<()> {
    // Entire manual implementation
    // No attempt to parse Perl Hook code
}
```

## Error Handling Architecture

Port ExifTool's classification system:

```rust
pub enum ErrorLevel {
    /// Fatal - stop processing
    Fatal,
    /// Minor - continue but warn (ExifTool's MINOR_ERRORS)
    Minor,
    /// Warning - informational only
    Warning,
}

pub struct ExifError {
    pub level: ErrorLevel,
    pub message: String,
    pub context: ErrorContext,
}

pub struct ErrorContext {
    pub path: Vec<String>,      // IFD0.ExifIFD.MakerNotes
    pub tag: Option<String>,
    pub offset: Option<usize>,
}

/// Idiomatic Rust error types using thiserror
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ExifError {
    #[error("Invalid JPEG marker {marker:#x} at offset {offset:#x}")]
    InvalidMarker { marker: u8, offset: usize },

    #[error("Tag {tag} requires format {required} but found {found}")]
    InvalidFormat { tag: String, required: String, found: String },

    #[error("Missing processor implementation: {0}")]
    MissingProcessor(String),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}
```

## Async Support Strategy

The initial implementation is synchronous for simplicity, but the architecture supports easy async adaptation:

### Sync-First Design

```rust
// Initial synchronous API
pub struct ExifReader { /* ... */ }

impl ExifReader {
    pub fn read_metadata<R: Read + Seek>(
        &mut self,
        reader: R,
        options: ReadOptions,
    ) -> Result<Metadata, ExifError> {
        // Synchronous implementation
    }
}
```

### Future Async Wrapper

```rust
// Async wrapper (future milestone)
use tokio::task;

pub async fn read_metadata_async<R: AsyncRead + AsyncSeek>(
    mut reader: R,
    options: ReadOptions,
) -> Result<Metadata, ExifError> {
    // For CPU-intensive parsing, use spawn_blocking
    task::spawn_blocking(move || {
        let sync_reader = AsyncToSyncReader::new(reader);
        let mut exif_reader = ExifReader::new();
        exif_reader.read_metadata(sync_reader, options)
    }).await?
}

// Async streaming for large binary data
pub struct AsyncBinaryTagReader<R: AsyncRead + AsyncSeek> {
    reader: R,
    offset: u64,
    remaining: usize,
}

impl<R: AsyncRead + AsyncSeek> AsyncRead for AsyncBinaryTagReader<R> {
    // Efficient async streaming
}
```

This approach allows:

- Simple initial implementation
- No async complexity in core parsing logic
- Easy async adaptation when needed
- Efficient handling of I/O-bound operations

## Write Support Architecture

High-level design for future write support:

```rust
/// Write support trait - implemented later
pub trait WriteProc {
    fn write_directory(
        &self,
        writer: &mut ExifWriter,
        values: &HashMap<String, TagValue>,
        original: Option<&[u8]>,
    ) -> Result<Vec<u8>>;
}

/// Writer state (future)
pub struct ExifWriter {
    // Offset fixup system
    fixups: HashMap<u32, FixupInfo>,
    // New values to write
    new_values: HashMap<String, TagValue>,
    // Write options
    options: WriteOptions,
}
```

## Update Workflow for ExifTool Releases

When a new ExifTool version is released:

1. **Update ExifTool Submodule**

   ```bash
   cd third-party/exiftool
   git fetch origin
   git checkout v12.77  # new version
   cd ../..
   ```

2. **Regenerate and Build**

   ```bash
   # Extract updated tag definitions
   perl codegen/extract_tables.pl > codegen/tag_tables.json

   # Run codegen - will show new missing implementations
   cargo run -p codegen
   ```

3. **Review Changes**

   ```
   New in ExifTool 12.77:
   - 3 new mainstream tags requiring implementation
   - 1 new Canon processor variant
   - 47 non-mainstream tags (ignored)

   Missing implementations (priority order):
   1. canon_new_lens_type (PrintConv) - 15 test images
   2. nikon_z9_af_mode (PrintConv) - 8 test images
   3. ProcessCanonCR3 (Processor) - 5 test images
   ```

4. **Implement Missing Pieces**

   - Add implementations to palette
   - Reference ExifTool source
   - Test against provided images

5. **Ship Updated Version**
   ```bash
   cargo test
   # All passing - ready to release!
   ```

For minor ExifTool updates that only add tags within existing processors, the process is often just regenerate and ship. New processors or complex conversions require manual implementation.

## Development Workflow

1. **Extract Phase**

   ```bash
   perl codegen/extract_tables.pl > codegen/tag_tables.json
   ```

2. **Generate Phase**

   ```bash
   cargo run -p codegen
   ```

   Output:

   ```
   Generated: 823 mainstream tag definitions (from 15,234 total)
   Simple conversions implemented: 156
   Complex conversions referenced: 234 (no stubs generated)
   Custom processors identified: 47

   Code is ready to compile and run!
   Use --show-missing on actual images to see what's needed.
   ```

3. **Discover Missing Implementations**

   ```bash
   # Run on actual images to find what's needed
   cargo run -p exif-oxide -- t/images/Canon/EOS-5D.jpg --show-missing

   Missing implementations for this file:
   - orientation_lookup (EXIF:Orientation)
   - canon_ev_format (Canon:ExposureCompensation)
   - canon_wb_lookup (Canon:WhiteBalance)

   # Generate just these stubs
   cargo run -p exif-oxide -- t/images/Canon/EOS-5D.jpg --generate-stubs
   # Creates: implementations/stubs/eos_5d_stubs.rs
   ```

4. **Implement What's Needed**

   - Developer implements the specific functions
   - References ExifTool source
   - Registers in implementation palette
   - No need to implement unused conversions!

5. **Validate Phase**
   ```bash
   cargo test
   # Runs against ExifTool test images
   # Compares output with exiftool -j
   # Shows coverage metrics
   ```

## Benefits Over Previous Approaches

1. **Realistic**: No Perl parsing, just manual porting of what matters
2. **Incremental**: Ship working code immediately, improve coverage over time
3. **Maintainable**: Clear separation between generated and manual code
4. **Traceable**: Every manual implementation references ExifTool source
5. **Robust**: Handles ExifTool's full complexity through manual excellence
6. **No Panic**: System never crashes on missing implementations - always returns useful data
7. **Demand-Driven**: Only implement what's actually used in real files
8. **Zero Stub Spam**: No thousands of TODO functions cluttering the codebase

## Example Milestone Implementation

### Milestone 1: Basic JPEG/EXIF Support

Generated code provides:

- JPEG segment parsing (APP1 extraction)
- Basic EXIF IFD traversal
- Simple tag extraction (strings, integers)
- Common PrintConv lookups (Orientation, Flash)

Manual implementations add:

- EXIF date parsing
- Rational number handling
- Basic MakerNote detection

Coverage: ~200 common tags, enough for basic photo management.

### Milestone 2: Canon Support

Manual implementations:

- ProcessSerialData for AF information
- Canon-specific offset calculations
- CameraSettings binary data
- Canon PrintConv functions

This pattern continues for each manufacturer.

## Conclusion

ARCHITECTURE-TAKE-5 embraces the reality of ExifTool's complexity. Rather than trying to automatically handle Perl's flexibility, we:

1. Use codegen only for unambiguous translations
2. Manually port complex logic with full traceability
3. Build an implementation palette that grows over time
4. Maintain ExifTool compatibility through careful porting

This approach is more labor-intensive but results in:

- Correct handling of manufacturer quirks
- Predictable performance
- Maintainable code
- Clear progress tracking

The key insight: ExifTool's value isn't in its Perl code, but in the accumulated knowledge of metadata formats. We preserve this knowledge through careful manual translation, not automatic parsing.
