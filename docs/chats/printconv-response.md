> Key Uncertainties
>
> 1. Tag ID Mapping Maintenance
>
> The plan relies on hardcoded mappings like (33437, "complex_expression_printconv") â†’ "fnumber_print_conv". My concerns:
> - How do we ensure these mappings stay in sync with ExifTool updates?

Perhaps we should map the PrintConv to the _definition_ of the printconv (like, the actual perl string), instead of the name?

> - Should we extract these mappings from ExifTool source somehow?

See the main CLI's `--show-missing` -- that was an initial attempt that was _supposed_ to show missing PrintConv or ValueConv.

> - What happens when new tags are added with similar patterns?

If the PrintConv registry is mapped by perl strings, and it uses the same perl implementation, it'll be automatic!

> 2. Expression Pattern Coverage
>
> I'm not certain about the completeness of expression patterns:
> - How many unique sprintf patterns exist in ExifTool? (I only checked a few)

A TON, but I think they're under 50 ish? Can we do research on that?

> - Are there expressions beyond sprintf that we need to handle?

A TON: see third-party/exiftool/doc/concepts/PRINT_CONV.md

> - What about expressions with conditionals like $val > 0 ? "Yes" : "No"?

We have the expression parsing framework, but it might be safer to manually write a rust PrintConv function and assign it to `$val > 0 ? "Yes" : "No"`

> 3. Performance Impact
>
> The runtime pattern matching approach has unknowns:
> - Will regex matching on every tag conversion be too slow?

It'd only be matching against non-statically assigned PrintConv, right?

> - Should we pre-compile patterns at startup?

No -- the vast majority of ExifTool's source is not used when parsing any given file.

> - Is the fallback being called for every tag or just failures?

Never failure -- just degrade to whatever ValueConf gives us.

> Architectural Concerns
>
> 1. The "complex_expression_printconv" Mystery
>
> This placeholder name appears to be generated by tag_kit when it can't handle an expression. Questions:
> - Is this name consistent across all complex expressions?

Maybe not? Would we need or want multiple PrintConv registries for different "flavored" tags? I don't know why.

> - Should we investigate why tag_kit generates this specific name?

Absolutely

> - Would it be better to preserve the original expression in the generated code?

I think that'll be what we look up the printconv with, so yes?

> 2. Module Boundary Confusion
>
> The current approach mixes concerns:
> - Tag kit (generated) knows about PrintConv types but can't execute them

Why would it need to execute the PrintConv?

> - Runtime (manual) has implementations but doesn't know which tags need them

I think I'd like to move away from this wiring as much as possible. Almost all of our manually ported over code has had subtle bugs that prove difficult to debug later.

> - The fallback bridges this gap, but is this the right boundary?

Maybe it should be simpler? 

Let's call this Plan J: 

1. we extract PrintConv into Yet Another Crate/Module thing, let's just call it `printconv`.
2. both codegen and the main production code can import and use
3. `printconv` exposes the hashmap/registry lookup that lets `codegen` do lookup at codegen time for what function to use for any given perl string, and a "missing" function if nothing is registered. Note that the registry _could_ live in `codegen` instead of `printconv`, because only `codegen` needs it, and then `exif-oxide` wouldn't be bloated by the lookup table.
4. generated code directly imports and calls the correct function in `printconv`
5. the "missing" PrintConv knows how to store context for all tags it's invoked on to support --show-missing

> 3. Error Handling Philosophy
>
> The plan silently falls back to raw values on failure:
> - Should we log/warn when PrintConv fails?
> - How do we debug which PrintConvs are missing?
> - Should failed conversions be visible to users somehow?

See above --show-missing cli arg

>
> Technical Debt Concerns
>
> 1. Temporary vs Permanent
>
> Is this fallback approach intended to be temporary?
> - If temporary, what's the long-term vision?
> - If permanent, should we formalize it better?
> - How do we prevent this from becoming tech debt?

I think if we go with Plan J we don't need a fallback, right?

>
> 2. Testing Strategy
>
> I'm uncertain about comprehensive testing:
> - How do we test all PrintConv paths systematically?

I think we have to rely on the `make compat` system here -- we really should be testing against real files and real `exiftool -j -G -struct` output.
 
> - Should we generate tests from ExifTool's test suite?

More thank `make compat` is already doing? Do you have ideas?

> - How do we catch regressions when adding new PrintConvs?

Each PrintConv certainly could have unit tests.

> Alternative Considerations
>
> 1. Codegen-Time Resolution
>
> What if we resolved PrintConv mappings during codegen instead of runtime?
> - Could tag_kit.pl be enhanced to output function names directly?
> - Could we generate a mapping table as a separate codegen step?
> - Would this eliminate the runtime overhead?

I think this should be doable (see Plan J above!)

> 2. Registry Enhancement
>
> Could we enhance the registry to be smarter?
> - Auto-discover PrintConv functions by naming convention?

I think if we want to be extra fancy we can have the registry use a regex _or_ string to match the perl implementation -- or we could map the PrintConv to multiple relevant strings -- or we could do some generic whitespace normalization (we do already with the expression `conditions` if you want to look that up)

> - Use attributes/macros to mark PrintConv functions?
> - Generate registry entries from implementations?

Maybe? Aren't there only like 100 of these? I feel like we can take it step by step and grunt out the registry mapping by hand to KISS.

> Questions for Discussion
>
> 1. Scope: Should we fix just the critical EXIF tags first, or aim for comprehensive coverage?

"required:true" tags are table stakes and non-negotiable. Everything else is gravy.

> 2. ExifTool Fidelity: How important is exact output matching vs "good enough" formatting?

See `make compat`'s normalization functions -- GPSLatitude and GPSLongitude is always numeric, for example, and there are already a handful of tags where our output doesn't match ExifTool's _exactly_, but there are cases where ExifTool itself is inconsistent (like sometimes rendering strings or numbers for the same tag and G0 group name, so we standardized on number). We only want to stray from ExifTool output when defensible (like for simplicity's sake, or consistency)

> 3. Maintenance: Who maintains the tag ID mappings? Should this be documented in code or external config?

For "Plan J" the registry is just a map living in `codegen`.

> 4. Future-Proofing: How do we handle new ExifTool versions that add PrintConv expressions?

Presumably `--show-missing` and `make compat` will expose these issues.

> 5. Performance Requirements: What's our performance budget for PrintConv operations?

No specific budget, but we want things to be as fast and memory efficient as possible while still having a readable idiomatic rust code base.

> My Biggest Concern
>
> The fundamental issue is that we're building a bridge between two systems (codegen and runtime) that weren't designed to communicate. This feels like we're working
> around the architecture rather than with it. Should we consider a more fundamental restructuring where:
> - PrintConv type information is preserved through to runtime?

What information needs to be preserved?

> - Generated code can reference manual implementations more directly?

Yeah! Plan J will get us there, right?

> - The circular dependency is resolved through better module organization?

PLAN J!

> What are your thoughts on these concerns? Should we proceed with the pragmatic fix or investigate some of these deeper architectural questions first?

Let's iterate on this for a bit, I'd like to get this sorted out now rather than later.

