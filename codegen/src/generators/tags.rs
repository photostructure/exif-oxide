//! Generator for EXIF tag tables

use anyhow::Result;
use std::fs;
use crate::schemas::GeneratedTag;
use crate::common::escape_string;

/// Generate EXIF tag table code
pub fn generate_tag_table(tags: &[GeneratedTag], output_dir: &str) -> Result<()> {
    let mut code = String::new();

    // File header
    code.push_str("//! Generated EXIF tag definitions\n");
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen/generate_rust.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");

    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n\n");

    // Format enum
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n");
    code.push_str("pub enum TagFormat {\n");
    code.push_str("    U8,\n");
    code.push_str("    U16,\n");
    code.push_str("    U32,\n");
    code.push_str("    I8,\n");
    code.push_str("    I16,\n");
    code.push_str("    I32,\n");
    code.push_str("    RationalU,\n");
    code.push_str("    RationalS,\n");
    code.push_str("    String,\n");
    code.push_str("    Undef,\n");
    code.push_str("    Float,\n");
    code.push_str("    Double,\n");
    code.push_str("}\n\n");

    // Tag structure
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub struct TagDef {\n");
    code.push_str("    pub id: u32,\n");
    code.push_str("    pub name: &'static str,\n");
    code.push_str("    pub format: TagFormat,\n");
    code.push_str("    pub groups: &'static [&'static str],\n");
    code.push_str("    pub writable: bool,\n");
    code.push_str("    pub description: Option<&'static str>,\n");
    code.push_str("    pub print_conv_ref: Option<&'static str>,\n");
    code.push_str("    pub value_conv_ref: Option<&'static str>,\n");
    code.push_str("    pub notes: Option<&'static str>,\n");
    code.push_str("}\n\n");

    // Static tag array
    code.push_str("pub static EXIF_MAIN_TAGS: &[TagDef] = &[\n");

    for tag in tags {
        code.push_str("    TagDef {\n");
        code.push_str(&format!("        id: 0x{:x},\n", tag.id));
        code.push_str(&format!("        name: \"{}\",\n", tag.name));
        code.push_str(&format!("        format: TagFormat::{},\n", tag.format));

        // Groups array
        code.push_str("        groups: &[");
        for (i, group) in tag.groups.iter().enumerate() {
            if i > 0 {
                code.push_str(", ");
            }
            code.push_str(&format!("\"{}\"", group));
        }
        code.push_str("],\n");

        code.push_str(&format!("        writable: {},\n", tag.writable));

        // Optional fields
        if let Some(desc) = &tag.description {
            code.push_str(&format!(
                "        description: Some(\"{}\"),\n",
                escape_string(desc)
            ));
        } else {
            code.push_str("        description: None,\n");
        }

        if let Some(pc) = &tag.print_conv_ref {
            code.push_str(&format!("        print_conv_ref: Some(\"{}\"),\n", pc));
        } else {
            code.push_str("        print_conv_ref: None,\n");
        }

        if let Some(vc) = &tag.value_conv_ref {
            code.push_str(&format!("        value_conv_ref: Some(\"{}\"),\n", vc));
        } else {
            code.push_str("        value_conv_ref: None,\n");
        }

        if let Some(notes) = &tag.notes {
            // Handle multi-line notes
            let formatted = notes
                .lines()
                .map(|line| line.trim())
                .collect::<Vec<_>>()
                .join(" ");
            code.push_str(&format!(
                "        notes: Some(\"{}\"),\n",
                escape_string(&formatted)
            ));
        } else {
            code.push_str("        notes: None,\n");
        }

        code.push_str("    },\n");
    }

    code.push_str("];\n\n");

    // Tag lookup by ID
    code.push_str("/// Lazy-loaded lookup map from tag ID to tag definition\n");
    code.push_str("pub static TAG_LOOKUP: LazyLock<HashMap<u32, &'static TagDef>> = LazyLock::new(|| {\n");
    code.push_str("    let mut map = HashMap::new();\n");
    code.push_str("    for tag in EXIF_MAIN_TAGS {\n");
    code.push_str("        map.insert(tag.id, tag);\n");
    code.push_str("    }\n");
    code.push_str("    map\n");
    code.push_str("});\n\n");

    // Tag lookup by name
    code.push_str("/// Lazy-loaded lookup map from tag name to tag definition\n");
    code.push_str(
        "pub static TAG_NAME_LOOKUP: LazyLock<HashMap<&'static str, &'static TagDef>> = LazyLock::new(|| {\n"
    );
    code.push_str("    let mut map = HashMap::new();\n");
    code.push_str("    for tag in EXIF_MAIN_TAGS {\n");
    code.push_str("        map.insert(tag.name, tag);\n");
    code.push_str("    }\n");
    code.push_str("    map\n");
    code.push_str("});\n\n");

    // Convenience functions
    code.push_str("/// Look up a tag definition by its ID\n");
    code.push_str("pub fn lookup_tag_by_id(id: u32) -> Option<&'static TagDef> {\n");
    code.push_str("    TAG_LOOKUP.get(&id).copied()\n");
    code.push_str("}\n\n");

    code.push_str("/// Look up a tag definition by its name\n");
    code.push_str("pub fn lookup_tag_by_name(name: &str) -> Option<&'static TagDef> {\n");
    code.push_str("    TAG_NAME_LOOKUP.get(name).copied()\n");
    code.push_str("}\n");

    // Write to file
    let output_path = format!("{}/tag_tables.rs", output_dir);
    fs::write(&output_path, code)?;

    println!("âœ… Generated {}", output_path);
    Ok(())
}