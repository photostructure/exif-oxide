//! Generator for EXIF tag tables (modularized)

use anyhow::Result;
use std::{collections::HashMap, fs};
use crate::schemas::GeneratedTag;
use crate::common::escape_string;
use tracing::debug;

/// Group categorization for tags
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum TagGroup {
    /// Core EXIF tags - groups: &["EXIF"]
    Core,
    /// Camera-specific tags - groups: &["Camera", "EXIF"]
    Camera,
    /// GPS-related tags - groups: &["GPS"]
    Gps,
    /// Time-related tags - groups: &["EXIF", "Time"]
    Time,
    /// Author/Copyright tags - groups: &["Author", "EXIF"]
    Author,
    /// Special/mixed group tags
    Special,
}

impl TagGroup {
    /// Get the filename for this group
    fn filename(&self) -> &str {
        match self {
            TagGroup::Core => "core",
            TagGroup::Camera => "camera",
            TagGroup::Gps => "gps",
            TagGroup::Time => "time",
            TagGroup::Author => "author",
            TagGroup::Special => "special",
        }
    }

    /// Get the description for this group
    fn description(&self) -> &str {
        match self {
            TagGroup::Core => "Core EXIF tags",
            TagGroup::Camera => "Camera-specific EXIF tags",
            TagGroup::Gps => "GPS-related tags",
            TagGroup::Time => "Time-related tags",
            TagGroup::Author => "Author and copyright tags",
            TagGroup::Special => "Special and mixed-group tags",
        }
    }

    /// Get the constant name for this group
    fn constant_name(&self) -> &str {
        match self {
            TagGroup::Core => "CORE_TAGS",
            TagGroup::Camera => "CAMERA_TAGS",
            TagGroup::Gps => "GPS_TAGS",
            TagGroup::Time => "TIME_TAGS",
            TagGroup::Author => "AUTHOR_TAGS",
            TagGroup::Special => "SPECIAL_TAGS",
        }
    }

    /// Categorize a tag based on its groups
    fn categorize_tag(tag: &GeneratedTag) -> TagGroup {
        let groups: Vec<&str> = tag.groups.iter().map(|s| s.as_str()).collect();
        
        match groups.as_slice() {
            ["EXIF"] => TagGroup::Core,
            ["Camera", "EXIF"] | ["EXIF", "Camera"] => TagGroup::Camera,
            ["GPS"] => TagGroup::Gps,
            ["EXIF", "Time"] | ["Time", "EXIF"] => TagGroup::Time,
            ["Author", "EXIF"] | ["EXIF", "Author"] => TagGroup::Author,
            _ => TagGroup::Special,
        }
    }
}

/// Generate EXIF tag table code in modular structure
pub fn generate_tag_table(tags: &[GeneratedTag], output_dir: &str) -> Result<()> {
    // Create tags directory
    let tags_dir = format!("{output_dir}/tags");
    fs::create_dir_all(&tags_dir)?;

    // Group tags by category
    let mut grouped_tags: HashMap<TagGroup, Vec<&GeneratedTag>> = HashMap::new();
    for tag in tags {
        let group = TagGroup::categorize_tag(tag);
        grouped_tags.entry(group).or_default().push(tag);
    }

    // Generate common types file
    generate_common_types(&tags_dir)?;

    // Generate individual group files
    for (group, group_tags) in &grouped_tags {
        generate_group_file(group, group_tags, &tags_dir)?;
    }

    // Generate mod.rs file that re-exports everything
    generate_tags_mod_file(&grouped_tags, &tags_dir)?;


    debug!("  ✓ Generated modular tags structure with {} groups", grouped_tags.len());
    Ok(())
}

/// Generate common types that are shared across all tag files
fn generate_common_types(tags_dir: &str) -> Result<()> {
    let mut code = String::new();

    // File header
    code.push_str("//! Common types for EXIF tag definitions\n");
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");

    // Format enum
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n");
    code.push_str("pub enum TagFormat {\n");
    code.push_str("    U8,\n");
    code.push_str("    U16,\n");
    code.push_str("    U32,\n");
    code.push_str("    I8,\n");
    code.push_str("    I16,\n");
    code.push_str("    I32,\n");
    code.push_str("    RationalU,\n");
    code.push_str("    RationalS,\n");
    code.push_str("    String,\n");
    code.push_str("    Undef,\n");
    code.push_str("    Float,\n");
    code.push_str("    Double,\n");
    code.push_str("}\n\n");

    // Tag structure
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub struct TagDef {\n");
    code.push_str("    pub id: u32,\n");
    code.push_str("    pub name: &'static str,\n");
    code.push_str("    pub format: TagFormat,\n");
    code.push_str("    pub groups: &'static [&'static str],\n");
    code.push_str("    pub writable: bool,\n");
    code.push_str("    pub description: Option<&'static str>,\n");
    code.push_str("    pub print_conv_ref: Option<&'static str>,\n");
    code.push_str("    pub value_conv_ref: Option<&'static str>,\n");
    code.push_str("    pub notes: Option<&'static str>,\n");
    code.push_str("}\n");

    // Write to file
    let output_path = format!("{tags_dir}/common.rs");
    fs::write(&output_path, code)?;

    debug!("  ✓ Generated {}", output_path);
    Ok(())
}

/// Generate a file for a specific tag group
fn generate_group_file(group: &TagGroup, tags: &[&GeneratedTag], tags_dir: &str) -> Result<()> {
    let mut code = String::new();

    // File header
    code.push_str(&format!("//! {}\n", group.description()));
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");

    code.push_str("use super::common::{TagDef, TagFormat};\n\n");

    // Static tag array
    code.push_str(&format!("/// {}\n", group.description()));
    code.push_str(&format!("pub static {}: &[TagDef] = &[\n", group.constant_name()));

    for tag in tags {
        generate_tag_definition(tag, &mut code);
    }

    code.push_str("];\n\n");

    // Write to file
    let output_path = format!("{}/{}.rs", tags_dir, group.filename());
    fs::write(&output_path, code)?;

    debug!("  ✓ Generated {}", output_path);
    Ok(())
}

/// Generate a single tag definition
fn generate_tag_definition(tag: &GeneratedTag, code: &mut String) {
    code.push_str("    TagDef {\n");
    code.push_str(&format!("        id: 0x{:x},\n", tag.id));
    code.push_str(&format!("        name: \"{}\",\n", tag.name));
    code.push_str(&format!("        format: TagFormat::{},\n", tag.format));

    // Groups array
    code.push_str("        groups: &[");
    for (i, group) in tag.groups.iter().enumerate() {
        if i > 0 {
            code.push_str(", ");
        }
        code.push_str(&format!("\"{group}\""));
    }
    code.push_str("],\n");

    code.push_str(&format!("        writable: {},\n", tag.writable));

    // Optional fields
    if let Some(desc) = &tag.description {
        code.push_str(&format!(
            "        description: Some(\"{}\"),\n",
            escape_string(desc)
        ));
    } else {
        code.push_str("        description: None,\n");
    }

    if let Some(pc) = &tag.print_conv_ref {
        code.push_str(&format!("        print_conv_ref: Some(\"{pc}\"),\n"));
    } else {
        code.push_str("        print_conv_ref: None,\n");
    }

    if let Some(vc) = &tag.value_conv_ref {
        code.push_str(&format!("        value_conv_ref: Some(\"{vc}\"),\n"));
    } else {
        code.push_str("        value_conv_ref: None,\n");
    }

    if let Some(notes) = &tag.notes {
        // Handle multi-line notes
        let formatted = notes
            .lines()
            .map(|line| line.trim())
            .collect::<Vec<_>>()
            .join(" ");
        code.push_str(&format!(
            "        notes: Some(\"{}\"),\n",
            escape_string(&formatted)
        ));
    } else {
        code.push_str("        notes: None,\n");
    }

    code.push_str("    },\n");
}

/// Generate mod.rs file that re-exports all groups
fn generate_tags_mod_file(grouped_tags: &HashMap<TagGroup, Vec<&GeneratedTag>>, tags_dir: &str) -> Result<()> {
    let mut code = String::new();

    // File header
    code.push_str("//! Modular EXIF tag definitions\n");
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");

    // Imports needed for lookup tables
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n\n");

    // Common types
    code.push_str("pub mod common;\n");
    code.push_str("pub use common::{TagDef, TagFormat};\n\n");

    // Group modules
    let mut sorted_groups: Vec<_> = grouped_tags.keys().collect();
    sorted_groups.sort_by_key(|g| g.filename());

    for group in &sorted_groups {
        code.push_str(&format!("pub mod {};\n", group.filename()));
    }
    code.push('\n');

    // Re-export all tags
    for group in &sorted_groups {
        code.push_str(&format!("pub use {}::{};\n", group.filename(), group.constant_name()));
    }
    code.push('\n');

    // Combined tag table
    code.push_str("/// Combined tag table from all groups\n");
    code.push_str("pub static ALL_TAGS: LazyLock<Vec<&'static TagDef>> = LazyLock::new(|| {\n");
    code.push_str("    let mut tags = Vec::new();\n");
    for group in &sorted_groups {
        code.push_str(&format!("    tags.extend({}.iter());\n", group.constant_name()));
    }
    code.push_str("    tags\n");
    code.push_str("});\n\n");

    // Unified lookup tables
    code.push_str("/// Unified lookup map from tag ID to tag definition\n");
    code.push_str("pub static TAG_LOOKUP: LazyLock<HashMap<u32, &'static TagDef>> = LazyLock::new(|| {\n");
    code.push_str("    let mut map = HashMap::new();\n");
    code.push_str("    for tag in ALL_TAGS.iter() {\n");
    code.push_str("        map.insert(tag.id, *tag);\n");
    code.push_str("    }\n");
    code.push_str("    map\n");
    code.push_str("});\n\n");

    code.push_str("/// Unified lookup map from tag name to tag definition\n");
    code.push_str("pub static TAG_NAME_LOOKUP: LazyLock<HashMap<&'static str, &'static TagDef>> = LazyLock::new(|| {\n");
    code.push_str("    let mut map = HashMap::new();\n");
    code.push_str("    for tag in ALL_TAGS.iter() {\n");
    code.push_str("        map.insert(tag.name, *tag);\n");
    code.push_str("    }\n");
    code.push_str("    map\n");
    code.push_str("});\n\n");

    // Convenience functions
    code.push_str("/// Look up a tag definition by its ID\n");
    code.push_str("pub fn lookup_tag_by_id(id: u32) -> Option<&'static TagDef> {\n");
    code.push_str("    TAG_LOOKUP.get(&id).copied()\n");
    code.push_str("}\n\n");

    code.push_str("/// Look up a tag definition by its name\n");
    code.push_str("pub fn lookup_tag_by_name(name: &str) -> Option<&'static TagDef> {\n");
    code.push_str("    TAG_NAME_LOOKUP.get(name).copied()\n");
    code.push_str("}\n\n");

    // Compatibility alias
    code.push_str("/// Backward compatibility alias for the combined tag table\n");
    code.push_str("pub static TAG_TABLE: LazyLock<Vec<TagDef>> = LazyLock::new(|| {\n");
    code.push_str("    ALL_TAGS.iter().map(|tag| (*tag).clone()).collect()\n");
    code.push_str("});\n");

    // Write to file
    let output_path = format!("{tags_dir}/mod.rs");
    fs::write(&output_path, code)?;

    debug!("  ✓ Generated {}", output_path);
    Ok(())
}

