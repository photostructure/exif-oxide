//! Modular tag kit generator that splits output into smaller files
//!
//! This generator creates tag definitions split by category to keep file sizes manageable

use anyhow::Result;
use std::fs;
use std::collections::HashMap;
use crate::common::escape_string;
use crate::schemas::tag_kit::{TagKitExtraction, TagKit, ExtractedTable};
use super::tag_kit_split::split_tag_kits;

/// Generate modular tag kit code from extracted data
pub fn generate_modular_tag_kit(
    extraction: &TagKitExtraction,
    output_dir: &str,
    module_name: &str,
) -> Result<()> {
    // Create output directory for tag kit modules 
    // Create tag_kit subdirectory inside the output directory
    let tag_kit_dir = format!("{output_dir}/tag_kit");
    fs::create_dir_all(&tag_kit_dir)?;
    
    // Split tag kits by category
    let categories = split_tag_kits(&extraction.tag_kits);
    
    // Keep track of all generated modules
    let mut generated_modules = Vec::new();
    let mut total_print_conv_count = 0;
    
    // Collect all subdirectory information
    let subdirectory_info = collect_subdirectory_info(&extraction.tag_kits);
    
    // Generate a module for each category with tags
    for (category, tag_kits) in &categories {
        if tag_kits.is_empty() {
            continue;
        }
        
        let module_name_cat = category.module_name();
        let (module_code, print_conv_count) = generate_category_module(
            module_name_cat,
            tag_kits,
            &extraction.source,
            &mut total_print_conv_count,
        )?;
        
        // Write category module
        let file_path = format!("{tag_kit_dir}/{module_name_cat}.rs");
        fs::write(&file_path, module_code)?;
        
        generated_modules.push(module_name_cat);
        
        println!("  ✓ Generated {} with {} tags, {} PrintConv tables",
            module_name_cat,
            tag_kits.len(),
            print_conv_count
        );
    }
    
    // Generate mod.rs that combines all modules and subdirectory processors
    let mod_code = generate_mod_file(&generated_modules, module_name, extraction, &subdirectory_info)?;
    fs::write(format!("{tag_kit_dir}/mod.rs"), mod_code)?;
    
    // Summary
    println!("  ✓ Generated modular tag kit for {} with {} tags split into {} modules", 
        module_name,
        extraction.tag_kits.len(),
        generated_modules.len()
    );
    
    Ok(())
}

/// Generate code for a single category module
fn generate_category_module(
    category_name: &str,
    tag_kits: &[&TagKit],
    source: &crate::schemas::tag_kit::SourceInfo,
    print_conv_counter: &mut usize,
) -> Result<(String, usize)> {
    let mut code = String::new();
    
    // Header with warning suppression at the top
    code.push_str(&format!("//! Tag kits for {} category from {}\n", category_name, source.module));
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");
    code.push_str("#![allow(unused_imports)]\n");
    code.push_str("#![allow(unused_mut)]\n");
    code.push_str("#![allow(dead_code)]\n");
    code.push_str("#![allow(unused_variables)]\n\n");
    
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n");
    code.push_str("use crate::types::TagValue;\n");
    code.push_str("use super::{TagKitDef, PrintConvType, SubDirectoryType};\n");
    // Import subdirectory processor functions from parent module
    code.push_str("use super::*;\n\n");
    
    // Generate PrintConv lookup tables for this category
    let mut local_print_conv_count = 0;
    for tag_kit in tag_kits {
        tracing::debug!("Processing tag '{}' with print_conv_type='{}'", tag_kit.name, tag_kit.print_conv_type);
        if tag_kit.print_conv_type == "Simple" {
            tracing::debug!("Found Simple PrintConv for tag '{}'", tag_kit.name);
            if let Some(print_conv_data) = &tag_kit.print_conv_data {
                tracing::debug!("PrintConv data exists for tag '{}'", tag_kit.name);
                if let Some(data_obj) = print_conv_data.as_object() {
                    tracing::debug!("PrintConv data is an object with {} entries", data_obj.len());
                    let const_name = format!("PRINT_CONV_{}", *print_conv_counter);
                    *print_conv_counter += 1;
                    local_print_conv_count += 1;
                    
                    code.push_str(&format!("static {const_name}: LazyLock<HashMap<String, &'static str>> = LazyLock::new(|| {{\n"));
                    code.push_str("    let mut map = HashMap::new();\n");
                    
                    // Sort keys for deterministic output
                    let mut sorted_keys: Vec<&String> = data_obj.keys().collect();
                    sorted_keys.sort();
                    
                    for key in sorted_keys {
                        let value = &data_obj[key];
                        tracing::debug!("Processing PrintConv entry: key='{}', value={:?}", key, value);
                        crate::generators::lookup_tables::generate_print_conv_entry(&mut code, key, value);
                    }
                    
                    code.push_str("    map\n");
                    code.push_str("});\n\n");
                }
            }
        }
    }
    
    // Generate tag definitions function
    code.push_str(&format!("/// Get tag definitions for {category_name} category\n"));
    code.push_str(&format!("pub fn get_{category_name}_tags() -> Vec<(u32, TagKitDef)> {{\n"));
    code.push_str("    vec![\n");
    
    // Reset print conv counter for this category
    let mut category_print_conv_index = *print_conv_counter - local_print_conv_count;
    
    for tag_kit in tag_kits {
        let tag_id = tag_kit.tag_id.parse::<u32>().unwrap_or(0);
        
        code.push_str(&format!("        ({tag_id}, TagKitDef {{\n"));
        code.push_str(&format!("            id: {tag_id},\n"));
        code.push_str(&format!("            name: \"{}\",\n", escape_string(&tag_kit.name)));
        code.push_str(&format!("            format: \"{}\",\n", escape_string(&tag_kit.format)));
        
        // Groups (currently empty in extraction)
        code.push_str("            groups: HashMap::new(),\n");
        
        // Writable
        code.push_str(&format!("            writable: {},\n", 
            if tag_kit.writable.is_some() { "true" } else { "false" }));
        
        // Notes
        if let Some(notes) = &tag_kit.notes {
            let trimmed_notes = notes.trim();
            code.push_str(&format!("            notes: Some(\"{}\"),\n", escape_string(trimmed_notes)));
        } else {
            code.push_str("            notes: None,\n");
        }
        
        // PrintConv
        match tag_kit.print_conv_type.as_str() {
            "Simple" => {
                if tag_kit.print_conv_data.is_some() {
                    code.push_str(&format!("            print_conv: PrintConvType::Simple(&PRINT_CONV_{category_print_conv_index}),\n"));
                    category_print_conv_index += 1;
                } else {
                    code.push_str("            print_conv: PrintConvType::None,\n");
                }
            }
            "Expression" => {
                if let Some(expr_data) = &tag_kit.print_conv_data {
                    if let Some(expr_str) = expr_data.as_str() {
                        code.push_str(&format!("            print_conv: PrintConvType::Expression(\"{}\"),\n", 
                            escape_string(expr_str)));
                    } else {
                        code.push_str("            print_conv: PrintConvType::Expression(\"unknown\"),\n");
                    }
                } else {
                    code.push_str("            print_conv: PrintConvType::Expression(\"unknown\"),\n");
                }
            }
            "Manual" => {
                if let Some(func_name) = &tag_kit.print_conv_data {
                    if let Some(name_str) = func_name.as_str() {
                        code.push_str(&format!("            print_conv: PrintConvType::Manual(\"{}\"),\n", 
                            escape_string(name_str)));
                    } else {
                        code.push_str("            print_conv: PrintConvType::Manual(\"unknown\"),\n");
                    }
                } else {
                    code.push_str("            print_conv: PrintConvType::Manual(\"unknown\"),\n");
                }
            }
            _ => {
                code.push_str("            print_conv: PrintConvType::None,\n");
            }
        }
        
        // ValueConv
        if let Some(value_conv) = &tag_kit.value_conv {
            code.push_str(&format!("            value_conv: Some(\"{}\"),\n", escape_string(value_conv)));
        } else {
            code.push_str("            value_conv: None,\n");
        }
        
        // Add subdirectory field
        if tag_kit.subdirectory.is_some() {
            code.push_str(&format!("            subdirectory: Some(SubDirectoryType::Binary {{ processor: process_tag_{:#x}_subdirectory }}),\n", tag_id));
        } else {
            code.push_str("            subdirectory: None,\n");
        }
        
        code.push_str("        }),\n");
    }
    
    code.push_str("    ]\n");
    code.push_str("}\n");
    
    Ok((code, local_print_conv_count))
}

/// Generate the mod.rs file that combines all category modules
fn generate_mod_file(
    modules: &[&str], 
    module_name: &str,
    extraction: &TagKitExtraction,
    subdirectory_info: &HashMap<u32, SubDirectoryCollection>,
) -> Result<String> {
    let mut code = String::new();
    
    // Header
    code.push_str(&format!("//! Modular tag kits with embedded PrintConv for {module_name}\n"));
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n");
    code.push_str("//!\n");
    code.push_str(&format!("//! Generated from: {} table: {}\n", extraction.source.module, extraction.source.table));
    code.push_str("//!\n");
    // NOTE: Do NOT add extraction timestamps here - they create spurious git diffs
    // that make it impossible to track real changes to generated code
    
    code.push_str("#![allow(unused_imports)]\n");
    code.push_str("#![allow(unused_mut)]\n");
    code.push_str("#![allow(dead_code)]\n");
    code.push_str("#![allow(unused_variables)]\n\n");
    
    // Module declarations (sorted for deterministic output)
    let mut sorted_modules: Vec<&str> = modules.iter().map(|s| s.as_ref()).collect();
    sorted_modules.sort();
    
    for module in sorted_modules {
        code.push_str(&format!("pub mod {module};\n"));
    }
    code.push('\n');
    
    // Common imports
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n");
    code.push_str("use crate::types::{TagValue, Result};\n");
    code.push_str("use crate::tiff_types::ByteOrder;\n");
    code.push_str("use crate::expressions::ExpressionEvaluator;\n\n");
    
    // Tag kit definition struct
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub struct TagKitDef {\n");
    code.push_str("    pub id: u32,\n");
    code.push_str("    pub name: &'static str,\n");
    code.push_str("    pub format: &'static str,\n");
    code.push_str("    pub groups: HashMap<&'static str, &'static str>,\n");
    code.push_str("    pub writable: bool,\n");
    code.push_str("    pub notes: Option<&'static str>,\n");
    code.push_str("    pub print_conv: PrintConvType,\n");
    code.push_str("    pub value_conv: Option<&'static str>,\n");
    code.push_str("    pub subdirectory: Option<SubDirectoryType>,\n");
    code.push_str("}\n\n");
    
    // PrintConv type enum
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub enum PrintConvType {\n");
    code.push_str("    None,\n");
    code.push_str("    Simple(&'static HashMap<String, &'static str>),\n");
    code.push_str("    Expression(&'static str),\n");
    code.push_str("    Manual(&'static str),\n");
    code.push_str("}\n\n");
    
    // Type alias to fix clippy::type_complexity warning
    code.push_str("/// Type alias for subdirectory processor function\n");
    code.push_str("pub type SubDirectoryProcessor = fn(&[u8], ByteOrder) -> Result<Vec<(String, TagValue)>>;\n\n");
    
    // SubDirectory type enum
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub enum SubDirectoryType {\n");
    code.push_str("    Binary {\n");
    code.push_str("        processor: SubDirectoryProcessor,\n");
    code.push_str("    },\n");
    code.push_str("}\n\n");
    
    // Combined tag map
    let const_name = format!("{}_TAG_KITS", module_name.to_uppercase());
    code.push_str(&format!("/// All tag kits for {module_name}\n"));
    code.push_str(&format!("pub static {const_name}: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {{\n"));
    code.push_str("    let mut map = HashMap::new();\n");
    code.push_str("    \n");
    
    // Add tags from each module (sorted for deterministic output)
    let mut sorted_modules: Vec<&str> = modules.iter().map(|s| s.as_ref()).collect();
    sorted_modules.sort();
    
    for module in sorted_modules {
        code.push_str(&format!("    // {module} tags\n"));
        code.push_str(&format!("    for (id, tag_def) in {module}::get_{module}_tags() {{\n"));
        code.push_str("        map.insert(id, tag_def);\n");
        code.push_str("    }\n");
        code.push_str("    \n");
    }
    
    code.push_str("    map\n");
    code.push_str("});\n\n");
    
    // Generate binary data helper functions
    code.push_str("// Helper functions for reading binary data\n");
    code.push_str("fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {\n");
    code.push_str("    if data.len() < count * 2 {\n");
    code.push_str("        return Err(crate::types::ExifError::ParseError(\"Insufficient data for int16s array\".to_string()));\n");
    code.push_str("    }\n");
    code.push_str("    let mut values = Vec::with_capacity(count);\n");
    code.push_str("    for i in 0..count {\n");
    code.push_str("        let offset = i * 2;\n");
    code.push_str("        let value = match byte_order {\n");
    code.push_str("            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),\n");
    code.push_str("            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),\n");
    code.push_str("        };\n");
    code.push_str("        values.push(value);\n");
    code.push_str("    }\n");
    code.push_str("    Ok(values)\n");
    code.push_str("}\n\n");
    
    code.push_str("fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {\n");
    code.push_str("    if data.len() < count * 2 {\n");
    code.push_str("        return Err(crate::types::ExifError::ParseError(\"Insufficient data for int16u array\".to_string()));\n");
    code.push_str("    }\n");
    code.push_str("    let mut values = Vec::with_capacity(count);\n");
    code.push_str("    for i in 0..count {\n");
    code.push_str("        let offset = i * 2;\n");
    code.push_str("        let value = match byte_order {\n");
    code.push_str("            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),\n");
    code.push_str("            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),\n");
    code.push_str("        };\n");
    code.push_str("        values.push(value);\n");
    code.push_str("    }\n");
    code.push_str("    Ok(values)\n");
    code.push_str("}\n\n");
    
    code.push_str("fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {\n");
    code.push_str("    if data.len() < 2 {\n");
    code.push_str("        return Err(crate::types::ExifError::ParseError(\"Insufficient data for int16s\".to_string()));\n");
    code.push_str("    }\n");
    code.push_str("    Ok(match byte_order {\n");
    code.push_str("        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),\n");
    code.push_str("        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),\n");
    code.push_str("    })\n");
    code.push_str("}\n\n");
    
    // Generate subdirectory processing functions
    if !subdirectory_info.is_empty() {
        code.push_str("// Subdirectory processing functions\n");
        
        // Generate binary data parsers for each unique subdirectory table
        let mut generated_tables = std::collections::BTreeSet::new();
        
        // Sort subdirectory collections by tag_id for deterministic output
        let mut sorted_collections: Vec<(&u32, &SubDirectoryCollection)> = subdirectory_info.iter().collect();
        sorted_collections.sort_by_key(|(tag_id, _)| *tag_id);
        
        for (_, collection) in sorted_collections {
            for variant in &collection.variants {
                if variant.is_binary_data {
                    if let Some(extracted_table) = &variant.extracted_table {
                        let table_fn_name = variant.table_name
                            .replace("Image::ExifTool::", "")
                            .replace("::", "_")
                            .to_lowercase();
                        
                        if generated_tables.insert(table_fn_name.clone()) {
                            generate_binary_parser(&mut code, &table_fn_name, extracted_table)?;
                        }
                    }
                }
            }
        }
        
        // Generate conditional dispatch functions for tags with subdirectories
        // Sort by tag_id for deterministic output
        let mut sorted_subdirs: Vec<(&u32, &SubDirectoryCollection)> = subdirectory_info.iter().collect();
        sorted_subdirs.sort_by_key(|(tag_id, _)| *tag_id);
        
        for (tag_id, collection) in sorted_subdirs {
            generate_subdirectory_dispatcher(&mut code, *tag_id, collection)?;
        }
    }
    
    // Apply PrintConv function (backward compatible - subdirectories return raw data)
    code.push_str("/// Apply PrintConv for a tag from this module\n");
    code.push_str("pub fn apply_print_conv(\n");
    code.push_str("    tag_id: u32,\n");
    code.push_str("    value: &TagValue,\n");
    code.push_str("    _evaluator: &mut ExpressionEvaluator,\n");
    code.push_str("    _errors: &mut Vec<String>,\n");
    code.push_str("    warnings: &mut Vec<String>,\n");
    code.push_str(") -> TagValue {\n");
    code.push_str(&format!("    if let Some(tag_kit) = {const_name}.get(&tag_id) {{\n"));
    code.push_str("        // Normal PrintConv processing only\n");
    code.push_str("        match &tag_kit.print_conv {\n");
    code.push_str("            PrintConvType::None => value.clone(),\n");
    code.push_str("            PrintConvType::Simple(lookup) => {\n");
    code.push_str("                // Convert value to string key for lookup\n");
    code.push_str("                let key = match value {\n");
    code.push_str("                    TagValue::U8(v) => v.to_string(),\n");
    code.push_str("                    TagValue::U16(v) => v.to_string(),\n");
    code.push_str("                    TagValue::U32(v) => v.to_string(),\n");
    code.push_str("                    TagValue::I16(v) => v.to_string(),\n");
    code.push_str("                    TagValue::I32(v) => v.to_string(),\n");
    code.push_str("                    TagValue::String(s) => s.clone(),\n");
    code.push_str("                    _ => return value.clone(),\n");
    code.push_str("                };\n");
    code.push_str("                \n");
    code.push_str("                if let Some(result) = lookup.get(&key) {\n");
    code.push_str("                    TagValue::String(result.to_string())\n");
    code.push_str("                } else {\n");
    code.push_str("                    TagValue::String(format!(\"Unknown ({})\", value))\n");
    code.push_str("                }\n");
    code.push_str("            }\n");
    code.push_str("            PrintConvType::Expression(expr) => {\n");
    code.push_str("                // TODO: Implement expression evaluation\n");
    code.push_str("                warnings.push(format!(\"Expression PrintConv not yet implemented for tag {}: {}\", \n");
    code.push_str("                    tag_kit.name, expr));\n");
    code.push_str("                value.clone()\n");
    code.push_str("            }\n");
    code.push_str("            PrintConvType::Manual(func_name) => {\n");
    code.push_str("                // TODO: Look up in manual registry\n");
    code.push_str("                warnings.push(format!(\"Manual PrintConv '{}' not found for tag {}\", \n");
    code.push_str("                    func_name, tag_kit.name));\n");
    code.push_str("                value.clone()\n");
    code.push_str("            }\n");
    code.push_str("        }\n");
    code.push_str("    } else {\n");
    code.push_str("        // Tag not found in kit\n");
    code.push_str("        value.clone()\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    // Add subdirectory processing functions
    code.push_str("/// Check if a tag has subdirectory processing\n");
    code.push_str("pub fn has_subdirectory(tag_id: u32) -> bool {\n");
    code.push_str(&format!("    if let Some(tag_kit) = {const_name}.get(&tag_id) {{\n"));
    code.push_str("        tag_kit.subdirectory.is_some()\n");
    code.push_str("    } else {\n");
    code.push_str("        false\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    code.push_str("/// Process subdirectory tags and return multiple extracted tags\n");
    code.push_str("pub fn process_subdirectory(\n");
    code.push_str("    tag_id: u32,\n");
    code.push_str("    value: &TagValue,\n");
    code.push_str("    byte_order: ByteOrder,\n");
    code.push_str(") -> Result<HashMap<String, TagValue>> {\n");
    code.push_str("    use tracing::debug;\n");
    code.push_str("    let mut result = HashMap::new();\n");
    code.push_str("    \n");
    code.push_str("    debug!(\"process_subdirectory called for tag_id: 0x{:04x}\", tag_id);\n");
    code.push_str("    \n");
    code.push_str(&format!("    if let Some(tag_kit) = {const_name}.get(&tag_id) {{\n"));
    code.push_str("        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {\n");
    code.push_str("            debug!(\"Found subdirectory processor for tag_id: 0x{:04x}\", tag_id);\n");
    code.push_str("            let bytes = match value {\n");
    code.push_str("                TagValue::U16Array(arr) => {\n");
    code.push_str("                    debug!(\"Converting U16Array with {} elements to bytes\", arr.len());\n");
    code.push_str("                    // Convert U16 array to bytes based on byte order\n");
    code.push_str("                    let mut bytes = Vec::with_capacity(arr.len() * 2);\n");
    code.push_str("                    for val in arr {\n");
    code.push_str("                        match byte_order {\n");
    code.push_str("                            ByteOrder::LittleEndian => bytes.extend_from_slice(&val.to_le_bytes()),\n");
    code.push_str("                            ByteOrder::BigEndian => bytes.extend_from_slice(&val.to_be_bytes()),\n");
    code.push_str("                        }\n");
    code.push_str("                    }\n");
    code.push_str("                    bytes\n");
    code.push_str("                }\n");
    code.push_str("                TagValue::U8Array(arr) => arr.clone(),\n");
    code.push_str("                _ => return Ok(result), // Not array data\n");
    code.push_str("            };\n");
    code.push_str("            \n");
    code.push_str("            debug!(\"Calling processor with {} bytes\", bytes.len());\n");
    code.push_str("            // Process subdirectory and collect all extracted tags\n");
    code.push_str("            match processor(&bytes, byte_order) {\n");
    code.push_str("                Ok(extracted_tags) => {\n");
    code.push_str("                    debug!(\"Processor returned {} tags\", extracted_tags.len());\n");
    code.push_str("                    for (name, value) in extracted_tags {\n");
    code.push_str("                        result.insert(name, value);\n");
    code.push_str("                    }\n");
    code.push_str("                }\n");
    code.push_str("                Err(e) => {\n");
    code.push_str("                    debug!(\"Processor error: {:?}\", e);\n");
    code.push_str("                }\n");
    code.push_str("            }\n");
    code.push_str("        } else {\n");
    code.push_str("            debug!(\"No subdirectory processor found for tag_id: 0x{:04x}\", tag_id);\n");
    code.push_str("        }\n");
    code.push_str("    } else {\n");
    code.push_str("        debug!(\"Tag not found in TAG_KITS: 0x{:04x}\", tag_id);\n");
    code.push_str("    }\n");
    code.push_str("    \n");
    code.push_str("    Ok(result)\n");
    code.push_str("}\n");
    
    Ok(code)
}

/// Information about a subdirectory and all its variants
#[derive(Debug)]
struct SubDirectoryCollection {
    tag_id: u32,
    tag_name: String,
    variants: Vec<SubDirectoryVariant>,
}

#[derive(Debug, Clone)]
struct SubDirectoryVariant {
    variant_id: String,
    condition: Option<String>,
    table_name: String,
    is_binary_data: bool,
    extracted_table: Option<ExtractedTable>,
}

/// Collect all subdirectory information from tag kits
fn collect_subdirectory_info(tag_kits: &[TagKit]) -> HashMap<u32, SubDirectoryCollection> {
    let mut subdirectory_map: HashMap<u32, SubDirectoryCollection> = HashMap::new();
    
    for tag_kit in tag_kits {
        if let Some(subdirectory) = &tag_kit.subdirectory {
            let tag_id = tag_kit.tag_id.parse::<u32>().unwrap_or(0);
            
            let variant = SubDirectoryVariant {
                variant_id: tag_kit.variant_id.clone().unwrap_or_else(|| format!("{}_default", tag_id)),
                condition: tag_kit.condition.clone(),
                table_name: subdirectory.tag_table.clone(),
                is_binary_data: subdirectory.is_binary_data.unwrap_or(false),
                extracted_table: subdirectory.extracted_table.clone(),
            };
            
            subdirectory_map
                .entry(tag_id)
                .and_modify(|collection| collection.variants.push(variant.clone()))
                .or_insert_with(|| SubDirectoryCollection {
                    tag_id,
                    tag_name: tag_kit.name.clone(),
                    variants: vec![variant],
                });
        }
    }
    
    subdirectory_map
}

/// Generate a binary data parser function for a subdirectory table
/// 
/// CRITICAL: ExifTool Binary Data Offset Handling
/// ===============================================
/// ExifTool allows NEGATIVE tag offsets in binary data tables!
/// 
/// Reference: ExifTool.pm lines 9830-9836 (ProcessBinaryData function)
/// ```perl
/// # get relative offset of this entry
/// my $entry = int($index) * $increment + $varSize;
/// # allow negative indices to represent bytes from end
/// if ($entry < 0) {
///     $entry += $size;
///     next if $entry < 0;
/// }
/// ```
/// 
/// This means:
/// - Tag offsets can be LESS than FIRST_ENTRY (e.g., offset 0 with FIRST_ENTRY = 1)
/// - Negative offsets are interpreted as offsets from END of data block
/// - Example: offset -2 means "2 bytes before end of data"
/// 
/// FOOTGUN WARNING: Using unsigned arithmetic here will cause wraparound!
/// A calculation like (0 - 1) * 2 = -2 becomes 18446744073709551614 in usize.
/// This creates absurd comparisons like "if data.len() >= 18446744073709551615"
fn generate_binary_parser(code: &mut String, fn_name: &str, table: &ExtractedTable) -> Result<()> {
    code.push_str(&format!("fn process_{}(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {{\n", fn_name));
    code.push_str("    let mut tags = Vec::new();\n");
    
    // Get the format size multiplier
    let format_size = match table.format.as_deref() {
        Some("int16s") | Some("int16u") => 2,
        Some("int32s") | Some("int32u") => 4,
        Some("int8s") | Some("int8u") => 1,
        _ => 2, // Default to int16
    };
    
    let first_entry = table.first_entry.unwrap_or(0);
    
    // Generate tag extraction code for each tag in the table
    for tag in &table.tags {
        // CRITICAL: Parse as i32 to handle negative offsets properly!
        let tag_offset = tag.tag_id.parse::<i32>().unwrap_or(0);
        // CRITICAL: Keep as signed to detect negative offsets
        let byte_offset = (tag_offset - first_entry) * format_size;
        
        code.push_str(&format!("    // {} at offset {}\n", tag.name, tag.tag_id));
        
        // Handle negative offsets (from end of data) like ExifTool does
        let offset_var_name = tag.name.to_lowercase().replace(' ', "_").replace('-', "_");
        if byte_offset < 0 {
            // For negative offsets, we need to generate runtime calculation
            code.push_str(&format!("    // {} uses negative offset {} (from end of data)\n", tag.name, byte_offset));
            code.push_str(&format!("    if data.len() as i32 + {} < 0 {{\n", byte_offset));
            code.push_str(&format!("        // Skipping {} - negative offset beyond data start\n", tag.name));
            code.push_str("        // (This is normal for some tables)\n");
            code.push_str("    } else {\n");
            code.push_str(&format!("        let {}_offset = (data.len() as i32 + {}) as usize;\n", 
                offset_var_name, byte_offset));
            // Set indent for the tag processing code
            code.push_str("        ");
        } else {
            // For positive offsets, use direct value
            let _byte_offset_usize = byte_offset as usize;
            // No extra indent needed
        }
        
        if let Some(format) = &tag.format {
            if format.ends_with(']') {
                // Array format like "int16s[4]"
                if let Some(array_start) = format.find('[') {
                    let base_format = &format[..array_start];
                    let count_str = &format[array_start + 1..format.len() - 1];
                    if let Ok(count) = count_str.parse::<usize>() {
                        let total_size = match base_format {
                            "int16s" | "int16u" => 2 * count,
                            "int32s" | "int32u" => 4 * count,
                            "int8s" | "int8u" => count,
                            _ => 2 * count,
                        };
                        
                        // Generate bounds check based on offset type
                        if byte_offset < 0 {
                            code.push_str(&format!("if {}_offset + {} <= data.len() {{\n", offset_var_name, total_size));
                        } else {
                            code.push_str(&format!("    if data.len() >= {} {{\n", byte_offset as usize + total_size));
                        }
                        
                        match base_format {
                            "int16s" => {
                                if byte_offset < 0 {
                                    code.push_str(&format!("            if let Ok(values) = read_int16s_array(&data[{}_offset..{}_offset + {}], byte_order, {}) {{\n", 
                                        offset_var_name, offset_var_name, total_size, count));
                                } else {
                                    code.push_str(&format!("        if let Ok(values) = read_int16s_array(&data[{}..{}], byte_order, {}) {{\n", 
                                        byte_offset as usize, byte_offset as usize + total_size, count));
                                }
                                code.push_str("            let value_str = values.iter().map(|v| v.to_string()).collect::<Vec<_>>().join(\" \");\n");
                                code.push_str(&format!("            tags.push((\"{}\".to_string(), TagValue::String(value_str)));\n", tag.name));
                                code.push_str("        }\n");
                            }
                            "int16u" => {
                                if byte_offset < 0 {
                                    code.push_str(&format!("            if let Ok(values) = read_int16u_array(&data[{}_offset..{}_offset + {}], byte_order, {}) {{\n", 
                                        offset_var_name, offset_var_name, total_size, count));
                                } else {
                                    code.push_str(&format!("        if let Ok(values) = read_int16u_array(&data[{}..{}], byte_order, {}) {{\n", 
                                        byte_offset as usize, byte_offset as usize + total_size, count));
                                }
                                code.push_str("            let value_str = values.iter().map(|v| v.to_string()).collect::<Vec<_>>().join(\" \");\n");
                                code.push_str(&format!("            tags.push((\"{}\".to_string(), TagValue::String(value_str)));\n", tag.name));
                                code.push_str("        }\n");
                            }
                            _ => {
                                // For other formats, just store the raw offset for now
                                code.push_str(&format!("        // TODO: Handle format {}\n", base_format));
                            }
                        }
                        
                        code.push_str("    }\n");
                        // Close the negative offset check if needed
                        if byte_offset < 0 {
                            code.push_str("    }\n");
                        }
                    }
                }
            } else {
                // Single value format
                let value_size = match format.as_str() {
                    "int16s" | "int16u" => 2,
                    "int32s" | "int32u" => 4,
                    "int8s" | "int8u" => 1,
                    _ => 2,
                };
                
                // Generate bounds check based on offset type
                if byte_offset < 0 {
                    code.push_str(&format!("if {}_offset + {} <= data.len() {{\n", offset_var_name, value_size));
                } else {
                    code.push_str(&format!("    if data.len() >= {} {{\n", byte_offset as usize + value_size));
                }
                
                match format.as_str() {
                    "int16s" => {
                        if byte_offset < 0 {
                            code.push_str(&format!("            if let Ok(value) = read_int16s(&data[{}_offset..{}_offset + {}], byte_order) {{\n", 
                                offset_var_name, offset_var_name, value_size));
                        } else {
                            code.push_str(&format!("        if let Ok(value) = read_int16s(&data[{}..{}], byte_order) {{\n", 
                                byte_offset as usize, byte_offset as usize + value_size));
                        }
                        code.push_str(&format!("            tags.push((\"{}\".to_string(), TagValue::I16(value)));\n", tag.name));
                        code.push_str("        }\n");
                    }
                    _ => {
                        // For other formats, just store the raw offset for now
                        code.push_str(&format!("        // TODO: Handle format {}\n", format));
                    }
                }
                
                code.push_str("    }\n");
                // Close the negative offset check if needed
                if byte_offset < 0 {
                    code.push_str("    }\n");
                }
            }
        } else {
            // No format specified - close negative offset block if needed
            if byte_offset < 0 {
                code.push_str("    }\n");
            }
        }
        
        code.push_str("    \n");
    }
    
    code.push_str("    Ok(tags)\n");
    code.push_str("}\n\n");
    
    Ok(())
}

/// Parse count conditions including OR operators
/// Handles:
/// - Simple: "$count == 582"
/// - OR: "$count == 1273 or $count == 1275"
/// - Perl OR: "$count == 1536 || $count == 2048"
/// - Multi-line: "$count == 692 or $count == 674 or $count == 702"
fn parse_count_conditions(condition: &str) -> Vec<usize> {
    let mut counts = Vec::new();
    
    // Normalize both "or" and "||" to a common separator
    let normalized = condition
        .replace("||", " or ")
        .replace('\n', " ");
    
    // Split on " or " and process each part
    for part in normalized.split(" or ") {
        let trimmed = part.trim();
        if trimmed.is_empty() {
            continue;
        }
        
        // Look for "== number" pattern
        if let Some(eq_pos) = trimmed.find("==") {
            let count_str = trimmed[eq_pos + 2..].trim();
            if let Ok(count) = count_str.parse::<usize>() {
                counts.push(count);
            }
        }
    }
    
    counts
}

/// Generate a conditional dispatch function for a tag with subdirectory variants
fn generate_subdirectory_dispatcher(code: &mut String, tag_id: u32, collection: &SubDirectoryCollection) -> Result<()> {
    code.push_str(&format!("pub fn process_tag_{:#x}_subdirectory(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {{\n", tag_id));
    code.push_str("    use tracing::debug;\n");
    
    // Determine the format for count calculation (usually int16s for Canon)
    let format_size = 2; // Default to int16s
    code.push_str(&format!("    let count = data.len() / {};\n", format_size));
    code.push_str(&format!("    debug!(\"process_tag_{:#x}_subdirectory called with {{}} bytes, count={{}}\", data.len(), count);\n", tag_id));
    code.push_str("    \n");
    code.push_str("    match count {\n");
    
    for variant in &collection.variants {
        if let Some(condition) = &variant.condition {
            // Use the new parser for count conditions
            let counts = parse_count_conditions(condition);
            
            if !counts.is_empty() {
                let table_fn_name = variant.table_name
                    .replace("Image::ExifTool::", "")
                    .replace("::", "_")
                    .to_lowercase();
                
                // Generate a match arm for each count value
                for count_val in counts {
                    code.push_str(&format!("        {} => {{\n", count_val));
                    code.push_str(&format!("            debug!(\"Matched count {} for variant {}\");\n", count_val, table_fn_name));
                    code.push_str(&format!("            process_{}(data, byte_order)\n", table_fn_name));
                    code.push_str("        }\n");
                }
            }
        }
    }
    
    code.push_str("        _ => Ok(vec![]), // Unknown variant\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    Ok(())
}