//! Modular tag kit generator that splits output into smaller files
//!
//! This generator creates tag definitions split by category to keep file sizes manageable

use anyhow::Result;
use std::fs;
use crate::common::escape_string;
use crate::schemas::tag_kit::{TagKitExtraction, TagKit};
use super::tag_kit_split::split_tag_kits;

/// Generate modular tag kit code from extracted data
#[allow(dead_code)]
pub fn generate_modular_tag_kit(
    extraction: &TagKitExtraction,
    output_dir: &str,
    module_name: &str,
) -> Result<()> {
    // Create output directory for tag kit modules 
    // Replace any hyphens with underscores for valid Rust module names
    let sanitized_module_name = module_name.to_lowercase().replace('-', "_");
    let tag_kit_dir = format!("{output_dir}/{sanitized_module_name}_tag_kit");
    fs::create_dir_all(&tag_kit_dir)?;
    
    // Split tag kits by category
    let categories = split_tag_kits(&extraction.tag_kits);
    
    // Keep track of all generated modules
    let mut generated_modules = Vec::new();
    let mut total_print_conv_count = 0;
    
    // Generate a module for each category with tags
    for (category, tag_kits) in &categories {
        if tag_kits.is_empty() {
            continue;
        }
        
        let module_name_cat = category.module_name();
        let (module_code, print_conv_count) = generate_category_module(
            module_name_cat,
            tag_kits,
            &extraction.source,
            &mut total_print_conv_count,
        )?;
        
        // Write category module
        let file_path = format!("{tag_kit_dir}/{module_name_cat}.rs");
        fs::write(&file_path, module_code)?;
        
        generated_modules.push(module_name_cat);
        
        println!("  ✓ Generated {} with {} tags, {} PrintConv tables",
            module_name_cat,
            tag_kits.len(),
            print_conv_count
        );
    }
    
    // Generate mod.rs that combines all modules
    let mod_code = generate_mod_file(&generated_modules, &sanitized_module_name, extraction)?;
    fs::write(format!("{tag_kit_dir}/mod.rs"), mod_code)?;
    
    // Summary
    println!("  ✓ Generated modular tag kit for {} with {} tags split into {} modules", 
        module_name,
        extraction.tag_kits.len(),
        generated_modules.len()
    );
    
    Ok(())
}

/// Generate code for a single category module
#[allow(dead_code)]
fn generate_category_module(
    category_name: &str,
    tag_kits: &[&TagKit],
    source: &crate::schemas::tag_kit::SourceInfo,
    print_conv_counter: &mut usize,
) -> Result<(String, usize)> {
    let mut code = String::new();
    
    // Header with warning suppression at the top
    code.push_str(&format!("//! Tag kits for {} category from {}\n", category_name, source.module));
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");
    code.push_str("#![allow(unused_imports)]\n");
    code.push_str("#![allow(unused_mut)]\n\n");
    
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n");
    code.push_str("use crate::types::TagValue;\n");
    code.push_str("use super::{TagKitDef, PrintConvType};\n\n");
    
    // Generate PrintConv lookup tables for this category
    let mut local_print_conv_count = 0;
    for tag_kit in tag_kits {
        if tag_kit.print_conv_type == "Simple" {
            if let Some(print_conv_data) = &tag_kit.print_conv_data {
                if let Some(data_obj) = print_conv_data.as_object() {
                    let const_name = format!("PRINT_CONV_{}", *print_conv_counter);
                    *print_conv_counter += 1;
                    local_print_conv_count += 1;
                    
                    code.push_str(&format!("static {const_name}: LazyLock<HashMap<String, &'static str>> = LazyLock::new(|| {{\n"));
                    code.push_str("    let mut map = HashMap::new();\n");
                    
                    for (key, value) in data_obj {
                        if let Some(val_str) = value.as_str() {
                            code.push_str(&format!("    map.insert(\"{}\".to_string(), \"{}\");\n", 
                                escape_string(key), 
                                escape_string(val_str)));
                        }
                    }
                    
                    code.push_str("    map\n");
                    code.push_str("});\n\n");
                }
            }
        }
    }
    
    // Generate tag definitions function
    code.push_str(&format!("/// Get tag definitions for {category_name} category\n"));
    code.push_str(&format!("pub fn get_{category_name}_tags() -> Vec<(u32, TagKitDef)> {{\n"));
    code.push_str("    vec![\n");
    
    // Reset print conv counter for this category
    let mut category_print_conv_index = *print_conv_counter - local_print_conv_count;
    
    for tag_kit in tag_kits {
        let tag_id = tag_kit.tag_id.parse::<u32>().unwrap_or(0);
        
        code.push_str(&format!("        ({tag_id}, TagKitDef {{\n"));
        code.push_str(&format!("            id: {tag_id},\n"));
        code.push_str(&format!("            name: \"{}\",\n", escape_string(&tag_kit.name)));
        code.push_str(&format!("            format: \"{}\",\n", escape_string(&tag_kit.format)));
        
        // Groups (currently empty in extraction)
        code.push_str("            groups: HashMap::new(),\n");
        
        // Writable
        code.push_str(&format!("            writable: {},\n", 
            if tag_kit.writable.is_some() { "true" } else { "false" }));
        
        // Notes
        if let Some(notes) = &tag_kit.notes {
            let trimmed_notes = notes.trim();
            code.push_str(&format!("            notes: Some(\"{}\"),\n", escape_string(trimmed_notes)));
        } else {
            code.push_str("            notes: None,\n");
        }
        
        // PrintConv
        match tag_kit.print_conv_type.as_str() {
            "Simple" => {
                if tag_kit.print_conv_data.is_some() {
                    code.push_str(&format!("            print_conv: PrintConvType::Simple(&PRINT_CONV_{category_print_conv_index}),\n"));
                    category_print_conv_index += 1;
                } else {
                    code.push_str("            print_conv: PrintConvType::None,\n");
                }
            }
            "Expression" => {
                if let Some(expr_data) = &tag_kit.print_conv_data {
                    if let Some(expr_str) = expr_data.as_str() {
                        code.push_str(&format!("            print_conv: PrintConvType::Expression(\"{}\"),\n", 
                            escape_string(expr_str)));
                    } else {
                        code.push_str("            print_conv: PrintConvType::Expression(\"unknown\"),\n");
                    }
                } else {
                    code.push_str("            print_conv: PrintConvType::Expression(\"unknown\"),\n");
                }
            }
            "Manual" => {
                if let Some(func_name) = &tag_kit.print_conv_data {
                    if let Some(name_str) = func_name.as_str() {
                        code.push_str(&format!("            print_conv: PrintConvType::Manual(\"{}\"),\n", 
                            escape_string(name_str)));
                    } else {
                        code.push_str("            print_conv: PrintConvType::Manual(\"unknown\"),\n");
                    }
                } else {
                    code.push_str("            print_conv: PrintConvType::Manual(\"unknown\"),\n");
                }
            }
            _ => {
                code.push_str("            print_conv: PrintConvType::None,\n");
            }
        }
        
        // ValueConv
        if let Some(value_conv) = &tag_kit.value_conv {
            code.push_str(&format!("            value_conv: Some(\"{}\"),\n", escape_string(value_conv)));
        } else {
            code.push_str("            value_conv: None,\n");
        }
        
        code.push_str("        }),\n");
    }
    
    code.push_str("    ]\n");
    code.push_str("}\n");
    
    Ok((code, local_print_conv_count))
}

/// Generate the mod.rs file that combines all category modules
#[allow(dead_code)]
fn generate_mod_file(
    modules: &[&str], 
    module_name: &str,
    extraction: &TagKitExtraction,
) -> Result<String> {
    let mut code = String::new();
    
    // Header
    code.push_str(&format!("//! Modular tag kits with embedded PrintConv for {module_name}\n"));
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n");
    code.push_str("//!\n");
    code.push_str(&format!("//! Generated from: {} table: {}\n", extraction.source.module, extraction.source.table));
    code.push_str("//!\n");
    // NOTE: Do NOT add extraction timestamps here - they create spurious git diffs
    // that make it impossible to track real changes to generated code
    
    code.push_str("#![allow(unused_imports)]\n");
    code.push_str("#![allow(unused_mut)]\n\n");
    
    // Module declarations
    for module in modules {
        code.push_str(&format!("pub mod {module};\n"));
    }
    code.push('\n');
    
    // Common imports
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n");
    code.push_str("use crate::types::TagValue;\n");
    code.push_str("use crate::expressions::ExpressionEvaluator;\n\n");
    
    // Tag kit definition struct
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub struct TagKitDef {\n");
    code.push_str("    pub id: u32,\n");
    code.push_str("    pub name: &'static str,\n");
    code.push_str("    pub format: &'static str,\n");
    code.push_str("    pub groups: HashMap<&'static str, &'static str>,\n");
    code.push_str("    pub writable: bool,\n");
    code.push_str("    pub notes: Option<&'static str>,\n");
    code.push_str("    pub print_conv: PrintConvType,\n");
    code.push_str("    pub value_conv: Option<&'static str>,\n");
    code.push_str("}\n\n");
    
    // PrintConv type enum
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub enum PrintConvType {\n");
    code.push_str("    None,\n");
    code.push_str("    Simple(&'static HashMap<String, &'static str>),\n");
    code.push_str("    Expression(&'static str),\n");
    code.push_str("    Manual(&'static str),\n");
    code.push_str("}\n\n");
    
    // Combined tag map
    let const_name = format!("{}_TAG_KITS", module_name.to_uppercase());
    code.push_str(&format!("/// All tag kits for {module_name}\n"));
    code.push_str(&format!("pub static {const_name}: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {{\n"));
    code.push_str("    let mut map = HashMap::new();\n");
    code.push_str("    \n");
    
    // Add tags from each module
    for module in modules {
        code.push_str(&format!("    // {module} tags\n"));
        code.push_str(&format!("    for (id, tag_def) in {module}::get_{module}_tags() {{\n"));
        code.push_str("        map.insert(id, tag_def);\n");
        code.push_str("    }\n");
        code.push_str("    \n");
    }
    
    code.push_str("    map\n");
    code.push_str("});\n\n");
    
    // Apply PrintConv function
    code.push_str("/// Apply PrintConv for a tag from this module\n");
    code.push_str("pub fn apply_print_conv(\n");
    code.push_str("    tag_id: u32,\n");
    code.push_str("    value: &TagValue,\n");
    code.push_str("    _evaluator: &mut ExpressionEvaluator,\n");
    code.push_str("    _errors: &mut Vec<String>,\n");
    code.push_str("    warnings: &mut Vec<String>,\n");
    code.push_str(") -> TagValue {\n");
    code.push_str(&format!("    if let Some(tag_kit) = {const_name}.get(&tag_id) {{\n"));
    code.push_str("        match &tag_kit.print_conv {\n");
    code.push_str("            PrintConvType::None => value.clone(),\n");
    code.push_str("            PrintConvType::Simple(lookup) => {\n");
    code.push_str("                // Convert value to string key for lookup\n");
    code.push_str("                let key = match value {\n");
    code.push_str("                    TagValue::U8(v) => v.to_string(),\n");
    code.push_str("                    TagValue::U16(v) => v.to_string(),\n");
    code.push_str("                    TagValue::U32(v) => v.to_string(),\n");
    code.push_str("                    TagValue::I16(v) => v.to_string(),\n");
    code.push_str("                    TagValue::I32(v) => v.to_string(),\n");
    code.push_str("                    TagValue::String(s) => s.clone(),\n");
    code.push_str("                    _ => return value.clone(),\n");
    code.push_str("                };\n");
    code.push_str("                \n");
    code.push_str("                if let Some(result) = lookup.get(&key) {\n");
    code.push_str("                    TagValue::String(result.to_string())\n");
    code.push_str("                } else {\n");
    code.push_str("                    TagValue::String(format!(\"Unknown ({})\", value))\n");
    code.push_str("                }\n");
    code.push_str("            }\n");
    code.push_str("            PrintConvType::Expression(expr) => {\n");
    code.push_str("                // TODO: Implement expression evaluation\n");
    code.push_str("                warnings.push(format!(\"Expression PrintConv not yet implemented for tag {}: {}\", \n");
    code.push_str("                    tag_kit.name, expr));\n");
    code.push_str("                value.clone()\n");
    code.push_str("            }\n");
    code.push_str("            PrintConvType::Manual(func_name) => {\n");
    code.push_str("                // TODO: Look up in manual registry\n");
    code.push_str("                warnings.push(format!(\"Manual PrintConv '{}' not found for tag {}\", \n");
    code.push_str("                    func_name, tag_kit.name));\n");
    code.push_str("                value.clone()\n");
    code.push_str("            }\n");
    code.push_str("        }\n");
    code.push_str("    } else {\n");
    code.push_str("        // Tag not found in kit\n");
    code.push_str("        value.clone()\n");
    code.push_str("    }\n");
    code.push_str("}\n");
    
    Ok(code)
}