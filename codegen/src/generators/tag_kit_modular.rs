//! Modular tag kit generator that splits output into smaller files
//!
//! This generator creates tag definitions split by category to keep file sizes manageable

use anyhow::Result;
use std::fs;
use std::collections::HashMap;
use crate::common::escape_string;
use crate::schemas::tag_kit::{TagKitExtraction, TagKit, ExtractedTable};
use super::tag_kit_split::split_tag_kits;

/// Generate modular tag kit code from extracted data
pub fn generate_modular_tag_kit(
    extraction: &TagKitExtraction,
    output_dir: &str,
    module_name: &str,
) -> Result<()> {
    // Create output directory for tag kit modules 
    // Create tag_kit subdirectory inside the output directory
    let tag_kit_dir = format!("{output_dir}/tag_kit");
    fs::create_dir_all(&tag_kit_dir)?;
    
    // Split tag kits by category
    let categories = split_tag_kits(&extraction.tag_kits);
    
    // Keep track of all generated modules
    let mut generated_modules = Vec::new();
    let mut total_print_conv_count = 0;
    
    // Collect all subdirectory information
    let subdirectory_info = collect_subdirectory_info(&extraction.tag_kits);
    
    // Generate a module for each category with tags
    for (category, tag_kits) in &categories {
        if tag_kits.is_empty() {
            continue;
        }
        
        let module_name_cat = category.module_name();
        let (module_code, print_conv_count) = generate_category_module(
            module_name_cat,
            tag_kits,
            &extraction.source,
            &mut total_print_conv_count,
        )?;
        
        // Write category module
        let file_path = format!("{tag_kit_dir}/{module_name_cat}.rs");
        fs::write(&file_path, module_code)?;
        
        generated_modules.push(module_name_cat);
        
        println!("  ✓ Generated {} with {} tags, {} PrintConv tables",
            module_name_cat,
            tag_kits.len(),
            print_conv_count
        );
    }
    
    // Generate mod.rs that combines all modules and subdirectory processors
    let mod_code = generate_mod_file(&generated_modules, &sanitized_module_name, extraction, &subdirectory_info)?;
    fs::write(format!("{tag_kit_dir}/mod.rs"), mod_code)?;
    
    // Summary
    println!("  ✓ Generated modular tag kit for {} with {} tags split into {} modules", 
        module_name,
        extraction.tag_kits.len(),
        generated_modules.len()
    );
    
    Ok(())
}

/// Generate code for a single category module
fn generate_category_module(
    category_name: &str,
    tag_kits: &[&TagKit],
    source: &crate::schemas::tag_kit::SourceInfo,
    print_conv_counter: &mut usize,
) -> Result<(String, usize)> {
    let mut code = String::new();
    
    // Header with warning suppression at the top
    code.push_str(&format!("//! Tag kits for {} category from {}\n", category_name, source.module));
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");
    code.push_str("#![allow(unused_imports)]\n");
    code.push_str("#![allow(unused_mut)]\n\n");
    
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n");
    code.push_str("use crate::types::TagValue;\n");
    code.push_str("use super::{TagKitDef, PrintConvType, SubDirectoryType};\n");
    // Import subdirectory processor functions from parent module
    code.push_str("use super::*;\n\n");
    
    // Generate PrintConv lookup tables for this category
    let mut local_print_conv_count = 0;
    for tag_kit in tag_kits {
        tracing::debug!("Processing tag '{}' with print_conv_type='{}'", tag_kit.name, tag_kit.print_conv_type);
        if tag_kit.print_conv_type == "Simple" {
            tracing::debug!("Found Simple PrintConv for tag '{}'", tag_kit.name);
            if let Some(print_conv_data) = &tag_kit.print_conv_data {
                tracing::debug!("PrintConv data exists for tag '{}'", tag_kit.name);
                if let Some(data_obj) = print_conv_data.as_object() {
                    tracing::debug!("PrintConv data is an object with {} entries", data_obj.len());
                    let const_name = format!("PRINT_CONV_{}", *print_conv_counter);
                    *print_conv_counter += 1;
                    local_print_conv_count += 1;
                    
                    code.push_str(&format!("static {const_name}: LazyLock<HashMap<String, &'static str>> = LazyLock::new(|| {{\n"));
                    code.push_str("    let mut map = HashMap::new();\n");
                    
                    for (key, value) in data_obj {
                        tracing::debug!("Processing PrintConv entry: key='{}', value={:?}", key, value);
                        crate::generators::lookup_tables::generate_print_conv_entry(&mut code, key, value);
                    }
                    
                    code.push_str("    map\n");
                    code.push_str("});\n\n");
                }
            }
        }
    }
    
    // Generate tag definitions function
    code.push_str(&format!("/// Get tag definitions for {category_name} category\n"));
    code.push_str(&format!("pub fn get_{category_name}_tags() -> Vec<(u32, TagKitDef)> {{\n"));
    code.push_str("    vec![\n");
    
    // Reset print conv counter for this category
    let mut category_print_conv_index = *print_conv_counter - local_print_conv_count;
    
    for tag_kit in tag_kits {
        let tag_id = tag_kit.tag_id.parse::<u32>().unwrap_or(0);
        
        code.push_str(&format!("        ({tag_id}, TagKitDef {{\n"));
        code.push_str(&format!("            id: {tag_id},\n"));
        code.push_str(&format!("            name: \"{}\",\n", escape_string(&tag_kit.name)));
        code.push_str(&format!("            format: \"{}\",\n", escape_string(&tag_kit.format)));
        
        // Groups (currently empty in extraction)
        code.push_str("            groups: HashMap::new(),\n");
        
        // Writable
        code.push_str(&format!("            writable: {},\n", 
            if tag_kit.writable.is_some() { "true" } else { "false" }));
        
        // Notes
        if let Some(notes) = &tag_kit.notes {
            let trimmed_notes = notes.trim();
            code.push_str(&format!("            notes: Some(\"{}\"),\n", escape_string(trimmed_notes)));
        } else {
            code.push_str("            notes: None,\n");
        }
        
        // PrintConv
        match tag_kit.print_conv_type.as_str() {
            "Simple" => {
                if tag_kit.print_conv_data.is_some() {
                    code.push_str(&format!("            print_conv: PrintConvType::Simple(&PRINT_CONV_{category_print_conv_index}),\n"));
                    category_print_conv_index += 1;
                } else {
                    code.push_str("            print_conv: PrintConvType::None,\n");
                }
            }
            "Expression" => {
                if let Some(expr_data) = &tag_kit.print_conv_data {
                    if let Some(expr_str) = expr_data.as_str() {
                        code.push_str(&format!("            print_conv: PrintConvType::Expression(\"{}\"),\n", 
                            escape_string(expr_str)));
                    } else {
                        code.push_str("            print_conv: PrintConvType::Expression(\"unknown\"),\n");
                    }
                } else {
                    code.push_str("            print_conv: PrintConvType::Expression(\"unknown\"),\n");
                }
            }
            "Manual" => {
                if let Some(func_name) = &tag_kit.print_conv_data {
                    if let Some(name_str) = func_name.as_str() {
                        code.push_str(&format!("            print_conv: PrintConvType::Manual(\"{}\"),\n", 
                            escape_string(name_str)));
                    } else {
                        code.push_str("            print_conv: PrintConvType::Manual(\"unknown\"),\n");
                    }
                } else {
                    code.push_str("            print_conv: PrintConvType::Manual(\"unknown\"),\n");
                }
            }
            _ => {
                code.push_str("            print_conv: PrintConvType::None,\n");
            }
        }
        
        // ValueConv
        if let Some(value_conv) = &tag_kit.value_conv {
            code.push_str(&format!("            value_conv: Some(\"{}\"),\n", escape_string(value_conv)));
        } else {
            code.push_str("            value_conv: None,\n");
        }
        
        // Add subdirectory field
        if tag_kit.subdirectory.is_some() {
            code.push_str(&format!("            subdirectory: Some(SubDirectoryType::Binary {{ processor: process_tag_{:#x}_subdirectory }}),\n", tag_id));
        } else {
            code.push_str("            subdirectory: None,\n");
        }
        
        code.push_str("        }),\n");
    }
    
    code.push_str("    ]\n");
    code.push_str("}\n");
    
    Ok((code, local_print_conv_count))
}

/// Generate the mod.rs file that combines all category modules
fn generate_mod_file(
    modules: &[&str], 
    module_name: &str,
    extraction: &TagKitExtraction,
    subdirectory_info: &HashMap<u32, SubDirectoryCollection>,
) -> Result<String> {
    let mut code = String::new();
    
    // Header
    code.push_str(&format!("//! Modular tag kits with embedded PrintConv for {module_name}\n"));
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n");
    code.push_str("//!\n");
    code.push_str(&format!("//! Generated from: {} table: {}\n", extraction.source.module, extraction.source.table));
    code.push_str("//!\n");
    // NOTE: Do NOT add extraction timestamps here - they create spurious git diffs
    // that make it impossible to track real changes to generated code
    
    code.push_str("#![allow(unused_imports)]\n");
    code.push_str("#![allow(unused_mut)]\n\n");
    
    // Module declarations
    for module in modules {
        code.push_str(&format!("pub mod {module};\n"));
    }
    code.push('\n');
    
    // Common imports
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n");
    code.push_str("use crate::types::{TagValue, Result};\n");
    code.push_str("use crate::tiff_types::ByteOrder;\n");
    code.push_str("use crate::expressions::ExpressionEvaluator;\n\n");
    
    // Tag kit definition struct
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub struct TagKitDef {\n");
    code.push_str("    pub id: u32,\n");
    code.push_str("    pub name: &'static str,\n");
    code.push_str("    pub format: &'static str,\n");
    code.push_str("    pub groups: HashMap<&'static str, &'static str>,\n");
    code.push_str("    pub writable: bool,\n");
    code.push_str("    pub notes: Option<&'static str>,\n");
    code.push_str("    pub print_conv: PrintConvType,\n");
    code.push_str("    pub value_conv: Option<&'static str>,\n");
    code.push_str("    pub subdirectory: Option<SubDirectoryType>,\n");
    code.push_str("}\n\n");
    
    // PrintConv type enum
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub enum PrintConvType {\n");
    code.push_str("    None,\n");
    code.push_str("    Simple(&'static HashMap<String, &'static str>),\n");
    code.push_str("    Expression(&'static str),\n");
    code.push_str("    Manual(&'static str),\n");
    code.push_str("}\n\n");
    
    // SubDirectory type enum
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub enum SubDirectoryType {\n");
    code.push_str("    Binary {\n");
    code.push_str("        processor: fn(&[u8], crate::tiff_types::ByteOrder) -> crate::types::Result<Vec<(String, TagValue)>>,\n");
    code.push_str("    },\n");
    code.push_str("}\n\n");
    
    // Combined tag map
    let const_name = format!("{}_TAG_KITS", module_name.to_uppercase());
    code.push_str(&format!("/// All tag kits for {module_name}\n"));
    code.push_str(&format!("pub static {const_name}: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {{\n"));
    code.push_str("    let mut map = HashMap::new();\n");
    code.push_str("    \n");
    
    // Add tags from each module
    for module in modules {
        code.push_str(&format!("    // {module} tags\n"));
        code.push_str(&format!("    for (id, tag_def) in {module}::get_{module}_tags() {{\n"));
        code.push_str("        map.insert(id, tag_def);\n");
        code.push_str("    }\n");
        code.push_str("    \n");
    }
    
    code.push_str("    map\n");
    code.push_str("});\n\n");
    
    // Generate binary data helper functions
    code.push_str("// Helper functions for reading binary data\n");
    code.push_str("fn read_int16s_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<i16>> {\n");
    code.push_str("    if data.len() < count * 2 {\n");
    code.push_str("        return Err(crate::types::ExifError::InvalidData(\"Insufficient data for int16s array\".to_string()));\n");
    code.push_str("    }\n");
    code.push_str("    let mut values = Vec::with_capacity(count);\n");
    code.push_str("    for i in 0..count {\n");
    code.push_str("        let offset = i * 2;\n");
    code.push_str("        let value = match byte_order {\n");
    code.push_str("            ByteOrder::LittleEndian => i16::from_le_bytes([data[offset], data[offset + 1]]),\n");
    code.push_str("            ByteOrder::BigEndian => i16::from_be_bytes([data[offset], data[offset + 1]]),\n");
    code.push_str("        };\n");
    code.push_str("        values.push(value);\n");
    code.push_str("    }\n");
    code.push_str("    Ok(values)\n");
    code.push_str("}\n\n");
    
    code.push_str("fn read_int16u_array(data: &[u8], byte_order: ByteOrder, count: usize) -> Result<Vec<u16>> {\n");
    code.push_str("    if data.len() < count * 2 {\n");
    code.push_str("        return Err(crate::types::ExifError::InvalidData(\"Insufficient data for int16u array\".to_string()));\n");
    code.push_str("    }\n");
    code.push_str("    let mut values = Vec::with_capacity(count);\n");
    code.push_str("    for i in 0..count {\n");
    code.push_str("        let offset = i * 2;\n");
    code.push_str("        let value = match byte_order {\n");
    code.push_str("            ByteOrder::LittleEndian => u16::from_le_bytes([data[offset], data[offset + 1]]),\n");
    code.push_str("            ByteOrder::BigEndian => u16::from_be_bytes([data[offset], data[offset + 1]]),\n");
    code.push_str("        };\n");
    code.push_str("        values.push(value);\n");
    code.push_str("    }\n");
    code.push_str("    Ok(values)\n");
    code.push_str("}\n\n");
    
    code.push_str("fn read_int16s(data: &[u8], byte_order: ByteOrder) -> Result<i16> {\n");
    code.push_str("    if data.len() < 2 {\n");
    code.push_str("        return Err(crate::types::ExifError::InvalidData(\"Insufficient data for int16s\".to_string()));\n");
    code.push_str("    }\n");
    code.push_str("    Ok(match byte_order {\n");
    code.push_str("        ByteOrder::LittleEndian => i16::from_le_bytes([data[0], data[1]]),\n");
    code.push_str("        ByteOrder::BigEndian => i16::from_be_bytes([data[0], data[1]]),\n");
    code.push_str("    })\n");
    code.push_str("}\n\n");
    
    // Generate subdirectory processing functions
    if !subdirectory_info.is_empty() {
        code.push_str("// Subdirectory processing functions\n");
        
        // Generate binary data parsers for each unique subdirectory table
        let mut generated_tables = std::collections::HashSet::new();
        
        for collection in subdirectory_info.values() {
            for variant in &collection.variants {
                if variant.is_binary_data {
                    if let Some(extracted_table) = &variant.extracted_table {
                        let table_fn_name = variant.table_name
                            .replace("Image::ExifTool::", "")
                            .replace("::", "_")
                            .to_lowercase();
                        
                        if generated_tables.insert(table_fn_name.clone()) {
                            generate_binary_parser(&mut code, &table_fn_name, extracted_table)?;
                        }
                    }
                }
            }
        }
        
        // Generate conditional dispatch functions for tags with subdirectories
        for (tag_id, collection) in subdirectory_info {
            generate_subdirectory_dispatcher(&mut code, *tag_id, collection)?;
        }
    }
    
    // Apply PrintConv function
    code.push_str("/// Apply PrintConv for a tag from this module\n");
    code.push_str("pub fn apply_print_conv(\n");
    code.push_str("    tag_id: u32,\n");
    code.push_str("    value: &TagValue,\n");
    code.push_str("    byte_order: ByteOrder,\n");
    code.push_str("    _evaluator: &mut ExpressionEvaluator,\n");
    code.push_str("    _errors: &mut Vec<String>,\n");
    code.push_str("    warnings: &mut Vec<String>,\n");
    code.push_str(") -> TagValue {\n");
    code.push_str(&format!("    if let Some(tag_kit) = {const_name}.get(&tag_id) {{\n"));
    code.push_str("        // Check if this tag has subdirectory processing\n");
    code.push_str("        if let Some(SubDirectoryType::Binary { processor }) = &tag_kit.subdirectory {\n");
    code.push_str("            // For subdirectory tags, we need to process the binary data\n");
    code.push_str("            match value {\n");
    code.push_str("                TagValue::U16Array(arr) => {\n");
    code.push_str("                    // Convert U16 array to bytes\n");
    code.push_str("                    let mut bytes = Vec::with_capacity(arr.len() * 2);\n");
    code.push_str("                    for val in arr {\n");
    code.push_str("                        bytes.extend_from_slice(&val.to_le_bytes());\n");
    code.push_str("                    }\n");
    code.push_str("                    // Process subdirectory and return first extracted tag for now\n");
    code.push_str("                    // TODO: Handle multiple extracted tags properly\n");
    code.push_str("                    if let Ok(extracted_tags) = processor(&bytes, byte_order) {\n");
    code.push_str("                        if !extracted_tags.is_empty() {\n");
    code.push_str("                            // For now, return a formatted string of all extracted tags\n");
    code.push_str("                            let mut result_parts = Vec::new();\n");
    code.push_str("                            for (name, val) in extracted_tags {\n");
    code.push_str("                                result_parts.push(format!(\"{}: {}\", name, val));\n");
    code.push_str("                            }\n");
    code.push_str("                            return TagValue::String(result_parts.join(\"; \"));\n");
    code.push_str("                        }\n");
    code.push_str("                    }\n");
    code.push_str("                }\n");
    code.push_str("                TagValue::U8Array(arr) => {\n");
    code.push_str("                    // Process U8 array directly\n");
    code.push_str("                    if let Ok(extracted_tags) = processor(arr, byte_order) {\n");
    code.push_str("                        if !extracted_tags.is_empty() {\n");
    code.push_str("                            // For now, return a formatted string of all extracted tags\n");
    code.push_str("                            let mut result_parts = Vec::new();\n");
    code.push_str("                            for (name, val) in extracted_tags {\n");
    code.push_str("                                result_parts.push(format!(\"{}: {}\", name, val));\n");
    code.push_str("                            }\n");
    code.push_str("                            return TagValue::String(result_parts.join(\"; \"));\n");
    code.push_str("                        }\n");
    code.push_str("                    }\n");
    code.push_str("                }\n");
    code.push_str("                _ => {} // Fall through to normal processing\n");
    code.push_str("            }\n");
    code.push_str("        }\n");
    code.push_str("        \n");
    code.push_str("        // Normal PrintConv processing\n");
    code.push_str("        match &tag_kit.print_conv {\n");
    code.push_str("            PrintConvType::None => value.clone(),\n");
    code.push_str("            PrintConvType::Simple(lookup) => {\n");
    code.push_str("                // Convert value to string key for lookup\n");
    code.push_str("                let key = match value {\n");
    code.push_str("                    TagValue::U8(v) => v.to_string(),\n");
    code.push_str("                    TagValue::U16(v) => v.to_string(),\n");
    code.push_str("                    TagValue::U32(v) => v.to_string(),\n");
    code.push_str("                    TagValue::I16(v) => v.to_string(),\n");
    code.push_str("                    TagValue::I32(v) => v.to_string(),\n");
    code.push_str("                    TagValue::String(s) => s.clone(),\n");
    code.push_str("                    _ => return value.clone(),\n");
    code.push_str("                };\n");
    code.push_str("                \n");
    code.push_str("                if let Some(result) = lookup.get(&key) {\n");
    code.push_str("                    TagValue::String(result.to_string())\n");
    code.push_str("                } else {\n");
    code.push_str("                    TagValue::String(format!(\"Unknown ({})\", value))\n");
    code.push_str("                }\n");
    code.push_str("            }\n");
    code.push_str("            PrintConvType::Expression(expr) => {\n");
    code.push_str("                // TODO: Implement expression evaluation\n");
    code.push_str("                warnings.push(format!(\"Expression PrintConv not yet implemented for tag {}: {}\", \n");
    code.push_str("                    tag_kit.name, expr));\n");
    code.push_str("                value.clone()\n");
    code.push_str("            }\n");
    code.push_str("            PrintConvType::Manual(func_name) => {\n");
    code.push_str("                // TODO: Look up in manual registry\n");
    code.push_str("                warnings.push(format!(\"Manual PrintConv '{}' not found for tag {}\", \n");
    code.push_str("                    func_name, tag_kit.name));\n");
    code.push_str("                value.clone()\n");
    code.push_str("            }\n");
    code.push_str("        }\n");
    code.push_str("    } else {\n");
    code.push_str("        // Tag not found in kit\n");
    code.push_str("        value.clone()\n");
    code.push_str("    }\n");
    code.push_str("}\n");
    
    Ok(code)
}

/// Information about a subdirectory and all its variants
#[derive(Debug)]
struct SubDirectoryCollection {
    tag_id: u32,
    tag_name: String,
    variants: Vec<SubDirectoryVariant>,
}

#[derive(Debug, Clone)]
struct SubDirectoryVariant {
    variant_id: String,
    condition: Option<String>,
    table_name: String,
    is_binary_data: bool,
    extracted_table: Option<ExtractedTable>,
}

/// Collect all subdirectory information from tag kits
fn collect_subdirectory_info(tag_kits: &[TagKit]) -> HashMap<u32, SubDirectoryCollection> {
    let mut subdirectory_map: HashMap<u32, SubDirectoryCollection> = HashMap::new();
    
    for tag_kit in tag_kits {
        if let Some(subdirectory) = &tag_kit.subdirectory {
            let tag_id = tag_kit.tag_id.parse::<u32>().unwrap_or(0);
            
            let variant = SubDirectoryVariant {
                variant_id: tag_kit.variant_id.clone().unwrap_or_else(|| format!("{}_default", tag_id)),
                condition: tag_kit.condition.clone(),
                table_name: subdirectory.tag_table.clone(),
                is_binary_data: subdirectory.is_binary_data.unwrap_or(false),
                extracted_table: subdirectory.extracted_table.clone(),
            };
            
            subdirectory_map
                .entry(tag_id)
                .and_modify(|collection| collection.variants.push(variant.clone()))
                .or_insert_with(|| SubDirectoryCollection {
                    tag_id,
                    tag_name: tag_kit.name.clone(),
                    variants: vec![variant],
                });
        }
    }
    
    subdirectory_map
}

/// Generate a binary data parser function for a subdirectory table
fn generate_binary_parser(code: &mut String, fn_name: &str, table: &ExtractedTable) -> Result<()> {
    code.push_str(&format!("fn process_{}(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {{\n", fn_name));
    code.push_str("    let mut tags = Vec::new();\n");
    
    // Get the format size multiplier
    let format_size = match table.format.as_deref() {
        Some("int16s") | Some("int16u") => 2,
        Some("int32s") | Some("int32u") => 4,
        Some("int8s") | Some("int8u") => 1,
        _ => 2, // Default to int16
    };
    
    let first_entry = table.first_entry.unwrap_or(0);
    
    // Generate tag extraction code for each tag in the table
    for tag in &table.tags {
        let tag_offset = tag.tag_id.parse::<i32>().unwrap_or(0);
        let byte_offset = ((tag_offset - first_entry) * format_size) as usize;
        
        code.push_str(&format!("    // {} at offset {}\n", tag.name, tag.tag_id));
        
        if let Some(format) = &tag.format {
            if format.ends_with(']') {
                // Array format like "int16s[4]"
                if let Some(array_start) = format.find('[') {
                    let base_format = &format[..array_start];
                    let count_str = &format[array_start + 1..format.len() - 1];
                    if let Ok(count) = count_str.parse::<usize>() {
                        let total_size = match base_format {
                            "int16s" | "int16u" => 2 * count,
                            "int32s" | "int32u" => 4 * count,
                            "int8s" | "int8u" => count,
                            _ => 2 * count,
                        };
                        
                        code.push_str(&format!("    if data.len() >= {} {{\n", byte_offset + total_size));
                        
                        match base_format {
                            "int16s" => {
                                code.push_str(&format!("        if let Ok(values) = read_int16s_array(&data[{}..{}], byte_order, {}) {{\n", 
                                    byte_offset, byte_offset + total_size, count));
                                code.push_str("            let value_str = values.iter().map(|v| v.to_string()).collect::<Vec<_>>().join(\" \");\n");
                                code.push_str(&format!("            tags.push((\"{}\".to_string(), TagValue::String(value_str)));\n", tag.name));
                                code.push_str("        }\n");
                            }
                            "int16u" => {
                                code.push_str(&format!("        if let Ok(values) = read_int16u_array(&data[{}..{}], byte_order, {}) {{\n", 
                                    byte_offset, byte_offset + total_size, count));
                                code.push_str("            let value_str = values.iter().map(|v| v.to_string()).collect::<Vec<_>>().join(\" \");\n");
                                code.push_str(&format!("            tags.push((\"{}\".to_string(), TagValue::String(value_str)));\n", tag.name));
                                code.push_str("        }\n");
                            }
                            _ => {
                                // For other formats, just store the raw offset for now
                                code.push_str(&format!("        // TODO: Handle format {}\n", base_format));
                            }
                        }
                        
                        code.push_str("    }\n");
                    }
                }
            } else {
                // Single value format
                let value_size = match format.as_str() {
                    "int16s" | "int16u" => 2,
                    "int32s" | "int32u" => 4,
                    "int8s" | "int8u" => 1,
                    _ => 2,
                };
                
                code.push_str(&format!("    if data.len() >= {} {{\n", byte_offset + value_size));
                
                match format.as_str() {
                    "int16s" => {
                        code.push_str(&format!("        if let Ok(value) = read_int16s(&data[{}..{}], byte_order) {{\n", 
                            byte_offset, byte_offset + value_size));
                        code.push_str(&format!("            tags.push((\"{}\".to_string(), TagValue::I16(value)));\n", tag.name));
                        code.push_str("        }\n");
                    }
                    _ => {
                        // For other formats, just store the raw offset for now
                        code.push_str(&format!("        // TODO: Handle format {}\n", format));
                    }
                }
                
                code.push_str("    }\n");
            }
        }
        
        code.push_str("    \n");
    }
    
    code.push_str("    Ok(tags)\n");
    code.push_str("}\n\n");
    
    Ok(())
}

/// Generate a conditional dispatch function for a tag with subdirectory variants
fn generate_subdirectory_dispatcher(code: &mut String, tag_id: u32, collection: &SubDirectoryCollection) -> Result<()> {
    code.push_str(&format!("pub fn process_tag_{:#x}_subdirectory(data: &[u8], byte_order: ByteOrder) -> Result<Vec<(String, TagValue)>> {{\n", tag_id));
    
    // Determine the format for count calculation (usually int16s for Canon)
    let format_size = 2; // Default to int16s
    code.push_str(&format!("    let count = data.len() / {};\n", format_size));
    code.push_str("    \n");
    code.push_str("    match count {\n");
    
    for variant in &collection.variants {
        if let Some(condition) = &variant.condition {
            // Extract count value from condition like "$count == 582"
            if let Some(count_match) = condition.split("==").nth(1) {
                if let Ok(count_val) = count_match.trim().parse::<usize>() {
                    let table_fn_name = variant.table_name
                        .replace("Image::ExifTool::", "")
                        .replace("::", "_")
                        .to_lowercase();
                    
                    code.push_str(&format!("        {} => process_{}(data, byte_order),\n", count_val, table_fn_name));
                }
            }
        }
    }
    
    code.push_str("        _ => Ok(vec![]), // Unknown variant\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    Ok(())
}