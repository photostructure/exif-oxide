//! Generator for supported tags summary

use anyhow::Result;
use std::fs;
use crate::schemas::{GeneratedTag, GeneratedCompositeTag};

/// Generate supported tags summary
pub fn generate_supported_tags(
    tags: &[GeneratedTag], 
    composite_tags: &[GeneratedCompositeTag],
    output_dir: &str
) -> Result<()> {
    let mut code = String::new();

    // File header
    code.push_str("//! Generated summary of all supported tags\n");
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");

    // Statistics constants
    code.push_str(&format!("/// Total number of supported standard tags\n"));
    code.push_str(&format!("pub const SUPPORTED_TAG_COUNT: usize = {};\n\n", tags.len()));
    
    code.push_str(&format!("/// Total number of supported composite tags\n"));
    code.push_str(&format!("pub const SUPPORTED_COMPOSITE_TAG_COUNT: usize = {};\n\n", composite_tags.len()));
    
    code.push_str(&format!("/// Total number of all supported tags\n"));
    code.push_str(&format!("pub const TOTAL_SUPPORTED_TAG_COUNT: usize = {};\n\n", 
        tags.len() + composite_tags.len()));

    // Tag name arrays for quick reference
    code.push_str("/// All supported standard tag names\n");
    code.push_str("pub const SUPPORTED_TAG_NAMES: &[&str] = &[\n");
    
    let mut sorted_tags: Vec<_> = tags.iter().map(|t| &t.name).collect();
    sorted_tags.sort();
    for name in sorted_tags {
        code.push_str(&format!("    \"{}\",\n", name));
    }
    
    code.push_str("];\n\n");

    // Composite tag names
    code.push_str("/// All supported composite tag names\n");
    code.push_str("pub const SUPPORTED_COMPOSITE_TAG_NAMES: &[&str] = &[\n");
    
    let mut sorted_composite: Vec<_> = composite_tags.iter().map(|t| &t.name).collect();
    sorted_composite.sort();
    for name in sorted_composite {
        code.push_str(&format!("    \"{}\",\n", name));
    }
    
    code.push_str("];\n\n");

    // Group statistics
    let mut group_counts = std::collections::HashMap::new();
    for tag in tags {
        for group in &tag.groups {
            *group_counts.entry(group.as_str()).or_insert(0) += 1;
        }
    }
    
    code.push_str("/// Tag counts by group\n");
    code.push_str("pub fn tag_counts_by_group() -> &'static [(&'static str, usize)] {\n");
    code.push_str("    &[\n");
    
    let mut sorted_groups: Vec<_> = group_counts.into_iter().collect();
    sorted_groups.sort_by_key(|(name, _)| *name);
    for (group, count) in sorted_groups {
        code.push_str(&format!("        (\"{}\", {}),\n", group, count));
    }
    
    code.push_str("    ]\n");
    code.push_str("}\n\n");

    // Summary function
    code.push_str("/// Get a summary of supported tag statistics\n");
    code.push_str("pub fn supported_tag_summary() -> String {\n");
    code.push_str("    format!(\n");
    code.push_str("        \"Supported tags: {} standard, {} composite, {} total\",\n");
    code.push_str("        SUPPORTED_TAG_COUNT,\n");
    code.push_str("        SUPPORTED_COMPOSITE_TAG_COUNT,\n");
    code.push_str("        TOTAL_SUPPORTED_TAG_COUNT\n");
    code.push_str("    )\n");
    code.push_str("}\n");

    // Write file
    let output_path = format!("{}/supported_tags.rs", output_dir);
    fs::write(&output_path, code)?;
    println!("  âœ“ Generated {}", output_path);

    Ok(())
}