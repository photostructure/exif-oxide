//! Generator for simple tables from ExifTool

use anyhow::{Context, Result};
use std::fs;
use std::path::Path;
use std::collections::HashSet;
use crate::schemas::{SimpleTablesData, ExtractedTable};
use crate::common::escape_string;

/// Generate simple tables from extraction JSON
pub fn generate_simple_tables(json_path: &Path, output_dir: &str) -> Result<()> {
    // Read and parse the JSON file
    let json_data = fs::read_to_string(json_path)
        .with_context(|| format!("Failed to read {}", json_path.display()))?;
    
    let tables_data: SimpleTablesData = serde_json::from_str(&json_data)
        .with_context(|| "Failed to parse simple tables JSON")?;
    
    println!("  Processing {} simple tables...", tables_data.total_tables);
    println!("  Output directory: {}", output_dir);
    println!("  Simple tables directory: {}/simple_tables", output_dir);
    
    // Create subdirectory for simple tables
    let simple_tables_dir = format!("{}/simple_tables", output_dir);
    fs::create_dir_all(&simple_tables_dir)?;
    
    // Generate mod.rs for simple_tables module
    let mut mod_content = String::new();
    mod_content.push_str("//! Generated simple table modules\n");
    mod_content.push_str("//!\n");
    mod_content.push_str("//! This file is automatically generated by codegen.\n");
    mod_content.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");
    
    // Process each table
    let mut sorted_tables: Vec<(&String, &ExtractedTable)> = tables_data.tables.iter().collect();
    sorted_tables.sort_by_key(|(name, _)| *name);
    
    // Track subdirectories we've created mod files for
    let mut subdirs_created = std::collections::HashSet::new();
    
    for (hash_name, table_data) in sorted_tables {
        // Generate code for this table
        let code = generate_table_code(hash_name, table_data)?;
        
        // Write to file
        let output_path = format!("{}/{}", simple_tables_dir, table_data.config.output_file);
        
        // Create subdirectory if needed
        if let Some(parent) = std::path::Path::new(&output_path).parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("Failed to create directory for {}", output_path))?;
        }
        
        println!("    Writing to: {}", output_path);
        fs::write(&output_path, code)
            .with_context(|| format!("Failed to write to {}", output_path))?;
        
        // Handle module declarations for subdirectories
        let path_parts: Vec<&str> = table_data.config.output_file.split('/').collect();
        
        if path_parts.len() > 1 {
            // It's in a subdirectory
            let subdir = path_parts[0];
            
            // Create mod.rs for subdirectory if we haven't already
            if !subdirs_created.contains(subdir) {
                subdirs_created.insert(subdir.to_string());
                
                let subdir_path = format!("{}/{}", simple_tables_dir, subdir);
                fs::create_dir_all(&subdir_path)?;
                
                // Create a mod.rs for this subdirectory
                let subdir_mod_path = format!("{}/mod.rs", subdir_path);
                let mut subdir_mod_content = String::new();
                subdir_mod_content.push_str(&format!("//! {} table modules\n\n", subdir));
                
                // We'll append to this file for each module in this subdirectory
                fs::write(&subdir_mod_path, subdir_mod_content)?;
                
                // Add subdirectory to main mod.rs
                mod_content.push_str(&format!("pub mod {};\n", subdir));
            }
            
            // Append this module to the subdirectory's mod.rs
            let subdir_mod_path = format!("{}/{}/mod.rs", simple_tables_dir, subdir);
            let module_name = path_parts[1].strip_suffix(".rs").unwrap_or(path_parts[1]);
            let mut existing_content = fs::read_to_string(&subdir_mod_path)?;
            existing_content.push_str(&format!("pub mod {};\n", module_name));
            fs::write(&subdir_mod_path, existing_content)?;
        } else {
            // It's in the root simple_tables directory
            let module_name = table_data.config.output_file
                .strip_suffix(".rs")
                .unwrap_or(&table_data.config.output_file);
            mod_content.push_str(&format!("pub mod {};\n", module_name));
        }
        
        println!(
            "    ✓ Generated {} ({} entries)",
            table_data.config.output_file, table_data.entry_count
        );
    }
    
    // Write mod.rs
    fs::write(format!("{}/mod.rs", simple_tables_dir), mod_content)?;
    
    // Add re-exports to file_types mod.rs if it exists
    let file_types_mod_path = format!("{}/file_types/mod.rs", simple_tables_dir);
    if std::path::Path::new(&file_types_mod_path).exists() {
        let mut file_types_content = fs::read_to_string(&file_types_mod_path)?;
        file_types_content.push_str("\n// Re-export commonly used functions for convenience\n");
        file_types_content.push_str("pub use file_type_lookup::{resolve_file_type, lookup_file_type_lookup, get_primary_format, supports_format, extensions_for_format};\n");
        file_types_content.push_str("pub use magic_numbers::lookup_magic_number_patterns;\n");
        file_types_content.push_str("pub use mime_types::lookup_mime_types;\n");
        fs::write(&file_types_mod_path, file_types_content)?;
    }
    
    println!("  ✓ Generated {} simple tables total", tables_data.total_tables);
    Ok(())
}

/// Generate Rust code for a single simple table
fn generate_table_code(hash_name: &str, table_data: &ExtractedTable) -> Result<String> {
    let extraction_type = table_data.extraction_type.as_deref().unwrap_or("simple_table");
    
    match extraction_type {
        "regex_strings" => generate_regex_table_code(hash_name, table_data),
        "file_type_lookup" => generate_file_type_lookup_code(hash_name, table_data),
        _ => generate_simple_table_code(hash_name, table_data),
    }
}

/// Generate code for a simple lookup table
fn generate_simple_table_code(hash_name: &str, table_data: &ExtractedTable) -> Result<String> {
    let config = &table_data.config;
    let mut code = String::new();
    
    // File header
    let constant_name = config.constant_name.as_ref()
        .ok_or_else(|| anyhow::anyhow!("constant_name required for simple tables"))?;
    
    code.push_str(&format!(
        "//! Generated {} lookup table\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n//!\n//! Source: ExifTool {} {}\n//! Description: {}\n\n",
        constant_name.to_lowercase(),
        config.module,
        hash_name,
        config.description
    ));
    
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n\n");
    
    // Determine key type
    let key_type = config.key_type.as_ref()
        .ok_or_else(|| anyhow::anyhow!("key_type required for simple tables"))?;
    
    let key_rust_type = match key_type.as_str() {
        "u8" => "u8",
        "u16" => "u16",
        "u32" => "u32",
        "i8" => "i8",
        "i16" => "i16",
        "i32" => "i32",
        "f32" => "f32",
        "String" => "&'static str",
        _ => "&'static str",
    };
    
    // Generate static HashMap
    code.push_str(&format!(
        "/// {} lookup table\n/// Source: ExifTool {} {} ({} entries)\npub static {}: LazyLock<HashMap<{}, &'static str>> = LazyLock::new(|| {{\n",
        config.description,
        config.module,
        hash_name,
        table_data.entry_count,
        constant_name,
        key_rust_type
    ));
    
    code.push_str("    let mut map = HashMap::new();\n");
    
    // Sort entries for deterministic output
    let mut sorted_entries = table_data.entries.clone();
    sorted_entries.sort_by(|a, b| {
        if key_type == "String" {
            a.key.as_ref().unwrap_or(&String::new()).cmp(b.key.as_ref().unwrap_or(&String::new()))
        } else {
            let a_num: i64 = a.key.as_ref().unwrap_or(&String::new()).parse().unwrap_or(0);
            let b_num: i64 = b.key.as_ref().unwrap_or(&String::new()).parse().unwrap_or(0);
            a_num.cmp(&b_num)
        }
    });
    
    // Add entries
    for entry in &sorted_entries {
        if let (Some(key), Some(value)) = (&entry.key, &entry.value) {
            let key_value = if key_type == "String" {
                format!("\"{}\"", key)
            } else {
                key.clone()
            };
            
            code.push_str(&format!(
                "    map.insert({}, \"{}\");\n",
                key_value,
                escape_string(value)
            ));
        }
    }
    
    code.push_str("    map\n});\n\n");
    
    // Generate lookup function
    let fn_name = constant_name.to_lowercase();
    let fn_param_type = if key_type == "String" { "&str" } else { key_rust_type };
    
    code.push_str(&format!(
        "/// Look up {} value by key\npub fn lookup_{}(key: {}) -> Option<&'static str> {{\n",
        config.description.to_lowercase(),
        fn_name,
        fn_param_type
    ));
    
    let key_ref = if key_type == "String" { "key" } else { "&key" };
    code.push_str(&format!("    {}.get({}).copied()\n", constant_name, key_ref));
    code.push_str("}\n");
    
    Ok(code)
}

/// Generate code for regex patterns table
fn generate_regex_table_code(hash_name: &str, table_data: &ExtractedTable) -> Result<String> {
    let config = &table_data.config;
    let mut code = String::new();
    
    let constant_name = config.constant_name.as_ref()
        .ok_or_else(|| anyhow::anyhow!("constant_name required for regex tables"))?;
    
    code.push_str(&format!(
        "//! Generated {} regex patterns table\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n//!\n//! Source: ExifTool {} {}\n//! Description: {}\n\n",
        constant_name.to_lowercase(),
        config.module,
        hash_name,
        config.description
    ));
    
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n\n");
    
    // Verify key type
    let key_type = config.key_type.as_ref()
        .ok_or_else(|| anyhow::anyhow!("key_type required for regex tables"))?;
    
    if key_type != "String" {
        return Err(anyhow::anyhow!(
            "regex_strings extraction only supports String key_type, got: {}",
            key_type
        ));
    }
    
    // Generate regex patterns table
    code.push_str(&format!(
        "/// {} regex patterns table\n/// Source: ExifTool {} {} ({} entries)\n/// Each value is a regex pattern for file type detection\npub static {}: LazyLock<HashMap<&'static str, &'static str>> = LazyLock::new(|| {{\n",
        config.description,
        config.module,
        hash_name,
        table_data.entry_count,
        constant_name
    ));
    
    code.push_str("    let mut map = HashMap::new();\n");
    
    // Sort entries
    let mut sorted_entries = table_data.entries.clone();
    sorted_entries.sort_by(|a, b| {
        a.key.as_ref().unwrap_or(&String::new()).cmp(b.key.as_ref().unwrap_or(&String::new()))
    });
    
    // Add entries with compatibility warnings
    for entry in &sorted_entries {
        if let (Some(key), Some(value)) = (&entry.key, &entry.value) {
            let compat_comment = if let Some(compat_note) = &entry.compatibility_notes {
                if !entry.rust_compatible.unwrap_or(true) {
                    format!(" // WARNING: {}", compat_note)
                } else {
                    String::new()
                }
            } else {
                String::new()
            };
            
            let pattern_str = if value.contains('"') {
                format!("\"{}\"", value.replace('\\', "\\\\").replace('"', "\\\""))
            } else {
                format!("r\"{}\"", value)
            };
            
            code.push_str(&format!(
                "    map.insert(\"{}\", {});{}\n",
                key, pattern_str, compat_comment
            ));
        }
    }
    
    code.push_str("    map\n});\n\n");
    
    // Generate lookup function
    let fn_name = constant_name.to_lowercase();
    code.push_str(&format!(
        "/// Look up {} regex pattern by key\npub fn lookup_{}(key: &str) -> Option<&'static str> {{\n",
        config.description.to_lowercase(),
        fn_name
    ));
    
    code.push_str(&format!("    {}.get(key).copied()\n", constant_name));
    code.push_str("}\n");
    
    Ok(code)
}

/// Generate code for file type lookup table
fn generate_file_type_lookup_code(hash_name: &str, table_data: &ExtractedTable) -> Result<String> {
    let config = &table_data.config;
    let mut code = String::new();
    
    let constant_name = config.constant_name.as_ref()
        .ok_or_else(|| anyhow::anyhow!("constant_name required for file type lookup"))?;
    
    code.push_str(&format!(
        "//! Generated {} file type lookup table\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n//!\n//! Source: ExifTool {} {}\n//! Description: {}\n\n",
        constant_name.to_lowercase(),
        config.module,
        hash_name,
        config.description
    ));
    
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n\n");
    
    // FileTypeEntry enum
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub enum FileTypeEntry {\n");
    code.push_str("    /// Simple alias pointing to another file type\n");
    code.push_str("    Alias(String),\n");
    code.push_str("    /// Full file type definition\n");
    code.push_str("    Definition {\n");
    code.push_str("        formats: Vec<String>,\n");
    code.push_str("        description: String,\n");
    code.push_str("    },\n");
    code.push_str("}\n\n");
    
    // Generate static HashMap
    code.push_str(&format!(
        "/// {} file type lookup table\n/// Source: ExifTool {} {} ({} entries)\npub static {}: LazyLock<HashMap<&'static str, FileTypeEntry>> = LazyLock::new(|| {{\n",
        config.description,
        config.module,
        hash_name,
        table_data.entry_count,
        constant_name
    ));
    
    code.push_str("    let mut map = HashMap::new();\n");
    
    // Sort entries
    let mut sorted_entries = table_data.entries.clone();
    sorted_entries.sort_by(|a, b| {
        let a_ext = a.extension.as_deref().unwrap_or("");
        let b_ext = b.extension.as_deref().unwrap_or("");
        a_ext.cmp(b_ext)
    });
    
    // Add entries
    for entry in &sorted_entries {
        if let Some(ext) = &entry.extension {
            if let Some(entry_type) = &entry.entry_type {
                match entry_type.as_str() {
                    "alias" => {
                        if let Some(target) = &entry.target {
                            code.push_str(&format!(
                                "    map.insert(\"{}\", FileTypeEntry::Alias(\"{}\".to_string()));\n",
                                ext, target
                            ));
                        }
                    }
                    "definition" => {
                        if let (Some(formats), Some(desc)) = (&entry.formats, &entry.description) {
                            code.push_str(&format!(
                                "    map.insert(\"{}\", FileTypeEntry::Definition {{\n",
                                ext
                            ));
                            
                            code.push_str("        formats: vec![");
                            for (i, fmt) in formats.iter().enumerate() {
                                if i > 0 { code.push_str(", "); }
                                code.push_str(&format!("\"{}\"", fmt));
                            }
                            code.push_str("].into_iter().map(String::from).collect(),\n");
                            
                            code.push_str(&format!(
                                "        description: \"{}\".to_string(),\n",
                                desc.replace('"', "\\\"")
                            ));
                            
                            code.push_str("    });\n");
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    
    code.push_str("    map\n});\n\n");
    
    // Generate lookup function
    let fn_name = constant_name.to_lowercase();
    code.push_str(&format!(
        "/// Look up file type by extension\npub fn lookup_{}(ext: &str) -> Option<&'static FileTypeEntry> {{\n",
        fn_name
    ));
    
    code.push_str("    let ext_upper = ext.to_uppercase();\n");
    code.push_str(&format!("    {}.get(ext_upper.as_str())\n", constant_name));
    code.push_str("}\n\n");
    
    // Helper function to resolve aliases
    code.push_str("/// Resolve file type aliases to their final definition\n");
    code.push_str("pub fn resolve_file_type(ext: &str) -> Option<(Vec<&'static str>, &'static str)> {\n");
    code.push_str("    let ext_upper = ext.to_uppercase();\n");
    code.push_str("    let mut current_ext = ext_upper.as_str();\n");
    code.push_str("    let mut seen = std::collections::HashSet::new();\n");
    code.push_str("    \n");
    code.push_str("    loop {\n");
    code.push_str(&format!("        match {}.get(current_ext) {{\n", constant_name));
    code.push_str("            Some(FileTypeEntry::Alias(target)) => {\n");
    code.push_str("                if !seen.insert(current_ext) {\n");
    code.push_str("                    return None; // Circular reference\n");
    code.push_str("                }\n");
    code.push_str("                current_ext = target;\n");
    code.push_str("            }\n");
    code.push_str("            Some(FileTypeEntry::Definition { description, formats }) => {\n");
    code.push_str("                return Some((formats.iter().map(|s| s.as_str()).collect(), description.as_str()));\n");
    code.push_str("            }\n");
    code.push_str("            None => return None,\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    // Additional helper functions
    code.push_str("/// Get the primary format (first format) for a file type\n");
    code.push_str("pub fn get_primary_format(ext: &str) -> Option<String> {\n");
    code.push_str("    resolve_file_type(ext).map(|(formats, _)| formats[0].to_string())\n");
    code.push_str("}\n\n");
    
    code.push_str("/// Check if a file type supports a specific format\n");
    code.push_str("pub fn supports_format(ext: &str, format: &str) -> bool {\n");
    code.push_str("    if let Some((formats, _)) = resolve_file_type(ext) {\n");
    code.push_str("        formats.contains(&format)\n");
    code.push_str("    } else {\n");
    code.push_str("        false\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    code.push_str("/// Get all extensions that support a given format\n");
    code.push_str("pub fn extensions_for_format(format: &str) -> Vec<String> {\n");
    code.push_str("    let mut extensions = Vec::new();\n");
    code.push_str("    \n");
    code.push_str(&format!("    for (ext, entry) in {}.iter() {{\n", constant_name));
    code.push_str("        match entry {\n");
    code.push_str("            FileTypeEntry::Definition { formats, .. } => {\n");
    code.push_str("                if formats.iter().any(|f| f == format) {\n");
    code.push_str("                    extensions.push(ext.to_string());\n");
    code.push_str("                }\n");
    code.push_str("            }\n");
    code.push_str("            FileTypeEntry::Alias(target) => {\n");
    code.push_str("                // Resolve alias and check\n");
    code.push_str("                if let Some((formats, _)) = resolve_file_type(target) {\n");
    code.push_str("                    if formats.contains(&format) {\n");
    code.push_str("                        extensions.push(ext.to_string());\n");
    code.push_str("                    }\n");
    code.push_str("                }\n");
    code.push_str("            }\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("    \n");
    code.push_str("    extensions\n");
    code.push_str("}\n");
    
    Ok(code)
}