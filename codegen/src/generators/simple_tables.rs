//! Generator for simple tables from ExifTool

use anyhow::{Context, Result};
use std::fs;
use std::path::Path;
use std::collections::HashSet;
use crate::schemas::{ExtractedTable, TableConfig, TableEntry};
use crate::common::escape_string;

/// Generate simple tables from individual JSON files
pub fn generate_simple_tables(json_dir: &Path, output_dir: &str) -> Result<()> {
    // Read the configuration file to know what tables to expect
    let config_path = json_dir.parent().unwrap().parent().unwrap().join("simple_tables.json");
    let config_data = fs::read_to_string(&config_path)
        .with_context(|| format!("Failed to read config at {}", config_path.display()))?;
    
    let config: serde_json::Value = serde_json::from_str(&config_data)
        .with_context(|| "Failed to parse simple_tables.json config")?;
    
    let tables = config["tables"].as_array()
        .ok_or_else(|| anyhow::anyhow!("No tables array in config"))?;
    
    println!("  Processing {} simple tables from individual files...", tables.len());
    println!("  Input directory: {}", json_dir.display());
    println!("  Output directory: {}/simple_tables", output_dir);
    
    // Create subdirectory for simple tables
    let simple_tables_dir = format!("{}/simple_tables", output_dir);
    fs::create_dir_all(&simple_tables_dir)?;
    
    // Generate mod.rs for simple_tables module
    let mut mod_content = String::new();
    mod_content.push_str("//! Generated simple table modules\n");
    mod_content.push_str("//!\n");
    mod_content.push_str("//! This file is automatically generated by codegen.\n");
    mod_content.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n");
    
    // Track subdirectories we've created mod files for
    let mut subdirs_created = std::collections::HashSet::new();
    let mut processed_count = 0;
    
    // Process each table from individual JSON files
    for table_config in tables {
        let hash_name = table_config["hash_name"].as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing hash_name in config"))?;
        let constant_name = table_config["constant_name"].as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing constant_name in config"))?;
        
        // Generate JSON filename from constant name
        let json_filename = format!("{}.json", constant_name.to_lowercase());
        let json_path = json_dir.join(&json_filename);
        
        // Skip if JSON file doesn't exist
        if !json_path.exists() {
            println!("    ⚠️  Skipping {} (file not found: {})", hash_name, json_filename);
            continue;
        }
        
        // Read individual JSON file
        let json_data = fs::read_to_string(&json_path)
            .with_context(|| format!("Failed to read {}", json_path.display()))?;
        
        let table_data: serde_json::Value = serde_json::from_str(&json_data)
            .with_context(|| format!("Failed to parse {}", json_path.display()))?;
        
        // Convert to ExtractedTable format
        // For boolean_set, we need to handle numeric values
        let extraction_type = table_config["extraction_type"].as_str();
        let entries = if extraction_type == Some("boolean_set") {
            // Handle boolean_set entries which have numeric values
            let json_entries = table_data["entries"].as_array()
                .ok_or_else(|| anyhow::anyhow!("entries must be an array"))?;
            let mut converted_entries = Vec::new();
            for entry in json_entries {
                let key = entry["key"].as_str()
                    .ok_or_else(|| anyhow::anyhow!("key must be a string"))?;
                // For boolean_set, we don't need the value in the Rust code
                converted_entries.push(TableEntry {
                    key: Some(key.to_string()),
                    value: Some("1".to_string()), // Convert to string for compatibility
                    rust_compatible: None,
                    compatibility_notes: None,
                    extension: None,
                    entry_type: None,
                    target: None,
                    formats: None,
                    description: None,
                });
            }
            converted_entries
        } else {
            // Check if value_type is defined in config
            let has_numeric_values = table_config.get("value_type").is_some();
            
            if has_numeric_values {
                // Handle tables with numeric values
                let json_entries = table_data["entries"].as_array()
                    .ok_or_else(|| anyhow::anyhow!("entries must be an array"))?;
                let mut converted_entries = Vec::new();
                for entry in json_entries {
                    let key = entry["key"].as_str()
                        .ok_or_else(|| anyhow::anyhow!("key must be a string"))?;
                    // Convert numeric value to string
                    let value = match &entry["value"] {
                        serde_json::Value::Number(n) => n.to_string(),
                        serde_json::Value::String(s) => s.clone(),
                        _ => return Err(anyhow::anyhow!("value must be a string or number")),
                    };
                    converted_entries.push(TableEntry {
                        key: Some(key.to_string()),
                        value: Some(value),
                        rust_compatible: None,
                        compatibility_notes: None,
                        extension: None,
                        entry_type: None,
                        target: None,
                        formats: None,
                        description: None,
                    });
                }
                converted_entries
            } else {
                // Normal parsing for other types
                serde_json::from_value(table_data["entries"].clone())
                    .with_context(|| "Failed to parse table entries")?
            }
        };
        
        let extracted_table = ExtractedTable {
            config: serde_json::from_value(table_config.clone())
                .with_context(|| "Failed to parse table config")?,
            entries,
            entry_count: table_data["metadata"]["entry_count"].as_u64().unwrap_or(0) as usize,
            extraction_type: extraction_type.map(String::from),
        };
        // Generate code for this table
        let code = generate_table_code(hash_name, &extracted_table)?;
        
        // Write to file
        let output_path = format!("{}/{}", simple_tables_dir, extracted_table.config.output_file);
        
        // Create subdirectory if needed
        if let Some(parent) = std::path::Path::new(&output_path).parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("Failed to create directory for {}", output_path))?;
        }
        
        println!("    Writing to: {}", output_path);
        fs::write(&output_path, code)
            .with_context(|| format!("Failed to write to {}", output_path))?;
        
        // Handle module declarations for subdirectories
        let path_parts: Vec<&str> = extracted_table.config.output_file.split('/').collect();
        
        if path_parts.len() > 1 {
            // It's in a subdirectory
            let subdir = path_parts[0];
            
            // Create mod.rs for subdirectory if we haven't already
            if !subdirs_created.contains(subdir) {
                subdirs_created.insert(subdir.to_string());
                
                let subdir_path = format!("{}/{}", simple_tables_dir, subdir);
                fs::create_dir_all(&subdir_path)?;
                
                // Create a mod.rs for this subdirectory
                let subdir_mod_path = format!("{}/mod.rs", subdir_path);
                let mut subdir_mod_content = String::new();
                subdir_mod_content.push_str(&format!("//! {} table modules\n\n", subdir));
                
                // We'll append to this file for each module in this subdirectory
                fs::write(&subdir_mod_path, subdir_mod_content)?;
                
                // Add subdirectory to main mod.rs
                mod_content.push_str(&format!("pub mod {};\n", subdir));
            }
            
            // Append this module to the subdirectory's mod.rs
            let subdir_mod_path = format!("{}/{}/mod.rs", simple_tables_dir, subdir);
            let module_name = path_parts[1].strip_suffix(".rs").unwrap_or(path_parts[1]);
            let mut existing_content = fs::read_to_string(&subdir_mod_path)?;
            existing_content.push_str(&format!("pub mod {};\n", module_name));
            fs::write(&subdir_mod_path, existing_content)?;
        } else {
            // It's in the root simple_tables directory
            let module_name = extracted_table.config.output_file
                .strip_suffix(".rs")
                .unwrap_or(&extracted_table.config.output_file);
            mod_content.push_str(&format!("pub mod {};\n", module_name));
        }
        
        println!(
            "    ✓ Generated {} ({} entries)",
            extracted_table.config.output_file, extracted_table.entry_count
        );
        processed_count += 1;
    }
    
    // Write mod.rs
    fs::write(format!("{}/mod.rs", simple_tables_dir), mod_content)?;
    
    // Add re-exports to file_types mod.rs if it exists
    let file_types_mod_path = format!("{}/file_types/mod.rs", simple_tables_dir);
    if std::path::Path::new(&file_types_mod_path).exists() {
        let mut file_types_content = fs::read_to_string(&file_types_mod_path)?;
        file_types_content.push_str("\n// Re-export commonly used functions for convenience\n");
        // Only re-export from modules that actually exist
        file_types_content.push_str("pub use mime_types::lookup_mime_types;\n");
        file_types_content.push_str("pub use file_extensions::lookup_file_type_extensions;\n");
        file_types_content.push_str("pub use weak_magic_types::is_weak_magic;\n");
        fs::write(&file_types_mod_path, file_types_content)?;
    }
    
    println!("  ✓ Generated {} simple tables total", processed_count);
    Ok(())
}

/// Generate Rust code for a single simple table
fn generate_table_code(hash_name: &str, table_data: &ExtractedTable) -> Result<String> {
    let extraction_type = table_data.extraction_type.as_deref().unwrap_or("simple_table");
    
    match extraction_type {
        "regex_strings" => generate_regex_table_code(hash_name, table_data),
        "file_type_lookup" => generate_file_type_lookup_code(hash_name, table_data),
        "boolean_set" => generate_boolean_set_code(hash_name, table_data),
        _ => generate_simple_table_code(hash_name, table_data),
    }
}

/// Generate code for a simple lookup table
fn generate_simple_table_code(hash_name: &str, table_data: &ExtractedTable) -> Result<String> {
    let config = &table_data.config;
    let mut code = String::new();
    
    // File header
    let constant_name = config.constant_name.as_ref()
        .ok_or_else(|| anyhow::anyhow!("constant_name required for simple tables"))?;
    
    code.push_str(&format!(
        "//! Generated {} lookup table\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n//!\n//! Source: ExifTool {} {}\n//! Description: {}\n\n",
        constant_name.to_lowercase(),
        config.module,
        hash_name,
        config.description
    ));
    
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n\n");
    
    // Determine key type
    let key_type = config.key_type.as_ref()
        .ok_or_else(|| anyhow::anyhow!("key_type required for simple tables"))?;
    
    let key_rust_type = match key_type.as_str() {
        "u8" => "u8",
        "u16" => "u16",
        "u32" => "u32",
        "i8" => "i8",
        "i16" => "i16",
        "i32" => "i32",
        "f32" => "f32",
        "String" => "&'static str",
        _ => "&'static str",
    };
    
    // Determine value type
    let value_rust_type = if let Some(value_type) = &config.value_type {
        match value_type.as_str() {
            "u8" => "u8",
            "u16" => "u16",
            "u32" => "u32",
            "i8" => "i8",
            "i16" => "i16",
            "i32" => "i32",
            "f32" => "f32",
            _ => "&'static str",
        }
    } else {
        "&'static str"
    };
    
    // Generate static HashMap
    code.push_str(&format!(
        "/// {} lookup table\n/// Source: ExifTool {} {} ({} entries)\npub static {}: LazyLock<HashMap<{}, {}>> = LazyLock::new(|| {{\n",
        config.description,
        config.module,
        hash_name,
        table_data.entry_count,
        constant_name,
        key_rust_type,
        value_rust_type
    ));
    
    code.push_str("    let mut map = HashMap::new();\n");
    
    // Sort entries for deterministic output
    let mut sorted_entries = table_data.entries.clone();
    sorted_entries.sort_by(|a, b| {
        if key_type == "String" {
            a.key.as_ref().unwrap_or(&String::new()).cmp(b.key.as_ref().unwrap_or(&String::new()))
        } else {
            let a_num: i64 = a.key.as_ref().unwrap_or(&String::new()).parse().unwrap_or(0);
            let b_num: i64 = b.key.as_ref().unwrap_or(&String::new()).parse().unwrap_or(0);
            a_num.cmp(&b_num)
        }
    });
    
    // Add entries
    for entry in &sorted_entries {
        if let (Some(key), Some(value)) = (&entry.key, &entry.value) {
            let key_value = if key_type == "String" {
                // Handle single quote specially for Rust string literals
                if key == "'" {
                    "\"'\"".to_string()
                } else {
                    format!("\"{}\"", escape_string(key))
                }
            } else {
                key.clone()
            };
            
            // Handle value based on type
            let value_str = if config.value_type.is_some() && value_rust_type != "&'static str" {
                // Numeric value - use directly
                value.clone()
            } else {
                // String value - escape and quote
                format!("\"{}\"", escape_string(value))
            };
            
            code.push_str(&format!(
                "    map.insert({}, {});\n",
                key_value,
                value_str
            ));
        }
    }
    
    code.push_str("    map\n});\n\n");
    
    // Generate lookup function
    let fn_name = constant_name.to_lowercase();
    let fn_param_type = if key_type == "String" { "&str" } else { key_rust_type };
    
    code.push_str(&format!(
        "/// Look up {} value by key\npub fn lookup_{}(key: {}) -> Option<{}> {{\n",
        config.description.to_lowercase(),
        fn_name,
        fn_param_type,
        value_rust_type
    ));
    
    let key_ref = if key_type == "String" { "key" } else { "&key" };
    let return_expr = if value_rust_type == "&'static str" {
        format!("{}.get({}).copied()", constant_name, key_ref)
    } else {
        format!("{}.get({}).copied()", constant_name, key_ref)
    };
    code.push_str(&format!("    {}\n", return_expr));
    code.push_str("}\n");
    
    Ok(code)
}

/// Generate code for regex patterns table
fn generate_regex_table_code(hash_name: &str, table_data: &ExtractedTable) -> Result<String> {
    let config = &table_data.config;
    let mut code = String::new();
    
    let constant_name = config.constant_name.as_ref()
        .ok_or_else(|| anyhow::anyhow!("constant_name required for regex tables"))?;
    
    code.push_str(&format!(
        "//! Generated {} regex patterns table\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n//!\n//! Source: ExifTool {} {}\n//! Description: {}\n\n",
        constant_name.to_lowercase(),
        config.module,
        hash_name,
        config.description
    ));
    
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n\n");
    
    // Verify key type
    let key_type = config.key_type.as_ref()
        .ok_or_else(|| anyhow::anyhow!("key_type required for regex tables"))?;
    
    if key_type != "String" {
        return Err(anyhow::anyhow!(
            "regex_strings extraction only supports String key_type, got: {}",
            key_type
        ));
    }
    
    // Generate regex patterns table
    code.push_str(&format!(
        "/// {} regex patterns table\n/// Source: ExifTool {} {} ({} entries)\n/// Each value is a regex pattern for file type detection\npub static {}: LazyLock<HashMap<&'static str, &'static str>> = LazyLock::new(|| {{\n",
        config.description,
        config.module,
        hash_name,
        table_data.entry_count,
        constant_name
    ));
    
    code.push_str("    let mut map = HashMap::new();\n");
    
    // Sort entries
    let mut sorted_entries = table_data.entries.clone();
    sorted_entries.sort_by(|a, b| {
        a.key.as_ref().unwrap_or(&String::new()).cmp(b.key.as_ref().unwrap_or(&String::new()))
    });
    
    // Add entries with compatibility warnings
    for entry in &sorted_entries {
        if let (Some(key), Some(value)) = (&entry.key, &entry.value) {
            let compat_comment = if let Some(compat_note) = &entry.compatibility_notes {
                if !entry.rust_compatible.unwrap_or(true) {
                    format!(" // WARNING: {}", compat_note)
                } else {
                    String::new()
                }
            } else {
                String::new()
            };
            
            let pattern_str = if value.contains('"') {
                format!("\"{}\"", value.replace('\\', "\\\\").replace('"', "\\\""))
            } else {
                format!("r\"{}\"", value)
            };
            
            code.push_str(&format!(
                "    map.insert(\"{}\", {});{}\n",
                key, pattern_str, compat_comment
            ));
        }
    }
    
    code.push_str("    map\n});\n\n");
    
    // Generate lookup function
    let fn_name = constant_name.to_lowercase();
    code.push_str(&format!(
        "/// Look up {} regex pattern by key\npub fn lookup_{}(key: &str) -> Option<&'static str> {{\n",
        config.description.to_lowercase(),
        fn_name
    ));
    
    code.push_str(&format!("    {}.get(key).copied()\n", constant_name));
    code.push_str("}\n");
    
    Ok(code)
}

/// Generate code for file type lookup table
fn generate_file_type_lookup_code(hash_name: &str, table_data: &ExtractedTable) -> Result<String> {
    let config = &table_data.config;
    let mut code = String::new();
    
    let constant_name = config.constant_name.as_ref()
        .ok_or_else(|| anyhow::anyhow!("constant_name required for file type lookup"))?;
    
    code.push_str(&format!(
        "//! Generated {} file type lookup table\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n//!\n//! Source: ExifTool {} {}\n//! Description: {}\n\n",
        constant_name.to_lowercase(),
        config.module,
        hash_name,
        config.description
    ));
    
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n\n");
    
    // FileTypeEntry enum
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub enum FileTypeEntry {\n");
    code.push_str("    /// Simple alias pointing to another file type\n");
    code.push_str("    Alias(String),\n");
    code.push_str("    /// Full file type definition\n");
    code.push_str("    Definition {\n");
    code.push_str("        formats: Vec<String>,\n");
    code.push_str("        description: String,\n");
    code.push_str("    },\n");
    code.push_str("}\n\n");
    
    // Generate static HashMap
    code.push_str(&format!(
        "/// {} file type lookup table\n/// Source: ExifTool {} {} ({} entries)\npub static {}: LazyLock<HashMap<&'static str, FileTypeEntry>> = LazyLock::new(|| {{\n",
        config.description,
        config.module,
        hash_name,
        table_data.entry_count,
        constant_name
    ));
    
    code.push_str("    let mut map = HashMap::new();\n");
    
    // Sort entries
    let mut sorted_entries = table_data.entries.clone();
    sorted_entries.sort_by(|a, b| {
        let a_ext = a.extension.as_deref().unwrap_or("");
        let b_ext = b.extension.as_deref().unwrap_or("");
        a_ext.cmp(b_ext)
    });
    
    // Add entries
    for entry in &sorted_entries {
        if let Some(ext) = &entry.extension {
            if let Some(entry_type) = &entry.entry_type {
                match entry_type.as_str() {
                    "alias" => {
                        if let Some(target) = &entry.target {
                            code.push_str(&format!(
                                "    map.insert(\"{}\", FileTypeEntry::Alias(\"{}\".to_string()));\n",
                                ext, target
                            ));
                        }
                    }
                    "definition" => {
                        if let (Some(formats), Some(desc)) = (&entry.formats, &entry.description) {
                            code.push_str(&format!(
                                "    map.insert(\"{}\", FileTypeEntry::Definition {{\n",
                                ext
                            ));
                            
                            code.push_str("        formats: vec![");
                            for (i, fmt) in formats.iter().enumerate() {
                                if i > 0 { code.push_str(", "); }
                                code.push_str(&format!("\"{}\"", fmt));
                            }
                            code.push_str("].into_iter().map(String::from).collect(),\n");
                            
                            code.push_str(&format!(
                                "        description: \"{}\".to_string(),\n",
                                desc.replace('"', "\\\"")
                            ));
                            
                            code.push_str("    });\n");
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    
    code.push_str("    map\n});\n\n");
    
    // Generate lookup function
    let fn_name = constant_name.to_lowercase();
    code.push_str(&format!(
        "/// Look up file type by extension\npub fn lookup_{}(ext: &str) -> Option<&'static FileTypeEntry> {{\n",
        fn_name
    ));
    
    code.push_str("    let ext_upper = ext.to_uppercase();\n");
    code.push_str(&format!("    {}.get(ext_upper.as_str())\n", constant_name));
    code.push_str("}\n\n");
    
    // Helper function to resolve aliases
    code.push_str("/// Resolve file type aliases to their final definition\n");
    code.push_str("pub fn resolve_file_type(ext: &str) -> Option<(Vec<&'static str>, &'static str)> {\n");
    code.push_str("    let ext_upper = ext.to_uppercase();\n");
    code.push_str("    let mut current_ext = ext_upper.as_str();\n");
    code.push_str("    let mut seen = std::collections::HashSet::new();\n");
    code.push_str("    \n");
    code.push_str("    loop {\n");
    code.push_str(&format!("        match {}.get(current_ext) {{\n", constant_name));
    code.push_str("            Some(FileTypeEntry::Alias(target)) => {\n");
    code.push_str("                if !seen.insert(current_ext) {\n");
    code.push_str("                    return None; // Circular reference\n");
    code.push_str("                }\n");
    code.push_str("                current_ext = target;\n");
    code.push_str("            }\n");
    code.push_str("            Some(FileTypeEntry::Definition { description, formats }) => {\n");
    code.push_str("                return Some((formats.iter().map(|s| s.as_str()).collect(), description.as_str()));\n");
    code.push_str("            }\n");
    code.push_str("            None => return None,\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    // Additional helper functions
    code.push_str("/// Get the primary format (first format) for a file type\n");
    code.push_str("pub fn get_primary_format(ext: &str) -> Option<String> {\n");
    code.push_str("    resolve_file_type(ext).map(|(formats, _)| formats[0].to_string())\n");
    code.push_str("}\n\n");
    
    code.push_str("/// Check if a file type supports a specific format\n");
    code.push_str("pub fn supports_format(ext: &str, format: &str) -> bool {\n");
    code.push_str("    if let Some((formats, _)) = resolve_file_type(ext) {\n");
    code.push_str("        formats.contains(&format)\n");
    code.push_str("    } else {\n");
    code.push_str("        false\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    code.push_str("/// Get all extensions that support a given format\n");
    code.push_str("pub fn extensions_for_format(format: &str) -> Vec<String> {\n");
    code.push_str("    let mut extensions = Vec::new();\n");
    code.push_str("    \n");
    code.push_str(&format!("    for (ext, entry) in {}.iter() {{\n", constant_name));
    code.push_str("        match entry {\n");
    code.push_str("            FileTypeEntry::Definition { formats, .. } => {\n");
    code.push_str("                if formats.iter().any(|f| f == format) {\n");
    code.push_str("                    extensions.push(ext.to_string());\n");
    code.push_str("                }\n");
    code.push_str("            }\n");
    code.push_str("            FileTypeEntry::Alias(target) => {\n");
    code.push_str("                // Resolve alias and check\n");
    code.push_str("                if let Some((formats, _)) = resolve_file_type(target) {\n");
    code.push_str("                    if formats.contains(&format) {\n");
    code.push_str("                        extensions.push(ext.to_string());\n");
    code.push_str("                    }\n");
    code.push_str("                }\n");
    code.push_str("            }\n");
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("    \n");
    code.push_str("    extensions\n");
    code.push_str("}\n");
    
    Ok(code)
}

/// Generate code for a boolean set table (keys map to boolean values)
fn generate_boolean_set_code(hash_name: &str, table_data: &ExtractedTable) -> Result<String> {
    let config = &table_data.config;
    let mut code = String::new();
    
    let constant_name = config.constant_name.as_ref()
        .ok_or_else(|| anyhow::anyhow!("constant_name required for boolean sets"))?;
    
    code.push_str(&format!(
        "//! Generated {} boolean set table\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n//!\n//! Source: ExifTool {} {}\n//! Description: {}\n\n",
        constant_name.to_lowercase().replace('_', " "),
        config.module,
        hash_name,
        config.description
    ));
    
    code.push_str("use std::collections::HashSet;\n");
    code.push_str("use std::sync::LazyLock;\n\n");
    
    // Verify key type
    let key_type = config.key_type.as_ref()
        .ok_or_else(|| anyhow::anyhow!("key_type required for boolean sets"))?;
    
    if key_type != "String" {
        return Err(anyhow::anyhow!(
            "boolean_set extraction only supports String key_type, got: {}",
            key_type
        ));
    }
    
    // Generate boolean set table
    code.push_str(&format!(
        "/// {} boolean set table\n/// Source: ExifTool {} {} ({} entries)\n/// Each key represents a file type that has the property described\npub static {}: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {{\n",
        config.description,
        config.module,
        hash_name,
        table_data.entry_count,
        constant_name
    ));
    
    code.push_str("    let mut set = HashSet::new();\n");
    
    // Sort entries
    let mut sorted_entries = table_data.entries.clone();
    sorted_entries.sort_by(|a, b| {
        a.key.as_ref().unwrap_or(&String::new()).cmp(b.key.as_ref().unwrap_or(&String::new()))
    });
    
    // Add entries (only keys where value is truthy)
    for entry in &sorted_entries {
        if let Some(key) = &entry.key {
            // In the JSON, values are stored as numbers (1 for true)
            // We only add keys that have truthy values
            code.push_str(&format!("    set.insert(\"{}\");\n", escape_string(key)));
        }
    }
    
    code.push_str("    set\n});\n\n");
    
    // Generate check function
    let fn_name = constant_name.to_lowercase();
    code.push_str(&format!(
        "/// Check if a file type is in the {} set\npub fn is_{}(file_type: &str) -> bool {{\n",
        config.description.to_lowercase(),
        fn_name.strip_suffix("_types").unwrap_or(&fn_name)
    ));
    
    code.push_str(&format!("    {}.contains(file_type)\n", constant_name));
    code.push_str("}\n");
    
    Ok(code)
}