//! Macro-based code generation for reduced boilerplate
//!
//! This module generates code that uses the shared macros from src/generated/macros.rs
//! to significantly reduce boilerplate in generated lookup tables.

use anyhow::{Context, Result};
use crate::schemas::ExtractedTable;
use crate::common::escape_string;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Configuration for a source module (e.g., Canon_pm, Nikon_pm)
pub struct ModuleConfig {
    pub module_name: String,
    pub source_path: Option<String>,
    pub simple_tables: Vec<(ExtractedTable, Option<String>)>,
    pub print_conv_tables: Vec<(ExtractedTable, Option<String>)>,
    pub boolean_sets: Vec<(ExtractedTable, Option<String>)>,
    pub regex_patterns: Vec<(ExtractedTable, Option<String>)>,
    pub file_type_lookups: Vec<(ExtractedTable, Option<String>)>,
}

/// Generate a complete module file using macro-based approach
pub fn generate_module_file(config: &ModuleConfig, output_dir: &str) -> Result<()> {
    let module_dir = Path::new(output_dir).join(&config.module_name);
    fs::create_dir_all(&module_dir)?;
    
    let mut code = String::new();
    
    // File header
    code.push_str(&format!(
        "//! Generated lookup tables from ExifTool {}\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n",
        config.module_name.replace("_pm", ".pm")
    ));
    
    // Import necessary types
    let mut imports = vec![];
    if !config.simple_tables.is_empty() || !config.print_conv_tables.is_empty() || 
       !config.file_type_lookups.is_empty() || !config.regex_patterns.is_empty() {
        imports.push("HashMap");
    }
    if !config.boolean_sets.is_empty() {
        imports.push("HashSet");
    }
    
    if !imports.is_empty() {
        code.push_str(&format!("use std::collections::{{{}}};\n", imports.join(", ")));
    }
    code.push_str("use std::sync::LazyLock;\n");
    
    // Add regex import if needed
    if !config.regex_patterns.is_empty() {
        code.push_str("use regex::Regex;\n");
    }
    
    code.push_str("\n");
    
    // Generate simple tables
    if !config.simple_tables.is_empty() {
        code.push_str("// Simple lookup tables\n");
        for (table, value_type) in &config.simple_tables {
            code.push_str(&generate_simple_table_macro(table, value_type.as_deref())?);
            code.push_str("\n");
        }
    }
    
    // Generate boolean sets
    if !config.boolean_sets.is_empty() {
        code.push_str("// Boolean sets\n");
        for (table, _) in &config.boolean_sets {
            code.push_str(&generate_boolean_set_macro(table)?);
            code.push_str("\n");
        }
    }
    
    // Generate regex patterns
    if !config.regex_patterns.is_empty() {
        code.push_str("// Regex patterns\n");
        for (table, _) in &config.regex_patterns {
            code.push_str(&generate_regex_pattern_macro(table)?);
            code.push_str("\n");
        }
    }
    
    // TODO: Add print_conv and file_type_lookup generation when needed
    
    // Write the module file
    let module_file = module_dir.join("mod.rs");
    fs::write(&module_file, code)?;
    
    println!("âœ… Generated {}", module_file.display());
    
    Ok(())
}

/// Generate a simple table with direct const and function (no macros)
fn generate_simple_table_macro(table: &ExtractedTable, config_value_type: Option<&str>) -> Result<String> {
    let metadata = &table.metadata;
    let mut code = String::new();
    
    // Add documentation comment
    code.push_str(&format!(
        "// {}\n// Source: ExifTool {} {} ({} entries)\n",
        metadata.description,
        table.source.module,
        table.source.hash_name,
        metadata.entry_count
    ));
    
    // Determine types
    let (key_type, lookup_key_type) = match metadata.key_type.as_str() {
        "String" => ("&'static str", "&str"),
        other => (other, other),
    };
    
    // Use value_type from config if provided, otherwise default
    let value_type = config_value_type.unwrap_or("&'static str");
    
    // Generate the static HashMap
    code.push_str(&format!(
        "pub static {}: LazyLock<HashMap<{}, {}>> = LazyLock::new(|| {{\n",
        metadata.constant_name, key_type, value_type
    ));
    code.push_str("    let mut map = HashMap::new();\n");
    
    // Sort entries for deterministic output
    let mut sorted_entries = table.entries.clone();
    sorted_entries.sort_by(|a, b| {
        if metadata.key_type == "String" {
            a.key.as_ref().unwrap_or(&String::new()).cmp(b.key.as_ref().unwrap_or(&String::new()))
        } else {
            let a_num: i64 = a.key.as_ref().unwrap_or(&String::new()).parse().unwrap_or(0);
            let b_num: i64 = b.key.as_ref().unwrap_or(&String::new()).parse().unwrap_or(0);
            a_num.cmp(&b_num)
        }
    });
    
    // Add entries
    for entry in &sorted_entries {
        if let (Some(key), Some(value)) = (&entry.key, &entry.value) {
            let key_literal = format_key_literal(&metadata.key_type, key)?;
            let value_literal = format_value_literal(&value_type, value)?;
            code.push_str(&format!("    map.insert({}, {});\n", key_literal, value_literal));
        }
    }
    
    code.push_str("    map\n});\n\n");
    
    // Generate the lookup function
    let function_name = format!("lookup_{}", metadata.constant_name.to_lowercase());
    code.push_str(&format!(
        "/// Look up {} value by key\n",
        metadata.constant_name
    ));
    code.push_str(&format!(
        "pub fn {}(key: {}) -> Option<{}> {{\n",
        function_name, lookup_key_type, value_type
    ));
    // Use .copied() for Copy types, .cloned() for non-Copy types like String
    if value_type.contains("String") || value_type == "String" {
        code.push_str(&format!("    {}.get(&key).cloned()\n", metadata.constant_name));
    } else {
        code.push_str(&format!("    {}.get(&key).copied()\n", metadata.constant_name));
    }
    code.push_str("}\n");
    
    Ok(code)
}

/// Generate a boolean set with direct const and function (no macros)
fn generate_boolean_set_macro(table: &ExtractedTable) -> Result<String> {
    let metadata = &table.metadata;
    let mut code = String::new();
    
    // Add documentation comment
    code.push_str(&format!(
        "// {}\n// Source: ExifTool {} {} ({} entries)\n",
        metadata.description,
        table.source.module,
        table.source.hash_name,
        metadata.entry_count
    ));
    
    let key_type = &metadata.key_type;
    let rust_key_type = if key_type == "String" {
        "String"
    } else {
        "&'static str"
    };
    
    // Generate the static HashSet
    code.push_str(&format!(
        "pub static {}: LazyLock<HashSet<{}>> = LazyLock::new(|| {{\n",
        metadata.constant_name, rust_key_type
    ));
    code.push_str("    let mut set = HashSet::new();\n");
    
    // Sort entries for deterministic output
    let mut sorted_entries = table.entries.clone();
    sorted_entries.sort_by(|a, b| {
        a.key.as_ref().unwrap_or(&String::new()).cmp(b.key.as_ref().unwrap_or(&String::new()))
    });
    
    // Add entries (only keys, values are ignored for sets)
    for entry in &sorted_entries {
        if let Some(key) = &entry.key {
            let key_literal = format_key_literal(&key_type, key)?;
            if key_type == "String" {
                code.push_str(&format!("    set.insert({}.to_string());\n", key_literal));
            } else {
                code.push_str(&format!("    set.insert({});\n", key_literal));
            }
        }
    }
    
    code.push_str("    set\n});\n\n");
    
    // Generate the check function
    let function_name = format!("is_{}", metadata.constant_name.to_lowercase());
    code.push_str(&format!(
        "/// Check if key is in {}\n",
        metadata.constant_name
    ));
    code.push_str(&format!(
        "pub fn {}(key: &str) -> bool {{\n",
        function_name
    ));
    code.push_str(&format!("    {}.contains(key)\n", metadata.constant_name));
    code.push_str("}\n");
    
    Ok(code)
}

/// Generate regex patterns with direct const (no macros)
fn generate_regex_pattern_macro(table: &ExtractedTable) -> Result<String> {
    let metadata = &table.metadata;
    let mut code = String::new();
    
    // Add documentation comment
    code.push_str(&format!(
        "// {}\n// Source: ExifTool {} {} ({} entries)\n",
        metadata.description,
        table.source.module,
        table.source.hash_name,
        metadata.entry_count
    ));
    
    // Generate the static HashMap of compiled regex patterns
    code.push_str(&format!(
        "pub static {}: LazyLock<HashMap<&'static str, Regex>> = LazyLock::new(|| {{\n",
        metadata.constant_name
    ));
    code.push_str("    let mut map = HashMap::new();\n");
    
    // Sort entries for deterministic output
    let mut sorted_entries = table.entries.clone();
    sorted_entries.sort_by(|a, b| {
        a.key.as_ref().unwrap_or(&String::new()).cmp(b.key.as_ref().unwrap_or(&String::new()))
    });
    
    // Add entries
    for entry in &sorted_entries {
        if let (Some(key), Some(value)) = (&entry.key, &entry.value) {
            let key_literal = format!("\"{}\"", escape_string(key));
            // Extract regex pattern from JSON value
            let pattern = match value {
                serde_json::Value::String(s) => s.clone(),
                _ => value.to_string(),
            };
            code.push_str(&format!(
                "    map.insert({}, Regex::new(r#\"{}\"#).unwrap());\n", 
                key_literal, pattern
            ));
        }
    }
    
    code.push_str("    map\n});\n\n");
    
    // Generate a lookup function if useful
    let function_name = format!("get_{}_pattern", metadata.constant_name.to_lowercase());
    code.push_str(&format!(
        "/// Get regex pattern for key from {}\n",
        metadata.constant_name
    ));
    code.push_str(&format!(
        "pub fn {}(key: &str) -> Option<&'static Regex> {{\n",
        function_name
    ));
    code.push_str(&format!("    {}.get(key)\n", metadata.constant_name));
    code.push_str("}\n");
    
    Ok(code)
}

/// Format a key literal based on its type
fn format_key_literal(key_type: &str, key: &str) -> Result<String> {
    match key_type {
        "String" => {
            // Handle single quote specially for Rust string literals
            if key == "'" {
                Ok("\"'\"".to_string())
            } else {
                Ok(format!("\"{}\"", escape_string(key)))
            }
        }
        _ => Ok(key.to_string()), // Numeric types
    }
}

/// Format a value literal based on its type
fn format_value_literal(value_type: &str, value: &serde_json::Value) -> Result<String> {
    match value_type {
        "&'static str" => {
            let value_str = match value {
                serde_json::Value::String(s) => s.clone(),
                serde_json::Value::Number(n) => n.to_string(),
                serde_json::Value::Bool(b) => b.to_string(),
                _ => value.to_string(),
            };
            Ok(format!("\"{}\"", escape_string(&value_str)))
        }
        "u32" | "u16" | "u8" | "i32" | "i16" | "i8" | "f32" | "f64" => {
            match value {
                serde_json::Value::Number(n) => Ok(n.to_string()),
                _ => Ok(value.to_string()),
            }
        }
        _ => Ok(format!("\"{}\"", escape_string(&value.to_string()))),
    }
}

/// Process configuration files from a directory and generate module
pub fn process_config_directory(
    config_dir: &Path,
    module_name: &str,
    extracted_tables: &HashMap<String, ExtractedTable>,
    output_dir: &str,
) -> Result<()> {
    let mut config = ModuleConfig {
        module_name: module_name.to_string(),
        source_path: None,
        simple_tables: Vec::new(),
        print_conv_tables: Vec::new(),
        boolean_sets: Vec::new(),
        regex_patterns: Vec::new(),
        file_type_lookups: Vec::new(),
    };
    
    // Read configuration files from the directory
    if config_dir.exists() {
        // Read simple_table.json
        let simple_table_path = config_dir.join("simple_table.json");
        if simple_table_path.exists() {
            let (tables, source) = read_table_config(&simple_table_path, extracted_tables)?;
            config.simple_tables = tables;
            config.source_path = Some(source);
        }
        
        // Read print_conv.json
        let print_conv_path = config_dir.join("print_conv.json");
        if print_conv_path.exists() {
            let (tables, _source) = read_table_config(&print_conv_path, extracted_tables)?;
            config.print_conv_tables = tables;
        }
        
        // Read boolean_set.json
        let boolean_set_path = config_dir.join("boolean_set.json");
        if boolean_set_path.exists() {
            let (tables, _source) = read_table_config(&boolean_set_path, extracted_tables)?;
            config.boolean_sets = tables;
        }
        
        // Read regex_patterns.json
        let regex_patterns_path = config_dir.join("regex_patterns.json");
        if regex_patterns_path.exists() {
            let (tables, _source) = read_table_config(&regex_patterns_path, extracted_tables)?;
            config.regex_patterns = tables;
        }
        
        // Read file_type_lookup.json
        let file_type_lookup_path = config_dir.join("file_type_lookup.json");
        if file_type_lookup_path.exists() {
            let (tables, _source) = read_table_config(&file_type_lookup_path, extracted_tables)?;
            config.file_type_lookups = tables;
        }
    }
    
    // Generate the module file
    if !config.simple_tables.is_empty() || 
       !config.print_conv_tables.is_empty() || 
       !config.boolean_sets.is_empty() ||
       !config.regex_patterns.is_empty() ||
       !config.file_type_lookups.is_empty() {
        generate_module_file(&config, output_dir)?;
    }
    
    Ok(())
}

/// Read table configuration and match with extracted data
fn read_table_config(
    config_path: &Path,
    extracted_tables: &HashMap<String, ExtractedTable>,
) -> Result<(Vec<(ExtractedTable, Option<String>)>, String)> {
    let config_json = fs::read_to_string(config_path)
        .with_context(|| format!("Failed to read {}", config_path.display()))?;
    let config: TableConfig = serde_json::from_str(&config_json)
        .with_context(|| format!("Failed to parse JSON from {}", config_path.display()))?;
    
    let mut tables = Vec::new();
    for table_ref in &config.tables {
        if let Some(extracted_table) = extracted_tables.get(&table_ref.hash_name).cloned() {
            // Update metadata with values from config
            let mut table_clone = extracted_table;
            table_clone.metadata.constant_name = table_ref.constant_name.clone();
            table_clone.metadata.description = table_ref.description.clone();
            tables.push((table_clone, table_ref.value_type.clone()));
        } else {
            eprintln!("Warning: Table {} not found in extracted data", table_ref.hash_name);
        }
    }
    
    Ok((tables, config.source))
}

#[derive(serde::Deserialize)]
struct TableConfig {
    source: String,
    description: String,
    tables: Vec<TableReference>,
}

#[derive(serde::Deserialize)]
struct TableReference {
    hash_name: String,
    constant_name: String,
    #[serde(default)]
    key_type: Option<String>,
    #[serde(default)]
    value_type: Option<String>,
    description: String,
}