//! Boolean set generator for membership testing

use anyhow::Result;
use crate::schemas::ExtractedTable;
use crate::common::escape_string;

/// Generate code for a boolean set table (keys map to boolean values)
pub fn generate_boolean_set(
    hash_name: &str,
    table_data: &ExtractedTable,
) -> Result<String> {
    let metadata = &table_data.metadata;
    let source = &table_data.source;
    let mut code = String::new();
    
    let constant_name = &metadata.constant_name;
    
    code.push_str(&format!(
        "//! Generated {} boolean set table\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n//!\n//! Source: ExifTool {} {}\n//! Description: {}\n\n",
        constant_name.to_lowercase().replace('_', " "),
        source.module,
        hash_name,
        metadata.description
    ));
    
    code.push_str("use std::collections::HashSet;\n");
    code.push_str("use std::sync::LazyLock;\n\n");
    
    // Verify key type
    let key_type = &metadata.key_type;
    
    if key_type != "String" {
        return Err(anyhow::anyhow!(
            "boolean_set extraction only supports String key_type, got: {}",
            key_type
        ));
    }
    
    // Generate boolean set table
    code.push_str(&format!(
        "/// {} boolean set table\n/// Source: ExifTool {} {} ({} entries)\n/// Each key represents a file type that has the property described\npub static {}: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {{\n",
        metadata.description,
        source.module,
        hash_name,
        metadata.entry_count,
        constant_name
    ));
    
    code.push_str("    let mut set = HashSet::new();\n");
    
    // Sort entries
    let mut sorted_entries = table_data.entries.clone();
    sorted_entries.sort_by(|a, b| {
        a.key.as_ref().unwrap_or(&String::new()).cmp(b.key.as_ref().unwrap_or(&String::new()))
    });
    
    // Add entries (only keys where value is truthy)
    for entry in &sorted_entries {
        if let Some(key) = &entry.key {
            // In the JSON, values are stored as numbers (1 for true)
            // We only add keys that have truthy values
            code.push_str(&format!("    set.insert(\"{}\");\n", escape_string(key)));
        }
    }
    
    code.push_str("    set\n});\n\n");
    
    // Generate check function
    let fn_name = constant_name.to_lowercase();
    code.push_str(&format!(
        "/// Check if a file type is in the {} set\npub fn is_{}(file_type: &str) -> bool {{\n",
        metadata.description.to_lowercase(),
        fn_name.strip_suffix("_types").unwrap_or(&fn_name)
    ));
    
    code.push_str(&format!("    {}.contains(file_type)\n", constant_name));
    code.push_str("}\n");
    
    Ok(code)
}