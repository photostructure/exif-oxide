//! Generator for the main module file that ties everything together

use anyhow::Result;
use std::fs;

/// Generate the main mod.rs file for generated code
pub fn generate_mod_file(output_dir: &str) -> Result<()> {
    let mut code = String::new();

    // File header
    code.push_str("//! Generated code module\n");
    code.push_str("//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n");
    code.push_str("//!\n");
    code.push_str("//! This module re-exports all generated code for easy access.\n\n");

    // Check which files exist and include them
    let entries = std::fs::read_dir(output_dir)?;
    let mut modules = Vec::new();
    
    for entry in entries {
        let entry = entry?;
        let path = entry.path();
        
        if path.is_file() {
            if let Some(name) = path.file_stem() {
                let name = name.to_string_lossy();
                if name != "mod" && path.extension().map_or(false, |ext| ext == "rs") {
                    modules.push(name.to_string());
                }
            }
        } else if path.is_dir() {
            if let Some(name) = path.file_name() {
                let name = name.to_string_lossy();
                modules.push(name.to_string());
            }
        }
    }
    
    // Sort modules for deterministic output
    modules.sort();
    
    // Add module declarations
    for module in &modules {
        code.push_str(&format!("pub mod {};\n", module));
    }
    
    code.push_str("\n");
    
    // Re-export commonly used items
    code.push_str("// Re-export commonly used types and functions\n");
    
    if modules.contains(&"tags".to_string()) {
        code.push_str("pub use tags::{TagDef, TagFormat, TAG_TABLE, TAG_LOOKUP, lookup_tag_by_id, lookup_tag_by_name};\n");
        // Compatibility aliases
        code.push_str("pub use tags::TAG_LOOKUP as TAG_BY_ID;\n");
        code.push_str("pub use tags::TAG_NAME_LOOKUP as TAG_BY_NAME;\n");
        code.push_str("pub use tags::TAG_TABLE as EXIF_MAIN_TAGS;\n");
    }
    
    if modules.contains(&"composite_tags".to_string()) {
        code.push_str("pub use composite_tags::{CompositeTagDef, COMPOSITE_TAGS, COMPOSITE_TAG_LOOKUP, lookup_composite_tag};\n");
    }
    
    if modules.contains(&"conversion_refs".to_string()) {
        code.push_str("pub use conversion_refs::{PRINT_CONV_REFS, VALUE_CONV_REFS, has_print_conv_ref, has_value_conv_ref};\n");
        // Compatibility aliases
        code.push_str("pub use conversion_refs::PRINT_CONV_REFS as REQUIRED_PRINT_CONV;\n");
        code.push_str("pub use conversion_refs::VALUE_CONV_REFS as REQUIRED_VALUE_CONV;\n");
    }
    
    if modules.contains(&"supported_tags".to_string()) {
        code.push_str("pub use supported_tags::{\n");
        code.push_str("    SUPPORTED_TAG_COUNT, SUPPORTED_COMPOSITE_TAG_COUNT, TOTAL_SUPPORTED_TAG_COUNT,\n");
        code.push_str("    SUPPORTED_TAG_NAMES, SUPPORTED_COMPOSITE_TAG_NAMES,\n");
        code.push_str("    tag_counts_by_group, supported_tag_summary\n");
        code.push_str("};\n");
    }
    
    // Add simple table re-exports for backward compatibility
    if modules.contains(&"simple_tables".to_string()) {
        code.push_str("\n// Re-export simple table modules for backward compatibility\n");
        code.push_str("pub use simple_tables::canon;\n");
        code.push_str("pub use simple_tables::nikon;\n");
        code.push_str("pub use simple_tables::exif;\n");
        code.push_str("pub use simple_tables::file_types;\n");
    }
    
    code.push_str("\n");
    
    // Add convenience functions
    code.push_str("/// Initialize all lazy static data structures\n");
    code.push_str("/// This can be called during startup to avoid lazy initialization costs later\n");
    code.push_str("pub fn initialize_all() {\n");
    
    if modules.contains(&"tags".to_string()) {
        code.push_str("    let _ = &*TAG_LOOKUP;\n");
    }
    
    if modules.contains(&"composite_tags".to_string()) {
        code.push_str("    let _ = &*COMPOSITE_TAG_LOOKUP;\n");
    }
    
    if modules.contains(&"conversion_refs".to_string()) {
        code.push_str("    let _ = &*PRINT_CONV_REFS;\n");
        code.push_str("    let _ = &*VALUE_CONV_REFS;\n");
    }
    
    code.push_str("}\n");

    // Write file
    let output_path = format!("{}/mod.rs", output_dir);
    fs::write(&output_path, code)?;
    println!("  âœ“ Generated {}", output_path);

    Ok(())
}