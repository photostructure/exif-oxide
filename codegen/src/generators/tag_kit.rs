//! Generator for unified tag kits with embedded PrintConv
//!
//! This generator creates tag definitions that include their PrintConv
//! implementations, solving the problem of tag ID/PrintConv mismatches.

use anyhow::Result;
use std::{fs, collections::HashMap};
use crate::common::escape_string;
use crate::schemas::tag_kit::TagKitExtraction;

/// Generate tag kit code from extracted data
#[allow(dead_code)]
pub fn generate_tag_kit(
    module_name: &str,
    extraction: &TagKitExtraction,
    output_dir: &str,
) -> Result<()> {
    let mut code = String::new();
    
    // File header
    code.push_str("//! Tag kits with embedded PrintConv for ");
    code.push_str(&extraction.source.module);
    code.push_str("\n//!\n");
    code.push_str("//! This file is automatically generated by codegen.\n");
    code.push_str("//! DO NOT EDIT MANUALLY - changes will be overwritten.\n");
    code.push_str("//!\n");
    code.push_str("//! Generated from: ");
    code.push_str(&extraction.source.module);
    code.push_str(" table: ");
    code.push_str(&extraction.source.table);
    code.push_str("\n\n");
    // NOTE: Do NOT add extraction timestamps here - they create spurious git diffs
    // that make it impossible to track real changes to generated code
    
    // Imports
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n");
    code.push_str("use crate::types::TagValue;\n");
    code.push_str("use crate::expressions::ExpressionEvaluator;\n\n");
    
    // Tag kit definition struct
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub struct TagKitDef {\n");
    code.push_str("    pub id: u32,\n");
    code.push_str("    pub name: &'static str,\n");
    code.push_str("    pub format: &'static str,\n");
    code.push_str("    pub groups: HashMap<&'static str, &'static str>,\n");
    code.push_str("    pub writable: bool,\n");
    code.push_str("    pub notes: Option<&'static str>,\n");
    code.push_str("    pub print_conv: PrintConvType,\n");
    code.push_str("    pub value_conv: Option<&'static str>,\n");
    code.push_str("}\n\n");
    
    // PrintConv type enum
    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("pub enum PrintConvType {\n");
    code.push_str("    None,\n");
    code.push_str("    Simple(&'static HashMap<String, &'static str>),\n");
    code.push_str("    Expression(&'static str),\n");
    code.push_str("    Manual(&'static str),\n");
    code.push_str("}\n\n");
    
    // Generate simple lookup tables
    let mut simple_tables = HashMap::new();
    for (idx, tag_kit) in extraction.tag_kits.iter().enumerate() {
        if tag_kit.print_conv_type == "Simple" {
            if let Some(data) = &tag_kit.print_conv_data {
                if let Some(obj) = data.as_object() {
                    let table_name = format!("PRINT_CONV_{idx}");
                    simple_tables.insert(tag_kit.tag_id.clone(), table_name.clone());
                    
                    // Generate the lookup table
                    code.push_str(&format!("static {table_name}: LazyLock<HashMap<String, &'static str>> = LazyLock::new(|| {{\n"));
                    code.push_str("    let mut map = HashMap::new();\n");
                    
                    // Sort keys for deterministic output
                    let mut sorted_keys: Vec<&String> = obj.keys().collect();
                    sorted_keys.sort();
                    
                    for key in sorted_keys {
                        let value = &obj[key];
                        if let Some(val_str) = value.as_str() {
                            code.push_str(&format!("    map.insert(\"{}\".to_string(), \"{}\");\n", 
                                escape_string(key), escape_string(val_str)));
                        }
                    }
                    
                    code.push_str("    map\n");
                    code.push_str("});\n\n");
                }
            }
        }
    }
    
    // Generate tag kits array
    let const_name = format!("{}_TAG_KITS", module_name.to_uppercase());
    code.push_str(&format!("pub static {const_name}: LazyLock<HashMap<u32, TagKitDef>> = LazyLock::new(|| {{\n"));
    code.push_str("    let mut map = HashMap::new();\n");
    
    for tag_kit in &extraction.tag_kits {
        // Parse tag ID
        let id = if tag_kit.tag_id.starts_with("0x") {
            u32::from_str_radix(&tag_kit.tag_id[2..], 16)?
        } else {
            tag_kit.tag_id.parse::<u32>()?
        };
        
        code.push_str(&format!("    map.insert({id}, TagKitDef {{\n"));
        code.push_str(&format!("        id: {id},\n"));
        code.push_str(&format!("        name: \"{}\",\n", escape_string(&tag_kit.name)));
        code.push_str(&format!("        format: \"{}\",\n", escape_string(&tag_kit.format)));
        
        // Groups
        code.push_str("        groups: {\n");
        code.push_str("            let mut groups = HashMap::new();\n");
        for (key, value) in &tag_kit.groups {
            code.push_str(&format!("            groups.insert(\"{}\", \"{}\");\n", 
                escape_string(key), escape_string(value)));
        }
        code.push_str("            groups\n");
        code.push_str("        },\n");
        
        // Writable
        let writable = match &tag_kit.writable {
            Some(serde_json::Value::Bool(b)) => *b,
            Some(serde_json::Value::String(_)) => true,
            _ => false,
        };
        code.push_str(&format!("        writable: {writable},\n"));
        
        // Notes
        if let Some(notes) = &tag_kit.notes {
            let trimmed_notes = notes.trim();
            if !trimmed_notes.is_empty() {
                code.push_str(&format!("        notes: Some(\"{}\"),\n", escape_string(trimmed_notes)));
            } else {
                code.push_str("        notes: None,\n");
            }
        } else {
            code.push_str("        notes: None,\n");
        }
        
        // PrintConv
        match tag_kit.print_conv_type.as_str() {
            "None" => {
                code.push_str("        print_conv: PrintConvType::None,\n");
            }
            "Simple" => {
                if let Some(table_name) = simple_tables.get(&tag_kit.tag_id) {
                    code.push_str(&format!("        print_conv: PrintConvType::Simple(&{table_name}),\n"));
                } else {
                    code.push_str("        print_conv: PrintConvType::None,\n");
                }
            }
            "Expression" => {
                if let Some(expr) = &tag_kit.print_conv_data {
                    if let Some(expr_str) = expr.as_str() {
                        code.push_str(&format!("        print_conv: PrintConvType::Expression(\"{}\"),\n", 
                            escape_string(expr_str)));
                    } else {
                        code.push_str("        print_conv: PrintConvType::None,\n");
                    }
                } else {
                    code.push_str("        print_conv: PrintConvType::None,\n");
                }
            }
            "Manual" => {
                if let Some(func_name) = &tag_kit.print_conv_data {
                    if let Some(name_str) = func_name.as_str() {
                        code.push_str(&format!("        print_conv: PrintConvType::Manual(\"{}\"),\n", 
                            escape_string(name_str)));
                    } else {
                        code.push_str("        print_conv: PrintConvType::Manual(\"unknown\"),\n");
                    }
                } else {
                    code.push_str("        print_conv: PrintConvType::Manual(\"unknown\"),\n");
                }
            }
            _ => {
                code.push_str("        print_conv: PrintConvType::None,\n");
            }
        }
        
        // ValueConv
        if let Some(value_conv) = &tag_kit.value_conv {
            code.push_str(&format!("        value_conv: Some(\"{}\"),\n", escape_string(value_conv)));
        } else {
            code.push_str("        value_conv: None,\n");
        }
        
        code.push_str("    });\n\n");
    }
    
    code.push_str("    map\n");
    code.push_str("});\n\n");
    
    // Helper function to apply PrintConv
    code.push_str("/// Apply PrintConv for a tag from this module\n");
    code.push_str("pub fn apply_print_conv(\n");
    code.push_str("    tag_id: u32,\n");
    code.push_str("    value: &TagValue,\n");
    code.push_str("    evaluator: &mut ExpressionEvaluator,\n");
    code.push_str("    errors: &mut Vec<String>,\n");
    code.push_str("    warnings: &mut Vec<String>,\n");
    code.push_str(") -> TagValue {\n");
    code.push_str(&format!("    if let Some(tag_kit) = {const_name}.get(&tag_id) {{\n"));
    code.push_str("        match &tag_kit.print_conv {\n");
    code.push_str("            PrintConvType::None => value.clone(),\n");
    code.push_str("            PrintConvType::Simple(lookup) => {\n");
    code.push_str("                // Convert value to string key for lookup\n");
    code.push_str("                let key = match value {\n");
    code.push_str("                    TagValue::U8(v) => v.to_string(),\n");
    code.push_str("                    TagValue::U16(v) => v.to_string(),\n");
    code.push_str("                    TagValue::U32(v) => v.to_string(),\n");
    code.push_str("                    TagValue::I16(v) => v.to_string(),\n");
    code.push_str("                    TagValue::I32(v) => v.to_string(),\n");
    code.push_str("                    TagValue::String(s) => s.clone(),\n");
    code.push_str("                    _ => return value.clone(),\n");
    code.push_str("                };\n");
    code.push_str("                \n");
    code.push_str("                if let Some(result) = lookup.get(&key) {\n");
    code.push_str("                    TagValue::String(result.to_string())\n");
    code.push_str("                } else {\n");
    code.push_str("                    TagValue::String(format!(\"Unknown ({})\", value))\n");
    code.push_str("                }\n");
    code.push_str("            }\n");
    code.push_str("            PrintConvType::Expression(expr) => {\n");
    code.push_str("                // TODO: Implement expression evaluation\n");
    code.push_str("                warnings.push(format!(\"Expression PrintConv not yet implemented for tag {}: {}\", \n");
    code.push_str("                    tag_kit.name, expr));\n");
    code.push_str("                value.clone()\n");
    code.push_str("            }\n");
    code.push_str("            PrintConvType::Manual(func_name) => {\n");
    code.push_str("                // TODO: Look up in manual registry\n");
    code.push_str("                warnings.push(format!(\"Manual PrintConv '{}' not found for tag {}\", \n");
    code.push_str("                    func_name, tag_kit.name));\n");
    code.push_str("                value.clone()\n");
    code.push_str("            }\n");
    code.push_str("        }\n");
    code.push_str("    } else {\n");
    code.push_str("        // Tag not found in kit\n");
    code.push_str("        value.clone()\n");
    code.push_str("    }\n");
    code.push_str("}\n");
    
    // Write to file
    let output_path = format!("{}/{}_tag_kit.rs", output_dir, module_name.to_lowercase());
    fs::write(&output_path, code)?;
    
    println!("  âœ“ Generated tag kit for {} with {} tags ({} simple, {} expression, {} manual)", 
        module_name,
        extraction.tag_kits.len(),
        extraction.tag_kits.iter().filter(|t| t.print_conv_type == "Simple").count(),
        extraction.tag_kits.iter().filter(|t| t.print_conv_type == "Expression").count(),
        extraction.tag_kits.iter().filter(|t| t.print_conv_type == "Manual").count()
    );
    
    Ok(())
}