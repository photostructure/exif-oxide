//! Standard lookup table generator for simple key-value mappings

use anyhow::Result;
use crate::schemas::ExtractedTable;
use crate::common::escape_string;

/// Generate code for a simple lookup table
pub fn generate_lookup_table(
    hash_name: &str,
    table_data: &ExtractedTable,
) -> Result<String> {
    let metadata = &table_data.metadata;
    let source = &table_data.source;
    let mut code = String::new();
    
    // File header
    let constant_name = &metadata.constant_name;
    
    code.push_str(&format!(
        "//! Generated {} lookup table\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n//!\n//! Source: ExifTool {} {}\n//! Description: {}\n\n",
        constant_name.to_lowercase(),
        source.module,
        hash_name,
        metadata.description
    ));
    
    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use std::sync::LazyLock;\n\n");
    
    // Determine key type
    let key_type = &metadata.key_type;
    
    let key_rust_type = match key_type.as_str() {
        "u8" => "u8",
        "u16" => "u16",
        "u32" => "u32",
        "i8" => "i8",
        "i16" => "i16",
        "i32" => "i32",
        "f32" => "f32",
        "String" => "&'static str",
        _ => "&'static str",
    };
    
    // Determine value type
    // For now, all values are strings since metadata doesn't include value_type
    let value_rust_type = "&'static str";
    
    // Generate static HashMap
    code.push_str(&format!(
        "/// {} lookup table\n/// Source: ExifTool {} {} ({} entries)\npub static {}: LazyLock<HashMap<{}, {}>> = LazyLock::new(|| {{\n",
        metadata.description,
        source.module,
        hash_name,
        metadata.entry_count,
        constant_name,
        key_rust_type,
        value_rust_type
    ));
    
    code.push_str("    let mut map = HashMap::new();\n");
    
    // Sort entries for deterministic output
    let mut sorted_entries = table_data.entries.clone();
    sorted_entries.sort_by(|a, b| {
        if key_type == "String" {
            a.key.as_ref().unwrap_or(&String::new()).cmp(b.key.as_ref().unwrap_or(&String::new()))
        } else {
            let a_num: i64 = a.key.as_ref().unwrap_or(&String::new()).parse().unwrap_or(0);
            let b_num: i64 = b.key.as_ref().unwrap_or(&String::new()).parse().unwrap_or(0);
            a_num.cmp(&b_num)
        }
    });
    
    // Add entries
    for entry in &sorted_entries {
        if let (Some(key), Some(value)) = (&entry.key, &entry.value) {
            let key_value = if key_type == "String" {
                // Handle single quote specially for Rust string literals
                if key == "'" {
                    "\"'\"".to_string()
                } else {
                    format!("\"{}\"", escape_string(key))
                }
            } else {
                key.clone()
            };
            
            // Handle value - convert from JSON Value to string
            let value_str = {
                let value_string = match value {
                    serde_json::Value::String(s) => s.clone(),
                    serde_json::Value::Number(n) => n.to_string(),
                    serde_json::Value::Bool(b) => b.to_string(),
                    _ => value.to_string(),
                };
                // String value - escape and quote
                format!("\"{}\"", escape_string(&value_string))
            };
            
            code.push_str(&format!(
                "    map.insert({}, {});\n",
                key_value,
                value_str
            ));
        }
    }
    
    code.push_str("    map\n});\n\n");
    
    // Generate lookup function
    let fn_name = constant_name.to_lowercase();
    let fn_param_type = if key_type == "String" { "&str" } else { key_rust_type };
    
    code.push_str(&format!(
        "/// Look up {} value by key\npub fn lookup_{}(key: {}) -> Option<{}> {{\n",
        metadata.description.to_lowercase(),
        fn_name,
        fn_param_type,
        value_rust_type
    ));
    
    let key_ref = if key_type == "String" { "key" } else { "&key" };
    let return_expr = if value_rust_type == "&'static str" {
        format!("{}.get({}).copied()", constant_name, key_ref)
    } else {
        format!("{}.get({}).copied()", constant_name, key_ref)
    };
    code.push_str(&format!("    {}\n", return_expr));
    code.push_str("}\n");
    
    Ok(code)
}