//! Pure key-value lookup table generation
//! 
//! This module handles generation of simple HashMap-based lookup tables
//! like Canon white balance values, Nikon lens IDs, etc.
//! 
//! These are straightforward mappings from numeric or string keys to descriptive values.

pub mod standard;

use anyhow::Result;
use std::collections::HashMap;
use std::path::Path;
use std::fs;
use crate::schemas::{ExtractedTable, input::TableConfig};
use crate::generators::data_sets;
use tracing::{debug, info};

/// Process configuration files from a directory and generate module
pub fn process_config_directory(
    config_dir: &Path,
    module_name: &str,
    extracted_tables: &HashMap<String, ExtractedTable>,
    output_dir: &str,
) -> Result<()> {
    println!("    Processing config directory for module: {}", module_name);
    
    let mut module_content = String::new();
    let mut has_content = false;
    let mut uses_hashset = false;
    let mut uses_hashmap = false;
    
    // Generate module header
    module_content.push_str(&format!(
        "//! Generated lookup tables from ExifTool {}\n//!\n//! This file is automatically generated.\n//! DO NOT EDIT MANUALLY - changes will be overwritten.\n\n",
        module_name.replace("_pm", ".pm")
    ));
    
    // Check for simple_table.json configuration
    let simple_table_config = config_dir.join("simple_table.json");
    if simple_table_config.exists() {
        let config_content = fs::read_to_string(&simple_table_config)?;
        let config_json: serde_json::Value = serde_json::from_str(&config_content)?;
        
        if let Some(tables) = config_json["tables"].as_array() {
            uses_hashmap = true;
            module_content.push_str("\n// Simple lookup tables\n");
            
            for table_config in tables {
                let hash_name = table_config["hash_name"].as_str().unwrap_or("");
                if let Some(extracted_table) = extracted_tables.get(hash_name) {
                    // Generate the lookup table code using our updated generator
                    let table_code = standard::generate_lookup_table(hash_name, extracted_table)?;
                    module_content.push_str(&table_code);
                    module_content.push_str("\n");
                    has_content = true;
                }
            }
        }
    }
    
    // Check for boolean_set.json configuration
    let boolean_set_config = config_dir.join("boolean_set.json");
    if boolean_set_config.exists() {
        let config_content = fs::read_to_string(&boolean_set_config)?;
        let config_json: serde_json::Value = serde_json::from_str(&config_content)?;
        
        if let Some(tables) = config_json["tables"].as_array() {
            uses_hashset = true;
            module_content.push_str("\n// Boolean set tables\n");
            
            for table_config in tables {
                let hash_name = table_config["hash_name"].as_str().unwrap_or("");
                if let Some(extracted_table) = extracted_tables.get(hash_name) {
                    // Update the extracted table's metadata with config values
                    let mut updated_table = extracted_table.clone();
                    if let Some(constant_name) = table_config["constant_name"].as_str() {
                        updated_table.metadata.constant_name = constant_name.to_string();
                    }
                    if let Some(description) = table_config["description"].as_str() {
                        updated_table.metadata.description = description.to_string();
                    }
                    
                    // Generate the boolean set code
                    let table_code = data_sets::boolean::generate_boolean_set(hash_name, &updated_table)?;
                    module_content.push_str(&table_code);
                    module_content.push_str("\n");
                    has_content = true;
                }
            }
        }
    }
    
    // Only write the module if we have content
    if has_content {
        // Add imports at the beginning based on what we're using
        let mut imports = String::new();
        if uses_hashmap {
            imports.push_str("use std::collections::HashMap;\n");
        }
        if uses_hashset {
            imports.push_str("use std::collections::HashSet;\n");
        }
        imports.push_str("use std::sync::LazyLock;\n");
        
        // Insert imports after the header comment
        let header_end = module_content.find("\n\n").unwrap_or(0) + 2;
        module_content.insert_str(header_end, &imports);
        
        // Create module directory and write the mod.rs file
        let module_output_dir = Path::new(output_dir).join(module_name);
        fs::create_dir_all(&module_output_dir)?;
        
        let mod_file_path = module_output_dir.join("mod.rs");
        fs::write(&mod_file_path, module_content)?;
        
        println!("  âœ“ Generated {}", mod_file_path.display());
    }
    
    Ok(())
}

