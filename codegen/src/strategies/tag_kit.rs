//! TagKitStrategy - Processes ExifTool tag table definitions
//!
//! This strategy recognizes and processes hash symbols that contain tag definitions
//! with Names, PrintConv, ValueConv, etc. from field_extractor.pl FieldSymbol data.

use anyhow::Result;
use serde_json::Value as JsonValue;
use tracing::{debug, info, warn};

use super::{ExtractionContext, ExtractionStrategy, GeneratedFile};
use crate::common::utils::escape_string;
use crate::field_extractor::FieldSymbol;
use crate::impl_registry::{
    classify_valueconv_expression, lookup_printconv, lookup_tag_specific_printconv, ValueConvType,
};
use crate::ppi::{parse_ppi_json, ExpressionType, RustGenerator};
use crate::strategies::output_locations::generate_module_path;

/// Strategy for processing tag table definitions (Main, Composite, etc.)
pub struct TagKitStrategy {
    /// Tag table symbols processed per module
    processed_symbols: Vec<ProcessedTagTable>,
    /// Track imports needed for generated functions
    imports: std::collections::HashSet<(String, String)>, // (module_path, function_name)
}

#[derive(Debug, Clone)]
struct ProcessedTagTable {
    module_name: String,
    table_name: String,
    symbol_data: JsonValue,
}

impl Default for TagKitStrategy {
    fn default() -> Self {
        Self::new()
    }
}

impl TagKitStrategy {
    pub fn new() -> Self {
        Self {
            processed_symbols: Vec::new(),
            imports: std::collections::HashSet::new(),
        }
    }

    /// Register an import for a conversion function
    fn register_import(&mut self, module_path: &str, function_name: &str) {
        self.imports
            .insert((module_path.to_string(), function_name.to_string()));
    }

    /// Check if symbol contains tag definition patterns
    fn is_tag_table_symbol(symbol: &FieldSymbol) -> bool {
        // Don't claim Composite tables - let CompositeTagStrategy handle those
        // Check if this is marked as a composite table (has AddCompositeTags call)
        if symbol.metadata.is_composite_table == 1 {
            return false;
        }

        // Look for common tag table indicators in the data
        if let Some(data) = symbol.data.as_object() {
            // Check for ExifTool tag table characteristics
            let has_writable = data.contains_key("WRITABLE");
            let has_groups = data.contains_key("GROUPS");
            let _has_notes = data.contains_key("NOTES");
            let has_write_group = data.contains_key("WRITE_GROUP");

            // Tag tables often have these metadata fields
            if has_writable || has_groups || has_write_group {
                return true;
            }

            // Common tag table names (excluding Composite which we handle above)
            let common_tables = ["Main", "Extra", "Image"];
            if common_tables.contains(&symbol.name.as_str()) {
                return true;
            }

            // Check for actual tag definition structure in the data
            // Real tag tables have entries with Name, Format, PrintConv, etc.
            for (_key, value) in data {
                if let Some(entry) = value.as_object() {
                    // Look for tag definition fields
                    if entry.contains_key("Name")
                        || entry.contains_key("Format")
                        || entry.contains_key("Writable")
                        || entry.contains_key("PrintConv")
                        || entry.contains_key("ValueConv")
                    {
                        return true;
                    }
                }
            }
        }

        false
    }

    /// Generate Rust code from FieldSymbol tag table data  
    fn generate_tag_table_code(&mut self, symbol: &ProcessedTagTable) -> Result<String> {
        let table_data = symbol
            .symbol_data
            .as_object()
            .ok_or_else(|| anyhow::anyhow!("Expected tag table to be an object"))?;

        if table_data.is_empty() {
            return Ok(String::new());
        }

        // Clear imports for this specific symbol to avoid cross-contamination
        self.imports.clear();

        let mut code = String::new();
        code.push_str(&format!(
            "//! Generated tag table definitions from {}::{}\n",
            symbol.module_name, symbol.table_name
        ));
        code.push_str("//!\n");
        code.push_str("//! This file is auto-generated by codegen/src/strategies/tag_kit.rs. Do not edit manually.\n");
        code.push('\n');
        code.push_str("use std::sync::LazyLock;\n");
        code.push_str("use std::collections::HashMap;\n");
        code.push_str("use crate::types::{TagInfo, PrintConv, ValueConv};\n");

        // First collect all valid tag entries with their tag IDs for sorting
        // This will populate self.imports through register_import calls
        let mut tag_entries = Vec::new();
        for (tag_key, tag_data) in table_data {
            if let Some(tag_obj) = tag_data.as_object() {
                if let Some((tag_id, entry)) =
                    self.build_tag_entry(tag_key, tag_obj, &symbol.module_name)?
                {
                    tag_entries.push((tag_id, entry));
                }
            }
        }

        // Sort entries by tag ID for deterministic output
        tag_entries.sort_by_key(|(tag_id, _)| *tag_id);

        // Add imports for conversion functions (after processing tags)
        if !self.imports.is_empty() {
            code.push('\n');
            code.push_str("// Generated imports for conversion functions\n");
            let mut imports_by_module: std::collections::BTreeMap<String, Vec<String>> =
                std::collections::BTreeMap::new();

            for (module_path, function_name) in &self.imports {
                imports_by_module
                    .entry(module_path.clone())
                    .or_default()
                    .push(function_name.clone());
            }

            for (module_path, functions) in imports_by_module {
                code.push_str(&format!(
                    "use {}::{{{}}};\n",
                    module_path,
                    functions.join(", ")
                ));
            }
        }

        code.push('\n');

        // Generate constant name using proper snake_case conversion
        let module_snake_case =
            crate::strategies::output_locations::to_snake_case(&symbol.module_name);
        let constant_name = format!(
            "{}_{}_TAGS",
            module_snake_case.to_uppercase(),
            symbol.table_name.to_uppercase()
        );

        code.push_str(&format!(
            "/// Tag definitions for {}::{} table\n",
            symbol.module_name, symbol.table_name
        ));
        code.push_str(&format!(
            "pub static {constant_name}: LazyLock<HashMap<u16, TagInfo>> = LazyLock::new(|| {{\n"
        ));

        // Generate HashMap construction based on whether we have entries
        if tag_entries.is_empty() {
            code.push_str("    HashMap::new()\n");
        } else {
            code.push_str("    HashMap::from([\n");
            for (_, entry) in tag_entries {
                code.push_str(&entry);
            }
            code.push_str("    ])\n");
        }

        code.push_str("});\n\n");

        // Generate apply_value_conv function: TODO: can this be DRY'ed up and moved into src/ proper, not shoved into every generated file?
        code.push_str("/// Apply ValueConv transformation for tags in this table\n");
        code.push_str("pub fn apply_value_conv(\n");
        code.push_str("    tag_id: u32,\n");
        code.push_str("    value: &crate::types::TagValue,\n");
        code.push_str("    _errors: &mut Vec<String>,\n");
        code.push_str(") -> Result<crate::types::TagValue, String> {\n");
        code.push_str("    let tag_id_u16 = tag_id as u16;\n");
        code.push_str(&format!(
            "    if let Some(tag_def) = {constant_name}.get(&tag_id_u16) {{\n"
        ));
        code.push_str("        if let Some(ref value_conv) = tag_def.value_conv {\n");
        code.push_str("            match value_conv {\n");
        code.push_str("                ValueConv::None => Ok(value.clone()),\n");
        code.push_str("                ValueConv::Function(func) => func(value).map_err(|e| e.to_string()),\n");
        code.push_str("                ValueConv::Expression(expr) => {\n");
        code.push_str(
            "                    // Use runtime expression evaluator for dynamic evaluation\n",
        );
        code.push_str("                    let mut evaluator = crate::expressions::ExpressionEvaluator::new();\n");
        code.push_str("                    evaluator.evaluate_expression(expr, value).map_err(|e| e.to_string())\n");
        code.push_str("                }\n");
        code.push_str("                _ => Ok(value.clone()),\n");
        code.push_str("            }\n");
        code.push_str("        } else {\n");
        code.push_str("            Ok(value.clone())\n");
        code.push_str("        }\n");
        code.push_str("    } else {\n");
        code.push_str("        Err(format!(\"Tag 0x{:04x} not found in table\", tag_id))\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");

        // Generate apply_print_conv function
        code.push_str("/// Apply PrintConv transformation for tags in this table\n");
        code.push_str("pub fn apply_print_conv(\n");
        code.push_str("    tag_id: u32,\n");
        code.push_str("    value: &crate::types::TagValue,\n");
        code.push_str("    _evaluator: &mut crate::expressions::ExpressionEvaluator,\n");
        code.push_str("    _errors: &mut Vec<String>,\n");
        code.push_str("    _warnings: &mut Vec<String>,\n");
        code.push_str(") -> crate::types::TagValue {\n");
        code.push_str("    let tag_id_u16 = tag_id as u16;\n");
        code.push_str(&format!(
            "    if let Some(tag_def) = {constant_name}.get(&tag_id_u16) {{\n"
        ));
        code.push_str("        if let Some(ref print_conv) = tag_def.print_conv {\n");
        code.push_str("            match print_conv {\n");
        code.push_str("                PrintConv::None => value.clone(),\n");
        code.push_str("                PrintConv::Function(func) => func(value),\n");
        code.push_str("                PrintConv::Expression(expr) => {\n");
        code.push_str(
            "                    // Use runtime expression evaluator for dynamic evaluation\n",
        );
        code.push_str("                    _evaluator.evaluate_expression(expr, value).unwrap_or_else(|_| value.clone())\n");
        code.push_str("                }\n");
        code.push_str("                _ => value.clone(),\n");
        code.push_str("            }\n");
        code.push_str("        } else {\n");
        code.push_str("            value.clone()\n");
        code.push_str("        }\n");
        code.push_str("    } else {\n");
        code.push_str("        value.clone()\n");
        code.push_str("    }\n");
        code.push_str("}\n");

        Ok(code)
    }

    /// Build a single tag entry from the field_extractor data
    /// Returns (tag_id, formatted_entry) or None if the tag should be skipped
    fn build_tag_entry(
        &mut self,
        tag_key: &str,
        tag_data: &serde_json::Map<String, JsonValue>,
        module: &str,
    ) -> Result<Option<(u16, String)>> {
        // Extract basic tag information
        let name = tag_data
            .get("Name")
            .and_then(|v| v.as_str())
            .unwrap_or(tag_key);
        let format = tag_data
            .get("Format")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");

        // Parse tag ID (could be string or number)
        let tag_id = if let Ok(id) = tag_key.parse::<u16>() {
            id
        } else if tag_key.starts_with("0x") || tag_key.starts_with("0X") {
            u16::from_str_radix(&tag_key[2..], 16).unwrap_or(0)
        } else {
            debug!("Skipping non-numeric tag key: {}", tag_key);
            return Ok(None);
        };

        // Process PrintConv if present
        let print_conv = self.process_print_conv(tag_data, module, name)?;

        // Process ValueConv if present
        let value_conv = self.process_value_conv(tag_data, module, name)?;

        // Build the formatted entry
        let mut entry = String::new();
        entry.push_str(&format!("        ({tag_id}, TagInfo {{\n"));
        entry.push_str(&format!("            name: \"{name}\",\n"));
        entry.push_str(&format!("            format: \"{format}\",\n"));
        entry.push_str(&format!("            print_conv: {print_conv},\n"));
        entry.push_str(&format!("            value_conv: {value_conv},\n"));
        entry.push_str("        }),\n");

        Ok(Some((tag_id, entry)))
    }

    /// Process PrintConv field using PPI AST when available, falling back to existing impl_registry
    fn process_print_conv(
        &mut self,
        tag_data: &serde_json::Map<String, JsonValue>,
        module: &str,
        tag_name: &str,
    ) -> Result<String> {
        // **NEW: PPI AST field handling** - check for optional *_ast fields first
        if let Some(ast_value) = tag_data.get("PrintConv_ast") {
            if let Some(print_conv_str) = tag_data.get("PrintConv").and_then(|v| v.as_str()) {
                // We have both original expression and AST - try to generate from AST
                match self.try_generate_from_ppi_ast(
                    ast_value,
                    ExpressionType::PrintConv,
                    print_conv_str,
                    module,
                    tag_name,
                ) {
                    Ok(generated_code) => return Ok(generated_code),
                    Err(e) => {
                        debug!("PPI generation failed for PrintConv '{}': {}, falling back to registry", print_conv_str, e);
                        // Continue to registry fallback below
                    }
                }
            }
        }

        // **EXISTING: Check for PrintConv field using registry system**
        if let Some(print_conv_value) = tag_data.get("PrintConv") {
            if let Some(print_conv_str) = print_conv_value.as_str() {
                // First try tag-specific lookup
                if let Some((module_path, func_name)) =
                    lookup_tag_specific_printconv(module, tag_name)
                {
                    // Generate direct function call
                    self.register_import(module_path, func_name);
                    return Ok(format!("Some(PrintConv::Function({func_name}))"));
                }

                // Then try expression lookup
                if let Some((module_path, func_name)) = lookup_printconv(print_conv_str, module) {
                    // Generate direct function call
                    self.register_import(module_path, func_name);
                    return Ok(format!("Some(PrintConv::Function({func_name}))"));
                }

                // For hash references (lookup tables), generate Simple variant
                if print_conv_str.starts_with("{") || print_conv_str.contains("=>") {
                    // This indicates a hash lookup - we'd need to parse it
                    // For now, leave as raw expression
                    return Ok(format!(
                        "Some(PrintConv::Expression(\"{}\".to_string()))",
                        escape_string(print_conv_str)
                    ));
                }

                // Default to Expression type for any other string
                return Ok(format!(
                    "Some(PrintConv::Expression(\"{}\".to_string()))",
                    escape_string(print_conv_str)
                ));
            } else if let Some(_print_conv_obj) = print_conv_value.as_object() {
                // This is likely a hash reference lookup table
                return Ok("Some(PrintConv::Complex)".to_string());
            }
        }

        // No PrintConv found
        Ok("None".to_string())
    }

    /// Process ValueConv field using PPI AST when available, falling back to existing impl_registry
    fn process_value_conv(
        &mut self,
        tag_data: &serde_json::Map<String, JsonValue>,
        module: &str,
        tag_name: &str,
    ) -> Result<String> {
        // **NEW: PPI AST field handling** - check for optional *_ast fields first
        if let Some(ast_value) = tag_data.get("ValueConv_ast") {
            if let Some(value_conv_str) = tag_data.get("ValueConv").and_then(|v| v.as_str()) {
                // We have both original expression and AST - try to generate from AST
                match self.try_generate_from_ppi_ast(
                    ast_value,
                    ExpressionType::ValueConv,
                    value_conv_str,
                    module,
                    tag_name,
                ) {
                    Ok(generated_code) => return Ok(generated_code),
                    Err(e) => {
                        debug!("PPI generation failed for ValueConv '{}': {}, falling back to registry", value_conv_str, e);
                        // Continue to registry fallback below
                    }
                }
            }
        }

        // **EXISTING: Check for ValueConv field using registry system**
        if let Some(value_conv_value) = tag_data.get("ValueConv") {
            if let Some(value_conv_str) = value_conv_value.as_str() {
                // Use the orchestration layer for proper priority handling
                match classify_valueconv_expression(value_conv_str, module) {
                    ValueConvType::CustomFunction(module_path, func_name) => {
                        // Registry match - generate direct function call
                        self.register_import(module_path, func_name);
                        return Ok(format!("Some(ValueConv::Function({func_name}))"));
                    }
                    ValueConvType::CompiledExpression(_compiled) => {
                        // Expression can be compiled - store as expression for runtime compilation
                        return Ok(format!(
                            "Some(ValueConv::Expression(\"{}\".to_string()))",
                            escape_string(value_conv_str)
                        ));
                    }
                }
            } else if let Some(_value_conv_obj) = value_conv_value.as_object() {
                // This is likely a complex conversion
                return Ok("Some(ValueConv::Complex)".to_string());
            }
        }

        // No ValueConv found
        Ok("None".to_string())
    }

    /// Try to generate code from PPI AST, fall back to registry on failure
    fn try_generate_from_ppi_ast(
        &mut self,
        ast_value: &JsonValue,
        expression_type: ExpressionType,
        original_expression: &str,
        module: &str,
        tag_name: &str,
    ) -> Result<String> {
        // Parse the PPI JSON AST
        let ppi_ast =
            parse_ppi_json(ast_value).map_err(|e| anyhow::anyhow!("PPI parsing failed: {}", e))?;

        // Generate function name from module, tag name, and expression type
        let function_name = format!(
            "{}_{}_{}",
            crate::strategies::output_locations::to_snake_case(module),
            crate::strategies::output_locations::to_snake_case(tag_name),
            match expression_type {
                ExpressionType::PrintConv => "print_ast",
                ExpressionType::ValueConv => "value_ast",
                ExpressionType::Condition => "condition_ast",
            }
        );

        // Create Rust code generator
        let generator = RustGenerator::new(
            expression_type,
            function_name.clone(),
            original_expression.to_string(),
        );

        // Generate the Rust function code
        let generated_function = generator
            .generate_function(&ppi_ast)
            .map_err(|e| anyhow::anyhow!("Code generation failed: {}", e))?;

        // Return the appropriate wrapper based on expression type
        match expression_type {
            ExpressionType::PrintConv => {
                Ok(format!("Some(PrintConv::Function({}))", function_name))
            }
            ExpressionType::ValueConv => {
                Ok(format!("Some(ValueConv::Function({}))", function_name))
            }
            ExpressionType::Condition => {
                Ok(format!("Some(Condition::Function({}))", function_name))
            }
        }
    }
}

impl ExtractionStrategy for TagKitStrategy {
    fn name(&self) -> &'static str {
        "TagKitStrategy"
    }

    fn can_handle(&self, symbol: &FieldSymbol) -> bool {
        let result = Self::is_tag_table_symbol(symbol);
        debug!("TagKitStrategy::can_handle({}) -> {}", symbol.name, result);
        result
    }

    fn extract(
        &mut self,
        symbol_data: &FieldSymbol,
        context: &mut ExtractionContext,
    ) -> Result<()> {
        context.log_strategy_selection(
            symbol_data,
            self.name(),
            "Detected tag table with PrintConv/ValueConv definitions",
        );

        // Store the symbol data directly for processing
        let processed_table = ProcessedTagTable {
            module_name: symbol_data.module.clone(),
            table_name: symbol_data.name.clone(),
            symbol_data: symbol_data.data.clone(),
        };

        debug!(
            "Stored TagTable symbol: {}::{}",
            processed_table.module_name, processed_table.table_name
        );
        self.processed_symbols.push(processed_table);

        Ok(())
    }

    fn finish_module(&mut self, _module_name: &str) -> Result<()> {
        // Nothing to do per-module
        Ok(())
    }

    fn finish_extraction(&mut self) -> Result<Vec<GeneratedFile>> {
        let mut files = Vec::new();

        if self.processed_symbols.is_empty() {
            return Ok(files);
        }

        info!(
            "Processing {} TagTable symbols",
            self.processed_symbols.len()
        );

        let symbols = self.processed_symbols.clone();
        for symbol in &symbols {
            match self.generate_tag_table_code(symbol) {
                Ok(code) => {
                    if !code.trim().is_empty() {
                        let path = generate_module_path(
                            &symbol.module_name,
                            &format!("{}_tags", symbol.table_name),
                        );

                        files.push(GeneratedFile {
                            path,
                            content: code,
                            strategy: self.name().to_string(),
                        });

                        debug!(
                            "Generated TagTable code for {}::{}",
                            symbol.module_name, symbol.table_name
                        );
                    }
                }
                Err(e) => {
                    warn!(
                        "Failed to generate code for {}::{}: {}",
                        symbol.module_name, symbol.table_name, e
                    );
                }
            }
        }

        // Clear processed symbols
        self.processed_symbols.clear();

        info!("TagKitStrategy generated {} files", files.len());
        Ok(files)
    }
}
