//! MagicNumberStrategy for processing ExifTool's magic number regex patterns
//!
//! This strategy handles the %magicNumber symbol which contains regex patterns
//! for binary file type detection (e.g., "JPEG":"\\xff\\xd8\\xff")
//!
//! The working approach converts simple literal byte patterns to byte arrays
//! and marks complex patterns as "complex" with empty arrays.

use anyhow::Result;
use serde_json::Value as JsonValue;
use std::collections::HashMap;
use tracing::{debug, info};

use super::{ExtractionContext, ExtractionStrategy, GeneratedFile};
use crate::common::utils::{classify_magic_pattern, PatternClassification};
use crate::field_extractor::FieldSymbol;
use crate::strategies::output_locations::generate_module_path;

/// Strategy for processing ExifTool's magicNumber regex patterns
pub struct MagicNumberStrategy {
    /// Collected magic number data by module
    magic_data: HashMap<String, MagicNumberData>,
}

/// Magic number patterns extracted from ExifTool
#[derive(Debug, Clone)]
struct MagicNumberData {
    /// File type to raw byte array mappings (for all patterns, before classification)
    patterns: HashMap<String, Vec<u8>>,
    /// Classified literal patterns (file_type -> byte_array)
    literal_patterns: HashMap<String, Vec<u8>>,
    /// Classified regex patterns (file_type -> pattern_string)
    regex_patterns: HashMap<String, String>,
}

impl MagicNumberStrategy {
    /// Create new MagicNumberStrategy
    pub fn new() -> Self {
        Self {
            magic_data: HashMap::new(),
        }
    }

    /// Generate Rust code for magic number patterns
    /// Creates two separate HashMaps: one for literal patterns, one for regex patterns
    fn generate_magic_number_code(&self, data: &MagicNumberData) -> String {
        let mut code = String::new();

        // File header
        code.push_str("//! Generated magic number patterns from ExifTool's magicNumber hash\n");
        code.push_str("//!\n");
        code.push_str("//! Source: ExifTool.pm %magicNumber\n");
        code.push_str("//!\n");
        code.push_str("//! This file is auto-generated by codegen/src/strategies/magic_numbers.rs. Do not edit manually.\n\n");

        // Imports
        code.push_str("use std::collections::HashMap;\n");
        code.push_str("use std::sync::LazyLock;\n");
        code.push_str("use regex::bytes::{Regex, RegexBuilder};\n\n");

        // Generate literal patterns HashMap for fast byte matching
        code.push_str("/// Literal magic number patterns as byte slices for fast comparison\n");
        code.push_str("/// These patterns can be matched directly without regex compilation\n");
        code.push_str("pub static LITERAL_MAGIC_NUMBERS: LazyLock<HashMap<&'static str, &'static [u8]>> = LazyLock::new(|| {\n");
        code.push_str("    let mut map = HashMap::new();\n\n");

        // Sort literal patterns for consistent output
        let mut literal_patterns: Vec<_> = data.literal_patterns.iter().collect();
        literal_patterns.sort_by_key(|&(k, _)| k);

        for (file_type, byte_pattern) in &literal_patterns {
            let byte_list = byte_pattern
                .iter()
                .map(|b| format!("{b}"))
                .collect::<Vec<_>>()
                .join(", ");

            code.push_str(&format!(
                "    map.insert(\"{file_type}\", &[{byte_list}][..]);\n"
            ));
        }

        code.push_str("\n    map\n");
        code.push_str("});\n\n");

        // Generate regex patterns HashMap for complex matching
        code.push_str("/// Complex regex magic number patterns\n");
        code.push_str("/// These patterns require regex compilation and are used as fallback\n");
        code.push_str("pub static REGEX_MAGIC_NUMBERS: LazyLock<HashMap<&'static str, Regex>> = LazyLock::new(|| {\n");
        code.push_str("    let mut map = HashMap::new();\n\n");

        // Sort regex patterns for consistent output
        let mut regex_patterns: Vec<_> = data.regex_patterns.iter().collect();
        regex_patterns.sort_by_key(|&(k, _)| k);

        for (file_type, pattern_str) in &regex_patterns {
            // For display purposes, escape backslashes and quotes
            let display_pattern = pattern_str.replace('\\', "\\\\").replace('"', "\\\"");

            // For raw string literals, we need to handle potential quote conflicts
            let raw_pattern = if pattern_str.contains('"') {
                // If the pattern contains quotes, we need to escape them properly
                format!("r#\"{}\"#", pattern_str.replace("\\", "\\\\"))
            } else {
                // Simple raw string works fine
                format!("r\"{pattern_str}\"")
            };

            code.push_str(&format!("    // Pattern: {display_pattern}\n"));
            code.push_str(&format!(
                "    if let Ok(regex) = RegexBuilder::new({raw_pattern})\n"
            ));
            code.push_str("        .unicode(false)\n");
            code.push_str("        .build() {\n");
            code.push_str(&format!("        map.insert(\"{file_type}\", regex);\n"));
            code.push_str("    }\n\n");
        }

        code.push_str("    map\n");
        code.push_str("});\n");

        code
    }
}

impl ExtractionStrategy for MagicNumberStrategy {
    fn name(&self) -> &'static str {
        "MagicNumberStrategy"
    }

    fn can_handle(&self, symbol: &FieldSymbol) -> bool {
        // Only handle magicNumber from ExifTool module
        if symbol.name != "magicNumber" || symbol.module != "ExifTool" {
            return false;
        }

        // Must be a hash with raw_bytes values (from enhanced field_extractor.pl)
        if let JsonValue::Object(map) = &symbol.data {
            if map.is_empty() {
                return false;
            }

            // All values must be objects with raw_bytes arrays
            let all_raw_bytes = map
                .values()
                .all(|v| v.is_object() && v.get("raw_bytes").is_some_and(|rb| rb.is_array()));

            debug!(
                "magicNumber pattern check: all_raw_bytes={}, size={}",
                all_raw_bytes,
                map.len()
            );

            all_raw_bytes
        } else {
            false
        }
    }

    fn extract(&mut self, symbol: &FieldSymbol, context: &mut ExtractionContext) -> Result<()> {
        info!("ðŸ”§ Extracting magicNumber raw byte patterns");

        if let JsonValue::Object(map) = &symbol.data {
            let mut patterns = HashMap::new();
            let mut literal_patterns = HashMap::new();
            let mut regex_patterns = HashMap::new();

            for (file_type, value) in map {
                if let Some(obj) = value.as_object() {
                    if let Some(raw_bytes) = obj.get("raw_bytes") {
                        if let Some(bytes_array) = raw_bytes.as_array() {
                            // Convert JSON array of numbers to Vec<u8>
                            let mut byte_vec = Vec::new();
                            for byte_val in bytes_array {
                                if let Some(byte_num) = byte_val.as_u64() {
                                    if byte_num <= 255 {
                                        byte_vec.push(byte_num as u8);
                                    }
                                }
                            }

                            // Store raw patterns
                            patterns.insert(file_type.clone(), byte_vec.clone());

                            // Classify pattern and store in appropriate HashMap
                            match classify_magic_pattern(&byte_vec) {
                                PatternClassification::Literal(literal_bytes) => {
                                    literal_patterns.insert(file_type.clone(), literal_bytes);
                                }
                                PatternClassification::Regex => {
                                    // Convert raw bytes back to pattern string for regex compilation
                                    let pattern_str = String::from_utf8_lossy(&byte_vec);
                                    regex_patterns
                                        .insert(file_type.clone(), pattern_str.to_string());
                                }
                            }
                        }
                    }
                }
            }

            let data = MagicNumberData {
                patterns,
                literal_patterns: literal_patterns.clone(),
                regex_patterns: regex_patterns.clone(),
            };

            info!(
                "    âœ“ Parsed {} magic number patterns ({} literal, {} regex)",
                data.patterns.len(),
                literal_patterns.len(),
                regex_patterns.len()
            );

            self.magic_data.insert(symbol.module.clone(), data);

            context.log_strategy_selection(
                symbol,
                self.name(),
                &format!("Hash with raw byte array values for magic number detection ({} literal, {} regex patterns)", 
                    literal_patterns.len(), regex_patterns.len()),
            );
        }

        Ok(())
    }

    fn finish_module(&mut self, _module_name: &str) -> Result<()> {
        // No per-module finalization needed
        Ok(())
    }

    fn finish_extraction(
        &mut self,
        _context: &mut ExtractionContext,
    ) -> Result<Vec<GeneratedFile>> {
        let mut files = Vec::new();

        for data in self.magic_data.values() {
            let content = self.generate_magic_number_code(data);

            files.push(GeneratedFile {
                path: generate_module_path("ExifTool", "magic_numbers"),
                content,
            });

            info!(
                "ðŸ“ Generated magic_numbers.rs with {} magic number patterns",
                data.patterns.len()
            );
        }

        Ok(files)
    }
}

impl Default for MagicNumberStrategy {
    fn default() -> Self {
        Self::new()
    }
}
